<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>状压 DP 总结 &amp; 练习简要题解</title>
      <link href="/posts/State-Compression-Dynamic-Programming/"/>
      <url>/posts/State-Compression-Dynamic-Programming/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>状压 DP 就是状态压缩 DP，表现为把某一些状态（比如说某个元素是否被取过）压缩成二进制（当然也有别的进制），用这个进制下某个数的表示来表示一个状态，然后把这个状态作为 $dp$ 数组的一维来状态转移。</p><p>比如说有 $5$ 个元素，$1,2,4$ 已经被取过，$3,5$ 还没有。可以用如下二进制数来表示：</p><script type="math/tex; mode=display">(11010)_2=(26)_{10}</script><p>那么 $dp$ 数组就可以开一维来记录状态，当这一维的下标为 $26$ 时，就代表这个状态。<del>所以状压题的数据范围非常的明显，当然，这种数据范围也不排除暴搜的可能性。</del></p><p><del>对，总结就这么点。</del> 其实做状压 DP 就是不停地做题。</p><hr><h2 id="练习题目记录（怎么错的）"><a href="#练习题目记录（怎么错的）" class="headerlink" title="练习题目记录（怎么错的）"></a>练习题目记录（怎么错的）</h2><p>因为蒟蒻 ljt 做状压每一道都要调很久很久，所以 ta 决定把这些玩意儿记录下来。</p><p>当然这个东西是写给自己看的，所以写得比较混乱，如果您需要且看不懂的话可以问我 qwq。<del>当然肯定是没人需要的。</del></p><p>A. 牧场的安排</p><ul><li>$\text{82pts}$ 初始化了第一行，结果没考虑到数据只有一行的情况。</li></ul><p>B. 最小总代价</p><ul><li>$\text{0pts}$ 题意理解错了又没看样例。</li><li>$\text{95pts}$ <code>(1 &lt;&lt; N) - 1</code> 误打成了 <code>(1 &lt;&lt; N + 1) - 1</code>（忘改过来了）。</li></ul><p>C. 项链</p><ul><li>$\text{0pts}$  四重循环被老爷机制裁了。</li><li>$\text{10pts}$ 比较玄学，把范围改成 $0\sim n-1$ 就过了。</li></ul><p>D. 国王</p><ul><li>$\text{0pts}$ <code>num(y)</code> 误打成了 <code>num(x)</code>（记得分清楚每个变量的意义！）。</li></ul><p>E. Hie with the Pie</p><ul><li>$\text{0pts}$ 没有理解做法，Floyd 的用处。</li><li>$\text{15pts}$ 没加多组数据。</li></ul><p>F. Traveling</p><ul><li>$\text{0pts}$ 锅太多了，主要有以下几个：<ul><li>预处理错误，没有真正弄明白预处理数组的意义。</li><li>循环顺序错误，枚举状态应该写在在最外面。</li><li>你没事加什么并查集啊！</li><li>数组两维大小不一样，开反了。</li></ul></li></ul><p>H. 炮兵阵地</p><ul><li>$\text{0pts}$ 运算符优先级的问题，众所周知 <code>+</code> 优先级比三目运算符高。 /yiw</li><li>$\text{40pts}$ 数组开小了。</li></ul><p>O. 集合选数</p><ul><li>$\text{0pts}$ 把加法原理和乘法原理弄混。</li><li>$\text{30pts}$ 构造矩阵的问题，$o$ 只需要乘一遍就可以了，我多乘了一遍，没有去重。</li><li>$\text{60pts}$ <code>memset</code> 速度过慢。</li><li>$\text{90pts}$ 打表出奇迹！</li></ul><hr><h2 id="简要题解"><a href="#简要题解" class="headerlink" title="简要题解"></a>简要题解</h2><h3 id="A-牧场的安排"><a href="#A-牧场的安排" class="headerlink" title="A. 牧场的安排"></a>A. 牧场的安排</h3><blockquote><p>题意：有一个 $N\times M$ 的矩阵，有些格子里面可以种草，但是不能有相邻的格子同时种草（相邻指上下左右）。给出一个矩阵 $a$，$a_{i,j}=1/0$ 代表 $i$ 行 $j$ 列的格子可以/不可以种草。求种草的方案总数，答案需要 $\bmod\ 10^8$。$1\le N,M\le 12$。</p></blockquote><p>$dp_{i,j}$ 代表前 $i$ 行，最后一行状态为 $j$ 时的方案数量。其中 $j$ 是一个二进制数，<strong>从高位到低位</strong>编号为 $1,2,3,\ldots$ 分别代表第 $1,2,3,\ldots$ 块地种不种草，$1$ 代表种了，$0$ 代表没种。</p><p>然后每枚举到某一行的某个状态时，在这个状态下，我们需要知道三件事：</p><ol><li>这一行的状态有相邻的格子种草吗？</li><li>这一行和上一行有相邻的格子种草吗？</li><li>这一行是否有一些格子本来不能种草却被种上了？</li></ol><p>只有这三个问题的回答都是“不”，这个状态才是合法的。</p><p>要知道这三个问题的答案，我们还需要知道上一行的状态（回答第二个问题和状态转移）。所以可以再打一层循环枚举上一层的状态。那如何判断这三个问题呢？使用位运算就可以了。</p><p>首先看第一个，要判断一个二进制数当中是否有相邻的 $1$。我们知道按位与可以找到两个数同一个位置上同时存在的 $1$，那我们换个思考方向，如果把这个数本身左移或者右移一位呢？此时这两个数要是再按位与之后结果还是不为 $0$，那么就说明这两个数至少有一个地方有同一个位置上同时存在 $1$。而因为其中一个数是由另一个数左移/右移过来的，也就是说明至少有一个位置上的 $1$ 左边/右边有一个相邻的 $1$，也就是说有两个 $1$ 相邻，则不符合条件。</p><p>举个例子：<code>100101100101</code></p><p>左移一位后按位与：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 100101100101</span><br><span class="line">100101100101</span><br><span class="line">--------------</span><br><span class="line">0000001000000</span><br></pre></td></tr></table></figure><p>可以看到结果不为 $0$，则说明这个状态是不合法的。实际上，确实有两个 $1$ 连在一起了。</p><p>再来看第二个。要判断两个数是否有同一个位置上同时存在 $1$，这个很简单，甚至不需要任何处理，直接把两个数按位与一下即可，要是结果不为 $0$ 则代表状态不合法。</p><p>最后看第三个。其实我们检查的是<strong>一个二进制数的 $\textbf{1}$ 的集合是否完全包含另一个二进制数的 $\textbf{1}$ 的集合</strong>（这里的“集合”是指 $1$ 的位置的集合）。那么我们可以把两个数按位或，再检查按位或之后的结果是否等于集合范围更大的那个数。如果不相等，则代表大集合不能完全包含小集合，不合法。（思考一下，为什么？）</p><p>确定好了三个条件之后，我们终于可以愉快地转移状态了。</p><script type="math/tex; mode=display">dp_{i,j}=\sum\limits_{k=0}^{2^n-1}dp_{i-1,k}</script><p>（当然计算和的时候要满足三个条件了才能加。）</p><p>初始化 $dp_{0,0}=1$。<del>个人觉得状压 DP 的初始化是个很玄学的东西。</del></p><p>时间复杂度 $\Theta(n2^n)$。</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5101</span>, mod = (<span class="keyword">int</span>)<span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, N, x, ans, num[<span class="number">15</span>], dp[<span class="number">15</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    N = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            num[i] = (num[i] &lt;&lt; <span class="number">1</span>) + x; <span class="comment">// 把给出的矩阵转换成 n 个二进制数方便判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; <span class="comment">// 第 i 行</span></span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, N) &#123; <span class="comment">// 第 i 行的状态</span></span><br><span class="line">            <span class="keyword">if</span>(j &amp; (j &lt;&lt; <span class="number">1</span>) || (j | num[i]) ^ num[i]) <span class="comment">// 这里想写成 != 也可以，想写成异或也行，看大家的习惯咯</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">rep</span>(k, <span class="number">0</span>, N) &#123; <span class="comment">// 第 i-1 行的状态</span></span><br><span class="line">                <span class="keyword">if</span>(!(k &amp; j))</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][k]) % mod; <span class="comment">// 状态转移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == n)</span><br><span class="line">                ans = (ans + dp[i][j]) % mod; <span class="comment">// 计算答案，也可以拎出来单独写循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="B-最小总代价"><a href="#B-最小总代价" class="headerlink" title="B. 最小总代价"></a>B. 最小总代价</h3><blockquote><p>题意：$n$ 个人传物品，从任意一个人开始，每个人只能接一次物品。每两个人之间传物品都要付出一定的代价，求把物品传给所有的人的最小代价和。$2\le n\le 16$。</p></blockquote><p>PS. 这道题我写的是 $\Theta(n^22^n)$，但其实有更优的 $\Theta(n2^n)$ 算法。不过没关系，因为状压的解题思路都差不多，那种思路我会在后面介绍，所以也可以看一看我当初的想法。</p><p>$dp_{i,j,k}$ 表示目前传到的人数的个数为 $i$，状态为 $j$（从<strong>低位往高位数</strong>第 $i$ 位代表第 $i$ 个人是否已经被传到），且东西是第 $k$ 个人给出的（给谁了不知道）时的最小代价和。<del>所以很明显这个 $i$ 是不需要的 qwq。</del></p><blockquote><p>这里注意一下，上一道题是从高位到低位，这道题是从低位到高位，这是题目给法不一样造成的结果。上一道题题目是直接给出了我们需要使用的矩阵，那么从左往右遍历比较方便，而这道题我们需要知道在传递之前到传递之后状态的变化（而不是通过枚举得到两个状态，详情见后文），所以左移多少位肯定是从低位往高位写比较舒服。不管怎么样，我们写代码都是为了思考方便、写起来方便而定义的，当然如果两样都需要，我们就要考虑考虑如何处理这个冲突了。</p></blockquote><p>在转移的时候，还需要加一层循环，枚举是谁收到了 $k$ 给的物品，这样才可以确定加上的代价。</p><p>至于转移过程中还有一些剪枝或者判断，只有合法的情况才能继续下一层循环。这个过程可以看代码。</p><p>转移状态：</p><script type="math/tex; mode=display">dp_{i,j|2^{k-1},k}=\min\limits_{l=1}^{n}\{dp_{i-1,j,l}+a_{k,l}\}</script><p>初始化 $dp$ 极大值，$dp_{1,0\sim 2^n-1,1\sim n}=0$。</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, N, ans = <span class="number">1</span> &lt;&lt; <span class="number">30</span>, a[<span class="number">20</span>][<span class="number">20</span>], dp[<span class="number">20</span>][maxn][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 这个函数用来统计一个数的二进制中有多少个 1</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        s += (x &amp; <span class="number">1</span>);</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(dp[<span class="number">1</span>], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    N = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123; <span class="comment">// 收到的是第几个人 </span></span><br><span class="line">        <span class="built_in">rep</span>(f, <span class="number">1</span>, n) &#123; <span class="comment">// 从谁那里传过来的 </span></span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">0</span>, N) &#123; <span class="comment">// 上一个状态 </span></span><br><span class="line">                <span class="keyword">if</span>(!(j &amp; (<span class="number">1</span> &lt;&lt; f - <span class="number">1</span>)) || <span class="built_in">num</span>(j) != i - <span class="number">1</span>) <span class="comment">// 判断此状态是否和 i、k 贴合</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">rep</span>(k, <span class="number">1</span>, n) &#123; <span class="comment">// 谁收到了 </span></span><br><span class="line">                    <span class="keyword">if</span>(!(j &amp; (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>)) &amp;&amp; f != k)</span><br><span class="line">                        dp[i][j | (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>)][k] = <span class="built_in">min</span>(dp[i][j | (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>)][k], dp[i - <span class="number">1</span>][j][f] + a[f][k]);</span><br><span class="line">                    <span class="keyword">if</span>(i == n)</span><br><span class="line">                        ans = <span class="built_in">min</span>(ans, dp[i][j | (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>)][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="C-项链"><a href="#C-项链" class="headerlink" title="C. 项链"></a>C. 项链</h3><blockquote><p>题意：有 $n$ 个贝壳和 $m$ 组贝壳能连接的关系，每一组关系形如 $a_i,b_i$ 代表第 $a_i$ 和第 $b_i$ 个贝壳可以连接。项链是首尾相接的，而且要求用上所有的贝壳。求组成项链的方案数量。多组数据，$1\le T\le 5$，$1\le n\le 18$。</p></blockquote><p>这道题打 $\Theta(n^22^n)$ 会 T + M 到飞起，所以还是老老实实打 $\Theta(n2^n)$ 吧。</p><p>因为项链是环状，所以哪一个贝壳在第一个都无所谓。既然如此，我们不妨让第一个贝壳为首，只要最后一个贝壳可以和它相连就可以了。这样我们就把环搞成了链。</p><p>接着，$dp_{i,j}$ 表示目前的最后一个贝壳是第 $i$ 个，状态为 $j$（这次还是从低到高）时的方案总数量。状态转移时枚举上一个贝壳是哪一个，如果两个贝壳可以连接就加上。<del>都是套路。</del></p><script type="math/tex; mode=display">dp_{i,j}=\sum\limits_{k=1}^n dp_{k,j-2^i}</script><p>初始化 $dp_{0,0}=1$。</p><p>记得要开 <code>long long</code>。</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, u, v;</span><br><span class="line">ll dp[<span class="number">20</span>][maxn];</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line">        <span class="keyword">int</span> N = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            --u, --v;</span><br><span class="line">            b[u][v] = b[v][u] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">            b[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, N) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(j &amp; (<span class="number">1</span> &lt;&lt; i)))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">rep</span>(k, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j &amp; (<span class="number">1</span> &lt;&lt; k) &amp;&amp; b[i][k])</span><br><span class="line">                        dp[i][j] += dp[k][j - (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i][<span class="number">0</span>])</span><br><span class="line">                ans += dp[i][N];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS. 话说，你们有没有发现其实状压从 $0$ 开始貌似更好操作一些，因为二进制的最低为代表的是 $2^0$ 而不是 $2^1$ 嘛。比如这道题，我之前是从 $1$ 开始的死活过不了，结果改成从 $0$ 开始就神奇地过了 <del>（XSC062：说啥呢，还不是老子给你改的）</del>，只可惜我从 $1$ 开始写习惯了，所以一般来说只要能过我都还是从 $1$ 开始……</p><hr><h3 id="D-国王"><a href="#D-国王" class="headerlink" title="D. 国王"></a>D. 国王</h3><p><del>其实就是互不侵犯，鬼知道为啥要改名。</del></p><blockquote><p>题意：在 $n\times n$ 的棋盘上放 $k$ 个国王，国王可攻击相邻的 $8$ 个格子，求使它们无法互相攻击的方案总数。</p></blockquote><p>这道题因为规定了个数为 $k$ 个，所以除了状压需要的第 $i$ 行和状态为 $j$ 之外（这次 $j$ 从高到低和从低到高没有影响，可以自己想一想为什么 qwq），还需要一维确定目前已经有的个数。</p><p>$dp_{i,j,k}$ 代表前 $i$ 行，第 $i$ 行状态为 $j$，已经放了 $k$ 个国王时的方案总数量。</p><p>判断是否相邻方法和 A 题类似，都是用位运算。这道题多了四个角落的格子，其实很好解决，只需要把上一行左移一位按位与，右移一位按位与，看结果是不是 $0$ 即可（原理也在 A 当中说了）。</p><p>状态转移：</p><script type="math/tex; mode=display">dp_{i,j,k}=\sum\limits_{l=0}^{2^n-1}dp_{i-1,l,k-\text{numone}(l)}</script><p>（$\text{numone}$ 指一个二进制数中 $1$ 的个数，所以 $numone$ 可以预处理或者是打一个函数。）</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            w |= ch == <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            ch = <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>);</span><br><span class="line">            ch = <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w ? -x : x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">9</span>) <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">ll ans, dp[<span class="number">15</span>][<span class="number">105</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        s += x &amp; <span class="number">1</span>; <span class="comment">// 末位是不是 1</span></span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>; <span class="comment">// 右移一位，把判断过的末位扔掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(k &gt; (n * n) &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, k) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(x, <span class="number">0</span>, N) &#123;</span><br><span class="line">                <span class="keyword">if</span>(x &amp; (x &lt;&lt; <span class="number">1</span>) || j &lt; <span class="built_in">num</span>(x))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">rep</span>(y, <span class="number">0</span>, N) &#123; <span class="comment">// 枚举上一行的状态</span></span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= <span class="built_in">num</span>(y) &amp;&amp; !(x &amp; y) &amp;&amp; !(y &amp; (y &lt;&lt; <span class="number">1</span>)) &amp;&amp; !(x &amp; (y &lt;&lt; <span class="number">1</span>)) &amp;&amp; !(x &amp; (y &gt;&gt; <span class="number">1</span>))) <span class="comment">// 判断条件</span></span><br><span class="line">                        dp[i][j][y] += dp[i - <span class="number">1</span>][j - <span class="built_in">num</span>(y)][x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, N)</span><br><span class="line">        ans += dp[n][k][i]; <span class="comment">// 统计答案</span></span><br><span class="line">    <span class="built_in">write</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS. 有一个点需要大家注意，就是打状压的时候一定要弄清楚每一层循环的变量代表的是啥，状态转移的时候需要注意，尤其是同一种类型的变量！不然打错了很难调出来。</p><hr><h3 id="E-Hie-with-the-Pie"><a href="#E-Hie-with-the-Pie" class="headerlink" title="E. Hie with the Pie"></a>E. Hie with the Pie</h3><blockquote><p>题意：一个有 $n+1$ 个点的有向完全图，结点依次编号为 $0,1,\ldots,n$，给出其邻接矩阵（注意从 $i$ 到 $j$ 的距离不一定等于从 $j$ 到 $i$ 的距离）。请求出从 $0$ 号点出发，走过 $1$ 到 $n$ 号点至少一次，然后再回到 $0$ 号点的最短路。$1\le n\le 10$。</p></blockquote><p>注意到每个点都必须走，于是想到状压。</p><p>$dp_{i,j}$ 表示从 $0$ 出发，到了 $i$ 点，且状态为 $j$ 时的最短路。状态转移时，枚举上一个经过的点为 $k$，此时我们发现状态转移需要知道任意两个点 （$i$ 和 $k$）之间的最短路，所以我们先跑一遍 Floyd 预处理出任意两个点之间的最短路再转移，方程如下：</p><script type="math/tex; mode=display">dp_{i,j}=\min\limits_{k=1}^n\{dp_{k,j-2^{i-1}}+f(i,k)\}</script><p>然鹅，这道题难在于细节。</p><p>首先注意循环几层的顺序，外层必须是 $j$，因为 $j$ 的转移是从小到大的转移，而 $i$ 和 $k$ 都是无序的，为了保证 dp 的无后效性必须先枚举 $j$。</p><p><del>某搜索大佬：关我什么事。</del></p><p>其次注意答案的求法，我们不能直接枚举 $\min\{dp_{i,2^n-1}\}$，因为题目要求我们必须返回 $0$ 点，所以还得加上一个 $i$ 返回 $0$ 的最短路，即求 $\min\{dp_{i,2^n-1}+f(0,i)\}$。</p><p>Code：（长得和题解有点不一样，凑合着看吧 qwq）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">1</span> &lt;&lt; <span class="number">11</span>) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, G[<span class="number">15</span>][<span class="number">15</span>], dp[<span class="number">15</span>][maxn], f[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n)</span><br><span class="line">            f[i][j] = G[i][j];</span><br><span class="line">    <span class="built_in">rep</span>(k, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, n)</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k][j]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        ++n;</span><br><span class="line">        <span class="keyword">int</span> N = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, n)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;G[i][j]);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Floyd</span>();</span><br><span class="line">        <span class="built_in">rep</span>(k, <span class="number">0</span>, N) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(k &amp; (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == j || !(k &amp; (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    dp[i][k] = <span class="built_in">min</span>(dp[i][k], dp[j][k ^ (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)] + f[j][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, dp[i][N] + f[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="F-Traveling"><a href="#F-Traveling" class="headerlink" title="F. Traveling"></a>F. Traveling</h3><blockquote><p>题意：一个人要去 $N$ 个城市旅游，他可以从任意城市开始，城市之间有 $m$ 个道路，每个道路所花费的费用不用，求解出遍历所有城市，且每个城市去过的次数不超过两次的最小花费。$1\le N\le 10$。</p></blockquote><p>肉眼可见这题是个三进制的问题。不同于二进制，三进制没有系统内置的位运算，我们该怎么处理呢？</p><p>我们可以开两个数组进行预处理：$mi3$ 和 $num3$。$mi3_i$ 的值为 $3^i$，$num3_{i,j}$ 代表 $i$ 这个数的三进制的第 $j$ 位是 $0,1$ 还是 $2$。为了方便思考，$num3_i$ 按照高位到低位从左到右排。 比如一个数 $15$，三进制为 $121$，那么 $num3_{15}$ 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num3[15]:</span><br><span class="line">下标: 0 1 2 3 4 5 6 7 8 9 10</span><br><span class="line">权值: 0 0 0 0 0 0 0 0 1 2 1</span><br></pre></td></tr></table></figure><p>因为 $N\le 10$，所以这个数最多也就到 $3^{10}-1$，再多开一位，下标范围就是 $0\sim 10$。</p><p>至于使用方法嘛……往下看！</p><p>预处理工作做完后，输入图。为了方便，我们还是以 $0\sim n-1$ 编号城市。</p><p>接下来就是 dp：</p><p>$dp_{i,j}$ 代表到了第 $i$ 个城市之后状态为 $j$ 的最小代价，这里 $j$ 从低位到高位表示的城市编号依次递增。</p><p>接着再套一层循环，枚举上一步是从 $k$ 城市到 $i$ 城市，计算就可以了。emm，注意还是要先跑一遍 Floyd。</p><script type="math/tex; mode=display">dp_{i,j}=\min\limits_{k=0}^{n-1}\{dp_{k,j-3^i+f(i,k)}\}</script><p>状态转移方程很简单，相信大家都会，但是有几个细节我错了很久：</p><ol><li>状态转移时几层循环的顺序。注意到状态转移的时候，只有 $j$ 是一直在增加的，$i$ 和 $k$ 都是乱的。所以第一层循环应该是 $j$，其次是 $i$，最后是 $k$。</li><li>因为此处 $j$ 是按照从低位到高位从右到左的顺序排，但是预处理是从高位到低位从左到右，所以可以注意到状态转移时可以直接使用 $3^i$，但是在判断的时候需要特别注意是 $3^{i/k}$ 还是 $3^{10-i/k}$。</li></ol><p>我在调这道题的时候 mjl 叫我写注释，所以我写了一个比较详细的注释，大家可以参考。</p><p><del>感谢 XSC062 救了我一命！不过这个代码我不知道是有 UB 还是什么，使用 <code>C++17(Clang)</code> 可以 AC，而使用 <code>C++14(GCC8)</code> 会 WA $\text{5pts}$，如果有大佬愿意帮我看一下是怎么回事，那也是极好的。</del></p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N3 = <span class="number">6e4</span> + <span class="number">5</span>; <span class="comment">// 3 ^ 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, f[maxn][maxn], dp[maxn][N3];</span><br><span class="line"><span class="keyword">int</span> mi3[maxn], num3[N3][maxn];</span><br><span class="line"><span class="keyword">bool</span> b[N3];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mi3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        mi3[i] = mi3[i - <span class="number">1</span>] * <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, N3) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i, s = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) &#123;</span><br><span class="line">            num3[i][s] = x % <span class="number">3</span>;</span><br><span class="line">            x /= <span class="number">3</span>;</span><br><span class="line">            --s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, N3)</span><br><span class="line">            b[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, N3) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">10</span> - n + <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                b[i] &amp;= num3[i][j] &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">            dp[i][mi3[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            --u, --v;</span><br><span class="line">            f[u][v] = f[v][u] = <span class="built_in">min</span>(f[u][v], w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, mi3[n] - <span class="number">1</span>) &#123; <span class="comment">// j 表示到了 i 之后的状态，三进制表示下最低位代表 0 城市(3^0)，倒数第二位表示 1 城市(3^1)，i 城市即为 3^i </span></span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">0</span>, n - <span class="number">1</span>) &#123; <span class="comment">// 目前到了第 i 个城市</span></span><br><span class="line">                <span class="keyword">if</span>(!num3[j][<span class="number">10</span> - i]) <span class="comment">// 如果 j 表示 i 去过的位数为 0 则说明没去过 i，不合法</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 这里是 10 - i 是因为 num3 数组是从左到右编号递增，但是 j 是从右往左依次递增，所以要转换一下 </span></span><br><span class="line">                <span class="built_in">rep</span>(k, <span class="number">0</span>, n - <span class="number">1</span>) <span class="comment">// 从 k 城市到的 i 城市</span></span><br><span class="line">                    <span class="keyword">if</span>(num3[j][<span class="number">10</span> - k] &gt; <span class="number">0</span>) <span class="comment">// j 当中也必须经过至少一次 k 才合法，10 - k 同理 </span></span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[k][j - mi3[i]] + f[i][k]); <span class="comment">// 状态转移，之前的状态少去了一次 i 所以要减 3^i </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">0</span>, mi3[n] - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span>(b[i])</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, dp[j][i]); <span class="comment">// 如果所有城市都去过就统计答案 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans == <span class="number">0x3f3f3f3f</span> ? <span class="number">-1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="H-炮兵阵地"><a href="#H-炮兵阵地" class="headerlink" title="H. 炮兵阵地"></a>H. 炮兵阵地</h3><blockquote><p>题意：有 $N\times M$ 的地区，每一个可能是山地（<code>H</code>）或者平原（<code>P</code>），只有平原才能有炮兵。每个炮兵的攻击范围是上下左右两个格子。给出地形图，求炮兵不相互攻击时最多能部署的炮兵数量。$1\le N\le 100,1\le M \le 10$。</p></blockquote><p><del>别问我 G 去哪了，问就是还没做出来。</del></p><p>这题就是一个 A 和 D 的缝合怪，确定一个攻击范围，然后山地上不能有炮兵就像 A 的有些格子不能种草一样。因为上下左右是两格，所以状态转移的时候不仅要枚举上一行的状态，还要枚举上上一行的状态，这么搞不 <code>TLE&amp;MLE</code> 才怪呢。</p><p>怎么解决呢，其实有一个办法，就是我们先把所有满足条件的一行的排列 dfs 出来，<del>通过实验</del>我们发现最多也就只有 $60$ 种符合要求的排列，所以枚举状态的时候每一层最多就 $60$，就不会时间内存双爆炸啦。</p><p>注意一下这里是求最多能放多少个炮兵，所以两层状态的答案是要加起来取 $\max$ 而非乘起来。<del>今天也是把加法原理和乘法原理弄混的一天呢。</del></p><p>其他就没什么好说的了。</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, N, tot, num[<span class="number">105</span>], qn[<span class="number">65</span>], sum[<span class="number">65</span>], dp[<span class="number">105</span>][<span class="number">65</span>][<span class="number">65</span>];</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">105</span>], q[<span class="number">65</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> ls)</span> </span>&#123; <span class="comment">// 求满足条件的所有一行的情况，两个炮兵之间至少相隔两个格子，不考虑山地和平原</span></span><br><span class="line">    <span class="keyword">if</span>(t == m + <span class="number">1</span>) &#123;</span><br><span class="line">        ++tot;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m)</span><br><span class="line">            q[tot][i] = b[i];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ls &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        b[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(t + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        b[t] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(t + <span class="number">1</span>, ls + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getnum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        s += x &amp; <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    N = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, tot)</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m)</span><br><span class="line">            qn[i] = (qn[i] &lt;&lt; <span class="number">1</span>) + q[i][j];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, tot)</span><br><span class="line">        sum[i] = <span class="built_in">getnum</span>(qn[i]);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m)</span><br><span class="line">            num[i] = (num[i] &lt;&lt; <span class="number">1</span>) + (a[i][j] == <span class="string">&#x27;H&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, tot) &#123;</span><br><span class="line">            <span class="keyword">if</span>((qn[j] | num[i]) ^ num[i]) <span class="comment">// 山地上不能有炮兵，此处判断和 A 题相似</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">rep</span>(k, <span class="number">1</span>, tot) &#123;</span><br><span class="line">                <span class="keyword">if</span>(qn[k] &amp; qn[j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">rep</span>(l, <span class="number">1</span>, tot)</span><br><span class="line">                    <span class="keyword">if</span>(!(qn[l] &amp; qn[j]))</span><br><span class="line">                        dp[i][j][k] = <span class="built_in">max</span>(dp[i][j][k], dp[i - <span class="number">1</span>][k][l] + sum[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, tot)</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, tot)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[n][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="O-集合选数"><a href="#O-集合选数" class="headerlink" title="O. 集合选数"></a>O. 集合选数</h3><blockquote><p>题意：有一种集合，若 $x$ 在集合中，则 $2x$ 和 $3x$ 都不能在集合中。对于任意一个正整数 $n$，求出 ${1, 2,\ldots, n}$ 这个集合的满足上述约束条件的子集的个数，结果对 $10^9+1$ 取模。$1\le n\le 10^5$。</p></blockquote><p><del>这思路，老师不讲真的可以想到吗！</del></p><p>这题乍一看没什么头绪，咱要不先列个表：</p><script type="math/tex; mode=display">\begin{matrix}1 & 2 & 4 & 8 &\cdots\\ 3 & 6 & 12 & 24 &\cdots\\9 & 18 & 36 & 72 &\cdots \\\cdots\end{matrix}</script><p>观察一下，思考一下：当选 $1$ 的时候，$2,3$ 不能选；选 $2$ 的时候，$1,4,6$ 不能选；选 $6$ 的时候，$2,3,12,18$ 不能选……</p><p>有没有发现什么？</p><p>这不就是在这个矩阵中不能取相邻的数吗！</p><p>那我们就构造一个这样的矩阵，左上角数字为 $1$，最上面一行为 $2$ 的幂次，最左边一行为 $3$ 的幂次，剩下的数就由那一个位置上对应的 $2$ 的幂次和 $3$ 的幂次相乘，然后按照 A 题的求法求是不是就可以了？</p><p>想到这一层，我们就已经成功了一半。接下来的一半，还得看几个细节：</p><p>一、有些数，比如 $5$，貌似不在这个矩阵里面。</p><p>这个东西解决办法也不难，如果找到有数字不在之前列到过的矩阵里面，我们只需要以这个数为左上角，然后再构造矩阵：</p><script type="math/tex; mode=display">\begin{matrix}5(1\times 5) & 10(2\times 5) & 20(4\times 5) & 40(8\times 5) &\cdots\\ 15(3\times 5) & 30(6\times 5) & 60(12\times 5) & 120(24\times 5) &\cdots\\45(9\times 5) & 90(18\times 5) & 180(36\times 5) & 360(72\times 5) &\cdots \\\cdots\end{matrix}</script><p>没错，我们只需要在刚才那个矩阵的基础上，把每个数都乘以左上角那个数，就可以了！</p><p>用一个 <code>bool</code> 数组存一下每个数字是否已经存在，在构造矩阵的过程中，遇到一个数就把它标记为已经出现过。求解答案时依次枚举 $1\sim n$，如果发现有数没有枚举到，就以这个数为左上角构造矩阵再求解。</p><p>由于各个矩阵之间没有什么关系，所以方案的选择是任意的，即每个矩阵得出的答案相乘。</p><p>另外，需要注意一下，如果你和我一样是按照先构造第一行和第一列，再相乘构造整个矩阵的话，记得两数相乘时需要除以左上角那个数，因为相乘的时候两边系数都算了一次，需要去重。</p><p>二、矩阵的大小？</p><p>构造第一行和第一列的时候，肯定是到 $n$ 就结束了。但是相乘的时候，仍然会有数大小超过 $n$，那么这些超过 $n$ 就不能选，类似于 A 里面有些格子里不能种草，这个用一个 <code>bool</code> 数组标记即可。</p><p>因为 $n$ 最多为 $10^5$，$\log_2(10^5)\approx 17,\log_3\approx 12$，所以矩阵的大小不会超过 $17\times 12$，数组没有必要开太大。</p><p>另外，因为 $dp$ 数组等大小比较大，大家一定要注意不能用 <code>memset</code>，直接需要清空多少就清空多少，不然会 T 飞。<del>当然，如果您是 $90$ 分的话，打表也是一个不错的选择。</del></p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">1</span> &lt;&lt; <span class="number">17</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x2[<span class="number">20</span>], x3[<span class="number">20</span>], _x2, _x3, __x2, __x3, num[<span class="number">20</span>], dp[<span class="number">20</span>][maxn];</span><br><span class="line">ll a[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">20</span>][<span class="number">20</span>], gz[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Make</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123; <span class="comment">// 构造矩阵，一个横杠是矩阵的长宽，两个横杠是权值</span></span><br><span class="line">    _x2 = <span class="number">0</span>, _x3 = <span class="number">0</span>, __x2 = o, __x3 = o;</span><br><span class="line">    <span class="keyword">while</span>(__x2 &lt;= n)</span><br><span class="line">        x2[++_x2] = __x2, __x2 &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(__x3 &lt;= n)</span><br><span class="line">        x3[++_x3] = __x3, __x3 = (__x3 &lt;&lt; <span class="number">1</span>) + __x3;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, _x2)</span><br><span class="line">        a[<span class="number">1</span>][i] = x2[i], gz[x2[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, _x3)</span><br><span class="line">        a[i][<span class="number">1</span>] = x3[i], gz[x3[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, _x3)</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">2</span>, _x2)</span><br><span class="line">            a[i][j] = a[<span class="number">1</span>][j] * a[i][<span class="number">1</span>] / o;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, _x3)</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, _x2) &#123;</span><br><span class="line">            b[i][j] = (a[i][j] &lt;= n);</span><br><span class="line">            <span class="keyword">if</span>(b[i][j])</span><br><span class="line">                gz[a[i][j]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//memset(dp, 0, sizeof(dp));</span></span><br><span class="line"><span class="comment">//memset(num, 0, sizeof(num));</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, q = (<span class="number">1</span> &lt;&lt; _x2) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, _x3)</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, q)</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, _x3)</span><br><span class="line">        num[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, _x3)</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, _x2)</span><br><span class="line">            num[i] = (num[i] &lt;&lt; <span class="number">1</span>) + b[i][j];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, _x3) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, q) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &amp; (j &lt;&lt; <span class="number">1</span>) || (j | num[i]) ^ num[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">rep</span>(k, <span class="number">0</span>, q) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(k &amp; j))</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, q)</span><br><span class="line">        ans = (ans + dp[_x3][i]) % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;964986022&quot;</span>); <span class="comment">// 打表出奇迹</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll s = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(gz[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">Make</span>(i);</span><br><span class="line">        s = (s * <span class="built_in">Solve</span>()) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF899E Segments Removal 题解</title>
      <link href="/posts/Solution-CF899E/"/>
      <url>/posts/Solution-CF899E/</url>
      
        <content type="html"><![CDATA[<p>这是我们考试题，我做了 $75$ 分，最后才发现是元素入队的时候没有赋值……</p><hr><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote><p>有一个长度为 $n$ 的整数数组，对数组执行若干次操作。每一次找到连续相等整数的最长段（如果有多个段长度相同，选择最靠左边的段）并删除它。要求计算经过多少次操作后数组为空。</p></blockquote><hr><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>因为前两天才调完<a href="https://www.luogu.com.cn/problem/P7912">小熊的果篮</a>，记忆犹新，所以立刻想到了<strong>队列+链表</strong>的做法。然后再读题，发现需要找长度最长的区间，不能用普通队列，要用<strong>优先队列</strong>。</p><p>我们先把所有的区间都找出来，存储每一个区间的左端点，长度（这样就可以算出右端点了）和这个区间数字的值。然后把这些区间全部按照顺序弄到一个双向链表里面，并把需要的值加入优先队列。</p><p>详细的讲解在代码注释里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体，需要存区间左端点，区间长度和它在链表里的下标</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> l, len, id; &#125;;</span><br><span class="line">std::priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="comment">// 定义排序规则：区间长度，一样时左边优先</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node x, node y) &#123; <span class="keyword">return</span> (x.len != y.len) ? (x.len &lt; y.len) : (x.id &gt; y.id); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lst 为上一个区间的左端点，因为我们要计算区间长度，所以需要用这个区间和上个区间的左端点算上一个区间的长度，需要存一下</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, lst = <span class="number">0</span>; </span><br><span class="line">a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = <span class="number">-1</span>; <span class="comment">// 特殊处理头尾端点，以免错误合并</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] != a[i - <span class="number">1</span>]) &#123; <span class="comment">// 说明这个数是一个区间的开头</span></span><br><span class="line">        num[++k] = a[i];</span><br><span class="line">        l[k] = k - <span class="number">1</span>; <span class="comment">// 初始化链表</span></span><br><span class="line">        r[k] = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k != <span class="number">1</span>) &#123; <span class="comment">// 如果这个区间有上一个，即不是第一个</span></span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">node</span>(&#123;lst, i - lst, k - <span class="number">1</span>&#125;)); <span class="comment">// 元素入队</span></span><br><span class="line">            L[k - <span class="number">1</span>] = lst, LEN[k - <span class="number">1</span>] = i - lst; <span class="comment">// 记录区间左端点和长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        lst = i; <span class="comment">// 更新上一个区间的左端点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">node</span>(&#123;lst, n - lst + <span class="number">1</span>, k&#125;)); <span class="comment">// 最后一个区间也需要处理</span></span><br><span class="line">L[k] = lst, LEN[k] = n - lst + <span class="number">1</span>;</span><br><span class="line">r[<span class="number">0</span>] = <span class="number">1</span>, l[k + <span class="number">1</span>] = k; <span class="comment">// 链表的初始化</span></span><br></pre></td></tr></table></figure><p>接着就是核心代码了。</p><p>我们用一个 <code>bool</code> 数组标记一个区间是否被取过，然后从队列里面不停取元素。</p><ul><li>若此区间已经被标记过了就直接跳过。</li><li>若此区间没有被取过，就标记一下这个区间，此时又取了一个区间，答案需要 $+1$，然后检查一下它的左右两个区间是否需要被合并；如果需要，就把两个区间合并到它左边那个区间，并标记它右边那个区间。</li></ul><p>这句话信息量有点大，是什么意思呢？</p><p>说明我们拿到一个没被取过的区间时，需要做这几件事：</p><ol><li>把这个区间标记为“已经被取过”。</li><li>因为又取了一个区间，所以答案要 $+1$。</li><li>把这个区间从链表里删掉。</li><li>检查这个被删除的区间的左边的区间（命名为 $l$）和它右边的区间（命名为 $r$）是否需要被合并，也就是说这两个区间的值是不是一样的，如果是一样的，那这个区间被取了之后，$l$ 和 $r$ 就变成了一个区间，所以需要被合并。</li><li>合并两个区间的时候，可以把 $l$ 的长度改为两个区间的长度相加，然后把 $r$ 删掉。需要注意 $r$ 也要被标记。</li><li>把更新的 $l$ 加入队列。</li></ol><p>这个时候就会有小朋友问了：此时队列里还有原来的 $l$，是不是需要删掉？</p><p>答案是不需要。因为优先队列的排序规则是按照长度从大到小排的，所以更新后的 $l$ 一定会比原来的 $l$ 先取出，取出之后我们就标记了 $l$，也就不会重复取到了。</p><p>给一下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    id_use[x] = <span class="number">1</span>; <span class="comment">// 实现时可以把标记的代码放在删除的函数里面</span></span><br><span class="line">    r[l[x]] = r[x];</span><br><span class="line">    l[r[x]] = l[x];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; id_use[q.<span class="built_in">top</span>().id]) <span class="comment">// 过滤掉已经被标记过的点</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">empty</span>()) <span class="comment">// 如果队列被取空了就直接跳过</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    node u = q.<span class="built_in">top</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    ++ans; <span class="comment">// 更新答案</span></span><br><span class="line">    <span class="keyword">if</span>(num[r[u.id]] == num[l[u.id]]) &#123; <span class="comment">// 如果 l 和 r 需要被合并</span></span><br><span class="line">        LEN[l[u.id]] += LEN[r[u.id]]; <span class="comment">// 赋值，注意这里不写只能得 75 分</span></span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">node</span>(&#123;L[l[u.id]], LEN[l[u.id]], l[u.id]&#125;)); <span class="comment">// l 入队</span></span><br><span class="line">        <span class="built_in">remove</span>(r[u.id]); <span class="comment">// 删除 r</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">remove</span>(u.id); <span class="comment">// 把这个区间删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">write</span>(ans - <span class="number">1</span>); <span class="comment">// 这里 -1 是因为头和尾会被错误合并，所以会多一次</span></span><br></pre></td></tr></table></figure><p>大概就是这样了吧。因为核心代码已经给出，所以不再给完整代码了。</p><p><del>另外就是祝贺一下 ljt 考试的时候终于没有写挂快读快写了。</del></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.12.24 考试总结</title>
      <link href="/posts/2021-12-24-%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/posts/2021-12-24-%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>正解是单调队列，时间复杂度 $\Theta(n)$。</p><p>我们先把数组复制 $3$ 遍。等等，为什么不是两遍呢？</p><p>因为最大值有变化，某首歌是否满足条件的数据在变化，所以可能出现第一次可以播放，但第二次不行的情况。平时我们是复制两遍，所以这里要多复制一遍。</p><p>然后从第一首歌开始，一次遍历被复制了三遍的数组，维护一个单调递减的队列。当然，里面存的是数组下标，下标当然不是单调递减的，但是代表的喜爱值是递减的。</p><p>我们以样例举例：</p><p><code>3 2 5 3</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i =   1  2  3  4  5  6  7  8  9  10 11 12</span><br><span class="line">a =   3  2  5  3  3  2  5  3  3  2  5  3</span><br><span class="line">ans = 0  0  0  0  0  0  0  0  0  0  0  0</span><br></pre></td></tr></table></figure><p>每次遍历到一个数，依次进行如下操作：</p><p>第一步：判断队首元素是否符合标准，当前遍历到的元素 $i$ 是否满足要求，即是否有 $a<em>i&lt;\dfrac{a</em>{q.\text{front()}}}{2}$。如果是，那么计算队首元素的答案（从它开始最多可以放多少首歌，<strong>即为当前遍历到的歌曲编号减去队首元素的编号</strong>）并把队首元素弹出。</p><p><strong>注意队首可能不止一个元素不满足要求，需要连续弹出。</strong></p><p>比如我们遍历到了 $6$ 号，然后单调队列现在长这样：</p><p><code>front &#123;3, 4, 5&#125; back</code> 也就是 <code>front &#123;5, 3, 3&#125; back</code></p><p>本来没什么问题，但是注意到 $2&lt;\frac{5}{2}$，所以如果播放了 $3$ 号歌曲，就不能播放 $6$ 号歌曲了。那么，从 $3$ 号歌曲开始播放最多能播放 $6-3=3$ 首歌，也就是 $3,4,5$ 这三首。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                     v i遍历到这儿了</span><br><span class="line">i =   1  2  3  4  5  6  7  8  9  10 11 12</span><br><span class="line">a =   3  2  5  3  3  2  5  3  3  2  5  3</span><br><span class="line">ans = 0  0  3  0  0  0  0  0  0  0  0  0</span><br><span class="line">            ^答案被更新</span><br></pre></td></tr></table></figure></p><p>第二步：把遍历到的元素放进单调队列。当然，为了保持单调，也许需要弹出队尾的一些元素。</p><p><strong>其实这也是为什么不能用队列长度来更新答案的原因。有些数可能会被弹掉，此时直接用队列长度判断答案可能会遗漏。</strong></p><p>遍历完数组之后就可以输出答案了，但是有个问题：</p><p>比如样例遍历完之后 <code>ans</code> 数组长这样：</p><p><code>0 0 3 0 0 0 3 0 0 0 3 0</code></p><p>那 $1,2,4$ 号怎么办呢？</p><p>其实这个很简单，你想一下，就以 $2$ 号歌曲举例，你先听一首到 $3$ 号歌曲，然后再按照 $3$ 号的答案计算不就行了吗？所以这里我们再倒序遍历一遍数组，如果某个下标的答案没被更新，就把答案更新为 <code>在它后面的最近的一个本来就有答案的值 + 当前遍历到的下标和那个数的下标之差</code>。</p><p>给出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>)<span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, N, a[maxn], ans[maxn];</span><br><span class="line">std::deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">file</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;playlist.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;playlist.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">file</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        a[i + n] = a[i + (n &lt;&lt; <span class="number">1</span>)] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    N = <span class="number">3</span> * n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, N) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()<span class="comment">/*防止 RE*/</span> &amp;&amp; (a[i] &lt;&lt; <span class="number">1</span>) &lt; a[q.<span class="built_in">front</span>()]) &#123;</span><br><span class="line">            ans[q.<span class="built_in">front</span>()] = i - q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; a[q.<span class="built_in">back</span>()] &lt; a[i])</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>, lst = N + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dep</span>(i, N, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]) &#123;</span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            lst = i;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            ans[i] = ans[lst] + tot;</span><br><span class="line">        ++tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (ans[i] &lt; n &lt;&lt; <span class="number">1</span>) ? ans[i] : <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>二分很明显，关键是 $\text{check}$ 函数怎么写。</p><p>这里我们用 dp：$dp_{i,j}$ 代表用了 $i$ 次红色，$j$ 次绿色最多能覆盖到的神坛的编号（注意这个编号及以前的所有神坛都需要被覆盖）。</p><p>但是有一个问题：$r,g$ 的范围是 $10^9$，这样难道不会炸掉吗？</p><p>这里需要注意一下，因为 $n\le 2000$，所以只要 $r+g\ge 2000$，答案就一定是 $1$，直接输出即可。</p><p>那么我们就人为地把 $r,g$ 的范围降到了 $2000$。<del>然后就可以开始愉快的 $\Theta(n^2)$ 啦！（口胡）</del></p><p>首先我们要想一下这个状态转移方程。假设我们这一次要用红色，那么我们要依托 $dp_{i-1,j}$ 的值，假设它为 $k$。我们已经覆盖到了第 $k$ 个神坛，所以，我们可以忽略第 $k$ 个和第 $k+1$ 个之间的那些空的坐标，直接把第 $k+1$ 个神坛作为左端点。</p><p>那右端点可以覆盖到哪里呢？这个需要预处理一下。我们设 $R_i$ 代表用红色的线段（长度为 $L$，就是我们需要 $\text{check}$ 的那个数），把第 $i$ 个神坛作为左端点，右端点能够覆盖的最大神坛编号，这个数是固定的。</p><p>至于怎么预处理，因为 $n$ 很小，$\Theta(n)$ 和 $\Theta(n^2)$ 都可以用。$\Theta(n)$ 就是用两个指针，先全都指着 $1$，然后一点一点往右走，保证两个指针之间的区间长度不超过 $L$ 但是最长，这样计算答案就可以了。</p><p>绿色同理，只不过是把 $L$ 换成 $2\times L$，$R$ 换成 $G$。</p><p>状态转移方程：</p><script type="math/tex; mode=display">dp_{i,j}=\max\{R_{dp_{i-1,j}+1},G_{dp_{i,j-1}+1}\}</script><p>当然，如果你直接这么写的话会愉快的 WA 掉。</p><p>注意初始化：$dp$ 极小值，$dp_{0,0}=0$，且枚举需要从 $0$ 开始（注意有 $0$ 的时候需要特殊判断）。</p><p>然后还是 WA……</p><p>注意状态转移方程，这个方程可能会访问到 $R/G_{n+1}$，所以我们还需要一句：$G_{n+1}←n,R_{n+1}←n$。</p><p>然后就没了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, r, g, a[maxn];</span><br><span class="line"><span class="keyword">int</span> R[maxn], G[maxn], dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">file</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;light.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;light.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>, q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">while</span>(q &lt;= n &amp;&amp; a[q] - a[p] + <span class="number">1</span> &lt;= L)</span><br><span class="line">            ++q;</span><br><span class="line">        R[p] = q - <span class="number">1</span>;</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="number">1</span>, q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">while</span>(q &lt;= n &amp;&amp; a[q] - a[p] + <span class="number">1</span> &lt;= L &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            ++q;</span><br><span class="line">        G[p] = q - <span class="number">1</span>;</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    G[n + <span class="number">1</span>] = R[n + <span class="number">1</span>] = n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, r) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, g) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!i &amp;&amp; !j)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!i)</span><br><span class="line">                dp[i][j] = G[dp[i][j - <span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!j)</span><br><span class="line">                dp[i][j] = R[dp[i - <span class="number">1</span>][j] + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = std::<span class="built_in">max</span>(R[dp[i - <span class="number">1</span>][j] + <span class="number">1</span>], G[dp[i][j - <span class="number">1</span>] + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[r][g] &gt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(l, mid);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">file</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;r, &amp;g);</span><br><span class="line">    <span class="keyword">if</span>(r + g &gt;= n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    std::<span class="built_in">stable_sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">1000000000</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><del>思维题诶！全场 AC 人数最少的一道题。</del></p><p>首先看数据范围，$1\le n\le 10^9$，肯定不能用 $n$ 来枚举 <del>（毕竟 mjl 测评不开 O2）</del>。</p><p>那我们再思考一下，发现 $1\le m\le 10^5$，可以用 $m$ 来枚举。所以我们可以求一下：以每一个公共牌作为顺牌中第一张公共牌的方案数。</p><p>这样想有一个好处：不用去重。因为只要第一张公共牌不一样，那么两种方案肯定不同；而求一种情况时也不会重复计算。</p><p>那么怎么算呢？我们可以求出此时这个顺牌区间左端点能够覆盖到的最小和最大值，然后再减一下不就行了吗。</p><p>那这个最值怎么算呢？假设现在需要求的牌编号为 $i$。</p><p>先说最小值吧：</p><p>首先我们把给出的公共牌排序、去重。<strong>众所周知，数组去了重之后不一定和原来数组一样长，所以，我们现在用 $m$ 代表顺牌区间的长度，$k$ 代表去重后公共牌的个数，切勿混淆。</strong></p><p>第一点，因为 $i$ 是顺牌序列中的第一张公共牌，所以，顺牌的开头必须比第 $i-1$ 张公共牌的数值更大，即 $a_{i-1}+1$。</p><p>第二点，因为要形成连续 $m$ 张顺牌，而个人牌只有 $s$ 张，<strong>所以这个连续的序列里必须包含至少 $\bf{m-s}$ 张公共牌。</strong> 而 $i$ 是第一张，所以还要往后继续找至少 $m-s-1$ 张公共牌，而在规定条件下，找得越少，顺牌的开始位置就越靠前，这也是我们要找的最小值。从第 $i$ 张牌开始，往后找 $m-s-1$ 张牌是第 $i+m-s-1$ 张，再往前找开头，往前再找 $m$ 个就可以了。</p><p>这两个条件必须<strong>同时满足</strong>，所以在计算最小值时取这两个的最大值，即：</p><script type="math/tex; mode=display">Min=\max\{a_{i-1}+1,a_{i+m-s-1}-m+1\}</script><p>最大值要简单一些，因为要包含这张牌，所以最多到 $a_i$；而且因为顺牌的个数是 $m$ 张，所以要保证这么多牌，开头不能超过 $n-m+1$。取这两者的最小值即可。</p><p>这里需要注意一点，有时最小值可能反而比最大值大，此时是无解的，不要加上一个负数。</p><p>代码倒是挺简洁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>)<span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, ans, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">file</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;straight.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;straight.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">file</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    std::<span class="built_in">stable_sort</span>(a + <span class="number">1</span>, a + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> k = std::<span class="built_in">unique</span>(a + <span class="number">1</span>, a + m + <span class="number">1</span>) - a - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, k - m + s + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Min = <span class="built_in">max</span>(a[i - <span class="number">1</span>] + <span class="number">1</span>, a[i + m - s - <span class="number">1</span>] - m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> Max = <span class="built_in">min</span>(a[i], n - m + <span class="number">1</span>);</span><br><span class="line">        ans += <span class="built_in">max</span>(<span class="number">0</span>, Max - Min + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p><del>先纠正一个错误：DNA 是两条，这玩意儿应该是 RNA 但是又要换一个字母……</del></p><p>这题的突破口是 $|e|$ 和字母种类都很小，字母只有四种。</p><p>我们先写一个函数 $\text{f(ch)}$，可以把不同的字母转换为不同的下标（$eg.\ A\to 0,T\to 1,G\to 2,C\to 3$），这样可以使代码更加方便。</p><p>然后看一下这个序列，如果要从某一个字母开始周期修改，假设周期的长度是 $len$，某个字符在周期（也就是 $e$）中的位置是 $i$，我们会发现一件有趣的事，如图：</p><p><img src="https://s2.loli.net/2022/01/11/7ozaY4KsivOwFH8.png" alt=""></p><p>红色的地方即为这个字符会修改到的地方，可以发现这个分部是有规律的，它所有能够修改到的字符的下标 $\bmod\ len$ 的结果是一样的。</p><p>所以我们可以令 $BIT_{i,ch,j,k}$ 来代表字符为 $ch$，周期长度为 $j$ 且在周期中的位置为 $k$（周期遍历从 $1$ 开始），所有满足这些条件的字符在 $1\sim i$ 这个范围中的个数。</p><p>然后就是板子了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>)<span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, len;</span><br><span class="line"><span class="keyword">char</span> s[maxn], e[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> BIT[maxn][<span class="number">4</span>][<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">char</span> c, <span class="keyword">int</span> p, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">f</span>(c);</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        BIT[x][l][p][id] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> c, <span class="keyword">int</span> p, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, l = <span class="built_in">f</span>(c);</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        sum += BIT[x][l][p][id];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">file</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;virus.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;virus.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">file</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            <span class="built_in">update</span>(i, <span class="number">1</span>, s[i], j, i % j);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> op, x, l, r;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>, &amp;x, &amp;c);</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="built_in">update</span>(x, <span class="number">1</span>, c, j, x % j);</span><br><span class="line">                <span class="built_in">update</span>(x, <span class="number">-1</span>, s[x], j, x % j);</span><br><span class="line">            &#125;</span><br><span class="line">            s[x] = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s&quot;</span>, &amp;l, &amp;r, e + <span class="number">1</span>);</span><br><span class="line">            len = <span class="built_in">strlen</span>(e + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 这里注意一下应该是 (l + j - 1) % len 而不是 j，因为我们定义的周期遍历是从 1 而非从 l 开始 </span></span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, <span class="built_in">min</span>(len, r - l + <span class="number">1</span>))</span><br><span class="line">                ans += <span class="built_in">query</span>(r, e[j], len, (l + j - <span class="number">1</span>) % len) - <span class="built_in">query</span>(l - <span class="number">1</span>, e[j], len, (l + j - <span class="number">1</span>) % len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这次考试爆炸了，$0+10+0+0$ 差点就保龄了……</p><p>T1 我打了一个线段树，结果没有调出来，T2 写了二分+贪心就没管了，T3 和 T4 都没有写出一个像样的代码……</p><p>只能说明思维和码力都太弱了 qwq。</p><p>以及，一定不要拘泥于才学过的知识点（话说我 T3 刚开始也打的线段树来着 qwq）。</p>]]></content>
      
      
      <categories>
          
          <category> 考试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分答案 </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ST 表求解 RMQ 问题</title>
      <link href="/posts/Sparse-Table-for-RMQ/"/>
      <url>/posts/Sparse-Table-for-RMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="1-RMQ-是啥"><a href="#1-RMQ-是啥" class="headerlink" title="1. RMQ 是啥"></a>1. RMQ 是啥</h2><blockquote><p>RMQ (Range Minimum / Maximum Query）问题是指：对于长度为 $n$ 的数列 $A$，回答若干询问 $\text{RMQ}(A,i,j)(1\leq i,j\leq n)$，返回数列 $A$ 中下标在 $[i,j]$ 里的最小（大）值，<strong>也就是说，RMQ 问题是指求区间最值的问题。</strong></p></blockquote><p><del>全是抄的。</del></p><p>也就是说，RMQ 是一类问题，而不是一类数据结构。</p><p>所以<del>暴力（没有初始化，查询$\Theta(n)$）</del>，线段树（初始化和查询都是 $\Theta(\log n)$）等都可以解决 RMQ 问题。</p><p>那么是否有更♂快的方法呢？</p><p>有！就是 <strong>ST 表</strong>。</p><hr><h2 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h2><p>ST  表通过 DP 的方式，可以实现 $\Theta(n\log n)$ 初始化，$\Theta(1)$ 查询区间最值。</p><p>优点：最重要的，快！</p><p>缺点：不支持修改数组，而且空间复杂度为 $\Theta(n\log n)$，可能会受不了。</p><hr><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h2><p>$dp_{i,j}$ 代表从 $i$ 开始，区间长度为 $2^j$ 的区间，即 $[i,i+2^j)$ 的最值（可以是最大值或者最小值，这个无所谓）。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>对于 $\forall i,j=0$ 时，区间只有 $A_i$ 这一个数字，所以肯定最值是 $A_i$。</p><script type="math/tex; mode=display">dp_{i,0}=A_i(1\leq i\le n)</script><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>我们知道，对于任意一个长度为 $2$ 的幂次方的区间，都可以划分为长度相等的两部分，例如 $[3,10]$ 就像这样：</p><p>（$i=3,j=3$）</p><p><img src="https://img-blog.csdnimg.cn/4d23757e51bb42279587a7bf8147d76d.png" alt=""></p><p>也可以说明区间 $[i,i+2^j)$ 可以被分为 $[i,i+2^{j-1})$ 和 $[i+2^{j-1},i+2^j)$ 两个部分，每个部分的长度都是 $2^{j-1}$。</p><p>那么转移方程不就出来了吗：</p><script type="math/tex; mode=display">dp_{i,j}=\max(or \min)\{dp_{i,j-1},dp_{i+2^{j-1},j-1}\}</script><p>当然，在代码的实现过程中，我们可以用 <code>1 &lt;&lt; x</code> 来代替分析中的 $2^x$，不过需要注意的是，位运算的优先级比四则运算低，需要打括号。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>对于任意一个区间 $[i,j]$，如何用已经初始化好的 ST 表求解最值呢？</p><p>看图：</p><p><img src="https://img-blog.csdnimg.cn/e5bfd2ed96774760851a0bd61d305897.png" alt=""></p><p>我们可以把任意一个区间分解成这样两个长度为 $2$ 的幂次的区间，一个区间左端点为待求区间的左端点，另一个区间的右端点为待求区间的右端点，两个区间的长度为所有 $2$ 的幂次中小于 $j-i+1$ 的最大的那一个，转换一下就变成了可以用 $2$ 的幂次表示的 $2^{\lfloor\log_2(j-i+1)\rfloor}$。（PS：$2^{\log_2(x)}=x$）。</p><p>找到两个分解后的区间，求一下最值就行了。</p><hr><p>数列区间最大值问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, j, k) for(int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dep(i, j, k) for(int i = j; i &gt;= k; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>)<span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, a[maxn], dp[maxn][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        dp[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; j &lt;= n; ++j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">log2</span>(r - l + <span class="number">1</span>); <span class="comment">// cmath 库中有内置的 log2 函数，请注意不要用成以 e 为底的 log 函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">rmq</span>(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h2 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h2><p>ST 表本身就是个工具，我们在平时做题的时候不能想着刻意去使用它，详情参考洛谷 <a href="https://www.luogu.com.cn/problem/P2048">P2048</a> 。</p><p>另外，ST 表之所以有局限性，是因为它在查询的时候可能会有一部分区间被重复查询，所以只能求解那些有重复元素不影响最终结果的问题。这种问题除了最大最小值之外，还有 gcd、lcm 等，所以这些问题也是可以通过 ST 表求的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/posts/Segment-Tree/"/>
      <url>/posts/Segment-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><ul><li>二分的递归写法</li><li>二叉树</li></ul><hr><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树（Segment Tree）是一种二叉树，本质上和树状数组有区别<del>虽然都是树</del>。</p><p>不过和树状数组一样，线段树也是一种维护数组的数据结构，它可以实现 $O(\log n)$ 修改、查询<del>不过常数比树状数组大得多</del>。</p><p>另外，线段树的应用范围比树状数组广，不过它维护的数据必须满足结合律（$eg.(a+b)+c=a+(b+c)$）。为什么呢？这涉及到线段树实现的原理。</p><hr><h3 id="性质-amp-原理"><a href="#性质-amp-原理" class="headerlink" title="性质 &amp; 原理"></a>性质 &amp; 原理</h3><p>首先要建一棵线段树，首先我们要有一个线段，那就是数组。</p><p>然后，我们还需要一棵二叉树。</p><p>于是，我们就成功种了一棵线段树。</p><p>它长这样：</p><p><img src="https://s2.loli.net/2021/12/06/mN5Aro4wzDGBykP.jpg" alt=""></p><p>注意到每个结点里面的区间没，这是闭区间，代表的是这个结点存的信息来源于数组的哪个区间。</p><p>观察这个线段树，我们可以发现：</p><ul><li>每个叶子结点都代表数组中的一个元素。</li><li><p>每个非叶子结点的两个孩子的区间是从父节点区间的中间划开的。</p><p>  说详细一点，若一个非叶子结点覆盖的区间为 $[L,R]$，那么令 $mid=\lfloor \frac{L-R}{2}\rfloor$，则左孩子覆盖的区间为 $[L,mid]$，右孩子覆盖的区间为 $[mid+1,R]$。</p></li><li>除去最后一行是一棵满二叉树。</li></ul><p>那线段树的原理是怎样的呢？这里我们先讲最简单的单点修改、区间查询来理解。</p><p>有点类似于于归并排序，我们需要<strong>分解后再合并数据</strong>。每个父节点存储的信息都是其两个子节点信息的合并，这样我们就可以通过访问一个结点拿到这个节点所代表区间的信息。</p><p>首先分解，我们一层一层往下递归，直到找到叶子结点，然后把叶子结点的信息向它的父节点传递：</p><p><img src="https://s2.loli.net/2021/12/06/391XHMCVrvPwnjI.jpg" alt="向上传递信息"></p><p>然后由于递归回溯的原因，我们会接着遍历到它的兄弟，这个时候，它的父节点已经获得了两个子节点的信息，就可以<strong>合并信息</strong>了。</p><p>这个地方，我们给数组一个值，然后用数组元素和来代表需要求解的信息。</p><p><img src="https://s2.loli.net/2021/12/06/FnDj4KopWGSmB8P.jpg" alt="赋值"></p><p>我们继续往上回溯，按照相同的方法求解。在求解 $[1,3]$ 之前，我们需要把 $[1,2]$ 的值先传上去。</p><p><img src="https://s2.loli.net/2021/12/06/mgvj1z5rhweiLGW.jpg" alt="再往上"></p><p>这么一点一点的传上去，就可以求得区间的和了！</p><p>这个操作的时间复杂度是 $O(\log n)$，每次修改、查询和初始化的时候都这么来一遍，不就可以实现单点修改区间查询了嘛。</p><p>那么为什么求得的值必须满足结合律呢？显而易见，我们需要把求解的值分成一个区域一个区域地求解，如果不满足结合律就会出问题。</p><p>接下来我们来讲一讲 C++ 的实现。</p><hr><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>于是我们知道，每一个结点里需要存：</p><ul><li>区间左端点 $l$</li><li>区间右端点 $r$</li><li>这个区间的信息（$eg.\sum_{i=l}^{r}a_i$ 或者 $\max^{r}_{i=l}{a_i}$）</li></ul><p>等等，为什么不用存左孩子和右孩子呢？</p><p>这就涉及到存储线段树的方法。</p><p>一般来说，只要题目不卡空间，我们可以通过数组来存一个本质上是二叉树的线段树：</p><p>根节点数组下标是 $1$，对于每个非叶子节点，若它的数组下标是 $p$，那么其左孩子数组下标是 $2p$，右孩子数组下标是 $2p+1$。</p><p>那么，处理好存储的问题，接下来我们来解决初始化。</p><hr><h3 id="初始化-amp-单点修改"><a href="#初始化-amp-单点修改" class="headerlink" title="初始化 &amp; 单点修改"></a>初始化 &amp; 单点修改</h3><p>对于一段区间 $[l,r]$，我们把它从 $mid$ 分成 $[l,mid]$ 和 $[mid+1,r]$，然后以这两个区间作为此结点的两个子节点。</p><p>像开头说的那样，我们一直往下递归，当递归到叶子结点的时候就把数组的值赋给叶子结点，接着我们把叶子结点的信息传到它的父结点，然后求父结点的值，再把父结点的信息传给父结点的父结点……最终就可以把信息传递到根节点了。</p><p>请注意，儿子向父亲转移需要放在递归语句的后面。除此之外没有什么别的难点，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两行代码是求左子树和右子树下标的函数，p &lt;&lt; 1 等价于 p * 2，p &lt;&lt; 1 | 1 等价于 p * 2 + 1，不过速度更快</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lc</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rc</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[p].l = l, t[p].r = r; <span class="comment">// 给结点代表的区间端点赋值</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123; <span class="comment">// 这个节点是叶子节点，没有子树</span></span><br><span class="line">        t[p].val = a[l]; <span class="comment">// 赋值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid);     <span class="comment">// 初始化左子树</span></span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r); <span class="comment">// 初始化右子树</span></span><br><span class="line">    t[p].val = t[<span class="built_in">lc</span>(p)].val + t[<span class="built_in">rc</span>(p)].val; <span class="comment">// 合并左右子树的信息</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>单点修改的代码和初始化很像，不过还是有一点区别。</p><p>假设我们要修改下标为 $3$ 的数字，把它加上 $5$：</p><p><img src="https://s2.loli.net/2021/12/24/lFYhgs42vHINSUQ.jpg" alt=""></p><p>就像这样，我们要在每一个包含所修改数据的下标的区间加上 $5$。</p><p>那么整个 $\text{update}$ 函数有这两个部分：</p><ol><li><p>从根节点出发往下找，直到找到需要修改的点（叶子节点）；</p></li><li><p>往上回溯过程中修改每一个经过的结点的值。</p></li></ol><p>那么代码就呼之欲出了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].l == t[p].r) &#123; <span class="comment">// 找到了需要修改的叶子节点</span></span><br><span class="line">        t[p].val = k; <span class="comment">// 修改它的值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= x) <span class="comment">// 如果需要修改的结点在左子树</span></span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">lc</span>(p), x, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 需要修改的结点在右子树</span></span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rc</span>(p), x, k);</span><br><span class="line">    t[p].val = t[<span class="built_in">lc</span>(p)].val + t[<span class="built_in">rc</span>(p)].val; <span class="comment">// 合并左右子树的信息</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>我们可以把查询的区间分成一些部分，每个部分都一个结点的范围<strong>刚好覆盖</strong>，把这些结点的权值合并就可以了。</p><hr><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>众所周知单点修改线段树的时间复杂度是 $O(\log n)$，那么如果是区间修改，如何保持时间复杂度不变呢？</p><p>你可能会回答：差分。是的，这是一个可行的方法，不过差分只能维护区间和的查询，而对于查询最大值等则束手无策。<del>而且既然如此，直接打码量少常数小的树状数组他不香吗。</del></p><p>于是一个玄学的方法出现了：<strong>懒惰标记</strong>。</p><p>我们知道，对于一个区间的修改，后面的查询不一定用得到，比如有一次你修改区间 $[1,5]$ 但是后面根本没有查询这里的值，那么我们就没有必要在修改的时候把所有的子节点都修改一遍，<strong>只有需要的时候才修改。</strong></p><p>懒惰标记就是这么一个东西，我们给一个节点打上懒惰标记，就意味着<strong>这个结点的值已经被修改过，但是它的子节点还没有被更新。</strong> 只有我们在后面操作中需要更新后面的值，才需要把懒惰标记传到下面，更新需要的值。</p><p>在区间修改的时候，如果我们递归到一个结点覆盖的区间被需要修改的区间完全包含，那么我们就不需要再递归下去，而是给这个结点更新后打上一个懒惰标记，意味着这一段区间需要被修改，但是还没有完全实际操作。等下一次我们需要查询用到里面的值时，递归到这个节点时，我们就知道下面还没有更新，所以就把这个节点的两个子节点更新，然后把懒惰标记传到子节点上，以此类推。</p><p>把懒惰标记从父节点传到子节点的过程我们可以用一个 $\text{pushdown}$ 函数实现。在这个函数里面，我们先需要修改子节点的权值，然后把父节点的懒惰标记叠加到子节点的懒惰标记上，最后清空父节点的懒惰标记，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target 即为懒惰标记</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">lc</span>(p), r = <span class="built_in">rc</span>(p);</span><br><span class="line">    t[l].val += (t[l].r - t[l].l + <span class="number">1</span>) * t[p].target;</span><br><span class="line">    t[r].val += (t[r].r - t[r].l + <span class="number">1</span>) * t[p].target;</span><br><span class="line">    t[l].target += t[p].target;</span><br><span class="line">    t[r].target += t[p].target;</span><br><span class="line">    t[p].target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="一些扩展"><a href="#一些扩展" class="headerlink" title="一些扩展"></a>一些扩展</h3><p>线段树不仅可以维护诸如区间和，最值之类，还可以维护一些奇奇怪怪的东西。</p><p>先来看第一组：</p><p><a href="https://www.luogu.com.cn/problem/SP1043">GSS1</a> <a href="https://www.luogu.com.cn/problem/SP1716">GSS3</a></p><p>要求的是一个区间的最大子段和。</p><p>想一下，把两个区间合并为一个区间，该怎么找到这个区间的最大子段和呢？</p><p>无非就三种情况嘛：</p><ol><li>左边的最大子段和；</li><li>右边的最大子段和；</li><li>左边<strong>包含右端点</strong>的最大子段和加上右边<strong>包含左端点</strong>的最大子段和。</li></ol><p>那这三个东西怎么求呢？</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P7960 [NOIP2021] 报数 题解</title>
      <link href="/posts/Solution-P7960/"/>
      <url>/posts/Solution-P7960/</url>
      
        <content type="html"><![CDATA[<p>蒟蒻抢到了 CCF  的题！</p><p>考场上打玄学复杂度还没处理 $10^7+1$ 的屑只得了 $70$ 分。</p><hr><p>首先，注意到所有<strong>包含 7 或者这些数的倍数</strong>都不可以报。那么我们可以利用一个类似于埃氏筛的东西来筛出这些不能报的数。</p><h3 id="什么是埃筛"><a href="#什么是埃筛" class="headerlink" title="什么是埃筛"></a>什么是埃筛</h3><p>埃氏筛法本来是用来找质数的一种质数筛法。</p><p>我们知道，一个质数只有 $1$ 和它本身两个因数，所以，我们可以通过任意两个不为 $1$ 的数相乘得到一个合数。</p><p>我们开一个数组 $b$，$b_i$ 代表 $i$ 是否为合数。从 $2$ 开始筛，如果此时 $b_i=0$，就说明这个数不能通过任意两个不为 $1$ 的数相乘得到，它是一个质数。</p><p>如果 $b_i=1$，说明这是一个合数。我们知道，任何一个数一定有至少一个因子是质数，所以每个数都可以通过让任意一个数和质数相乘得到。用合数再去与别的数相乘会浪费时间，所以我们需要直接跳过下面的步骤。</p><p>此时我们拿到了一个质数 $i$，然后我们开始遍历 $2\times i,3\times i,\ldots$，这些全部都是合数，所以把它们全部标记为合数，直到超出筛的范围。</p><p>代码很简单，大概长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)</span><br><span class="line">        f[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度大概是 $O(n\log \log n)$。</p><hr><h3 id="怎么做这道题"><a href="#怎么做这道题" class="headerlink" title="怎么做这道题"></a>怎么做这道题</h3><p>因为任何含有 $7$ 的数字或其倍数都不可以报出，所以我们可以通过乘积来筛掉所有不合法的数，这很明显是一道埃筛的变形。那么我们该如何做这道题呢？</p><p>我们还是开一个 $b$ 数组记录所有的数是否能报，其中 $b_i=0$ 代表 $i$ 可以报，$b_i=1$ 则不能。</p><p>首先我们要知道怎么判断一个数 $x$ 是否含有 $7$。这个很简单，只需要重复以下两个步骤：</p><ol><li>计算 $x/10$ 的余数是否等于 $7$，如果有，说明此数含有 $7$；</li><li>$x$ 除以 $10$。</li></ol><p>用这样的方法可以遍历到 $x$ 每个数位上的数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断这个数能不能报，若 x 中有 7，返回 1 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">pan7</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> qwq;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        qwq = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(qwq == <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次筛到一个不能报的数，因为其倍数也不能报，所以我们把它乘以不同的数，把这些数也标记为不能报。期间我们需要保证不筛到 $10^7+1$ 外面去。代码长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pan7</span>(i)) &#123;</span><br><span class="line">            b[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> qwq = i * j;</span><br><span class="line">                <span class="keyword">if</span>(qwq &gt; n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                b[qwq] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $O(n \log  n)$。</p><p>接着我们已经知道了所有能报的的数，此时我们只需要从大到小遍历 $10^7+1\sim 1$ 的所有数，拿一个变量存当前遍历到的最小能报的数字，每次到一个数，这个变量里存的值就是它报了之后能报的下一个数字，把这个数存在 $ans$ 数组里面。</p><p>这样的预处理可以避免查询一个一个跳导致的玄学复杂度。</p><p>时间复杂度 $O(n)$。</p><p>然后我们就可以实现 $O(1)$ 询问。</p><hr><h3 id="一个坑"><a href="#一个坑" class="headerlink" title="一个坑"></a>一个坑</h3><p>题目数据范围是 $10^7$，为什么需要筛到 $10^7+1$ 呢？</p><p>因为可能询问的就是 $10^7$，而它的下一个数是 $10^7+1$。</p><p>这个坑卡掉了许许多多悲伤的 OIers。</p><hr><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>) <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = maxn - <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, q, tot, g[maxn], ans[maxn];</span><br><span class="line"><span class="keyword">bool</span> b[maxn];</span><br><span class="line"><span class="comment">// b[x] = 1 说明 x 不能被选</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若 x中有 7，返回 1 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">pan7</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> qwq;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        qwq = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(qwq == <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pan7</span>(i)) &#123;</span><br><span class="line">            b[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> qwq = i * j;</span><br><span class="line">                <span class="keyword">if</span>(qwq &gt; n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                b[qwq] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快读快写</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        w |= ch == <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">    x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">9</span>) <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;number.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;number.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">prime</span>();</span><br><span class="line">    <span class="keyword">int</span> Ans = (<span class="keyword">int</span>) <span class="number">1e7</span> + <span class="number">1</span>; <span class="comment">// 必须 +1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) &#123;</span><br><span class="line">        ans[i] = Ans;</span><br><span class="line">        <span class="keyword">if</span>(!b[i])</span><br><span class="line">            Ans = i;</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        q = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">write</span>(b[q] ? <span class="number">-1</span> : ans[q]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2021 爆炸记</title>
      <link href="/posts/NOIP2021-%E7%88%86%E7%82%B8%E8%AE%B0/"/>
      <url>/posts/NOIP2021-%E7%88%86%E7%82%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Day"><a href="#Day" class="headerlink" title="Day -?"></a>Day -?</h3><p>笑死，CQ 四百多名额最后去了三百多人（包括初中生）。</p><p>初二划水人员表示很淦。</p><hr><p>因为 CSP 完了就是《期 中 定 时 作 业》，所以暂时潜心搞 whk 没怎么搞 OI。</p><p>结果《期 中 定 时 作 业》爆炸了，语文估错时间作文没写完……</p><p>后来我们语文老师给我估分 $42$，我十分怀疑这个分数的真实性，但是我相信我们的语文老师 (^_^)。</p><p>数学海星，终于上 $140$ 了。英语比较爆炸，客观题扣了 $9$ 分，作文扣了 $4$ 分，勉强上 $135$，拿了本英语老师的英文版爱丽丝漫游仙境。<del>我们班最高 146，orz 年级第二 NH4+ 大佬。</del></p><p>最后结果嘛……班级 $\text{rk13(14?)}$，年级勉强卡进前 $100$。</p><hr><h3 id="Day-2、-1"><a href="#Day-2、-1" class="headerlink" title="Day -2、-1"></a>Day -2、-1</h3><p>一年一度的趣味运动会，初二了也是初中的最后一次。因为我们班妹子很少，而每个项目一个班男生和女生的参加人数是一样的，所以每个妹子都有很多项目。</p><p>我在那里颓废，看到班上一堆卷王在自己座位上卷，感到十分惊恐。<del>但是这依然挡不住我想要颓废的心（狗头）。</del></p><p>班级获得的结果还不错，拿了羊角球接力的第一名，最后<del>凭借“暗箱操作”的道德风尚奖</del>以 $5$ 分之差惊险拿到一等奖最后一名。（PS：后面我们班在冬季长跑以一分之差得到第二，英语配音二等奖第一名，都被我们说做这次的“报应”。）</p><p>本蒟蒻基本上在参加项目+看别人打排球+颓废+和 lym 聊天，没怎么复习（</p><hr><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>梅开二度，又发遗照……我的考号是 CQ-00281，本来说是想和大佬面基，但是大佬都很忙，也不敢去问。</p><p>话说 CQ NOIP 要全程戴口罩？这对于一个一戴口罩眼镜就要起雾的人来说怕是不太友好哦（</p><p>晚上回家准备了一堆吃的，稍微看了一下考前注意事项就去睡觉了。</p><hr><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>很早就起床了，看了一眼电脑，然后就出发了。到了 BS 门口，找到了穿着我们学校的校服的同学，然后听到他们在唱生日快乐，找 lym 问了下才知道是 cjg 学长过生日。</p><p>等了一会儿人就进学校了。<del>（某个教练一直让我们在校门口等 zqw 和 tl，结果等不及了进去之后才发现他俩早就进去了。）</del></p><p>我和 lym 巨佬很近，就在斜对面。这是个好兆头！</p><p>开题了，这次密码是 <code>IronHeart</code>，铁胆雄心？<del>那么这次是不是有码量超级大的题啊。</del></p><p>先看题，T1 看着比较简单，T2 不会，T3 不会，T4 看着是道只要肯打就能得分的大膜你。于是决定先做 T1。</p><p>想了一下，这 T1 看着有点像质数筛法啊！于是我准备敲一个类似于欧拉筛的东西，结果发现欧拉筛貌似不行，只好退而求其次，打了个类似于埃氏筛的东西。</p><p>打完了，开开心心按下 F9，然后：</p><p><code>[Error] ld returned 1 exit status</code></p><p>？？？</p><p>我一脸问号，再编译了几遍，结果是一样的。我觉得是自己的代码出现了问题，于是打了个 A + B，按下 F9，然后：</p><p><code>[Error] ld returned 1 exit status</code></p><p>心 脏 骤 停。</p><p>此时我的心里有一万匹草泥马奔涌而过，于是我举起手<del>召唤</del>找老师……</p><p>老师过来看了很久<del>我的 A + B</del>，调编译参数之类的也没解决，于是他又叫来了另一个老师，这位老师 Dev-C++ 右上角的参数从 <code>TDM-GCC 4.9.2 64-bit Debug</code> 改成了 <code>TDM-GCC 4.9.2 64-bit Release</code>，然后按下 F9：</p><p>电脑上出现了一个黑色的终端，它终于编译起了！</p><p>这个时候那个老师问了我一句：“你会打断点调试吗？”</p><p>我说会。</p><p>他问我要不要换台电脑。</p><p>我看着我的 T1 代码，委婉拒绝了他们好心的建议（我平时几乎不用断点调试）。</p><p>然后他们就走了。</p><p>然后我大概测了下 T1 的代码，大概没问题了，但是样例 4 死活 1.2s 左右怎么都卡不进去。于是先放掉了 T1。</p><p>PS：这人不仅打的玄学复杂度超时，还只打了 $10^7$ 没加一，笑死了。</p><p>T2T3 看上去都没什么思路，于是我吃了一些东西，开始干 T4……的 bfs 暴力。<del>你看看这个人这么逊，肯定只会打最暴力的暴力了 QAQ。</del></p><p>不得不说 T4 码量是真的大，应了那句 <code>IronHeart</code> 啊！我一直在敲，敲了很久很久，最后敲出来还过不了小样例！于是我开始分析，疯狂改 bug <del>造 bug</del>，然后把小样例过了 QWQ。</p><p>代码大概有 5k 吧，这是蒟蒻打过最长的代码了。</p><p>最后还剩半个小时，码了 T2 的暴搜和 T3  的 <code>rand</code>，但是肯定一分都没有……QAQ</p><p><del>话说坐我右边那位大巨佬比赛一开始就开始吃东西，好像是牛肉干，一直吃到了比赛结束，中间从来没断过……</del></p><hr><p>比赛结束几天后自测了一下。</p><p>估分：$90+0+0+rp\approx 90$</p><p>Luogu：$70+0+0+0=70$</p><p>你谷的分出来的时候我心里一紧，写了那么久的 T4 一分都没有吗？心态都要炸了。</p><p>接着 mjl 公布了估计的分数，我 $74$。（什么？我 T4 竟然有分？）</p><p>然后官方公布分数：</p><p>$70+0+0+8=78$</p><p>CCF 少爷姬 NB！</p><p>3= 滚粗了。</p><hr><p>据说 DJ $248$？愣着干啥？赶紧膜拜啊！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4656 [CEOI2017] Palindromic Partitions 题解</title>
      <link href="/posts/Solution-P4656/"/>
      <url>/posts/Solution-P4656/</url>
      
        <content type="html"><![CDATA[<p>这一定是 ljt 写过的最短的题解。</p><p>先上一个部分分：朴实无华的区间 dp $\text{45pts}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>) <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, dp[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[l + i] != s[r + i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= len / <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">f</span>(i, j - k + <span class="number">1</span>, k)) &#123;</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        dp[i][j] = dp[i + k][j - k] + <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!flag)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><p>如上的代码，内存不够，时间也要超限，那我们需要找新的办法。</p><p>正解：贪心 + Hash</p><p>因为要划分为尽量多的部分，所以我们从两边开始找，设两个指针分别指着从左往右数和从右往左数第 $i$ 个字符。只要找到两个字符串一样，就把它们分离出来。</p><p>两个字符串是否一样可以通过 Hash 判断，但是有个问题：我们是从两边往中间枚举的，右边那个字符串是倒着枚举的，怎么判断呢？</p><p>这个很简单，我们只需要判断一下当前右边遍历到的字符是字符串的第几个，假设它是第 $k$ 个，那么就加上它乘以 $base^k$ 即可。</p><p>最后有个细节：如果字符串的长度是奇数，或者还剩下一些字符，那么需要把这些字符作为一个区间，答案要加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>) <span class="number">1e6</span> + <span class="number">5</span>, p = <span class="number">97</span>, base = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        ull hash1 = <span class="number">0ull</span>, hash2 = <span class="number">0ull</span>, pow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            hash1 = hash1 * p + s[i];</span><br><span class="line">            hash2 = hash2 + s[n - i + <span class="number">1</span>] * pow;</span><br><span class="line">            pow *= p;</span><br><span class="line">            <span class="keyword">if</span>(hash1 == hash2) &#123;</span><br><span class="line">                ans += <span class="number">2</span>;</span><br><span class="line">                hash1 = hash2 = <span class="number">0ull</span>;</span><br><span class="line">                pow = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((n &amp; <span class="number">1</span>) || hash1)</span><br><span class="line">            ++ans;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6359 [CEOI2018] Cloud computing 题解</title>
      <link href="/posts/Solution-P6359/"/>
      <url>/posts/Solution-P6359/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://www.luogu.com.cn/problem/P6359">题目链接</a></p><p>我们教练十分努力，竟然找到了这个只有一百多人做的题目。</p><p>这是一道比较有思维难度的 01 背包题，建议评绿或者蓝？</p><hr><h3 id="确定容量和价值"><a href="#确定容量和价值" class="headerlink" title="确定容量和价值"></a>确定容量和价值</h3><p><del>这个输入的变量名很显然就是在提示你把计算机和客户订单混在一起嘛。</del></p><p>我们可以发现，对于每一个计算机，只有<strong>买或不买两种情况</strong>；对于每一个单子，只有<strong>接或不接两种状态。</strong> 而能不能接客户的单子取决于内核的数量够不够。于是，我们想到了这道题的算法——01 背包，内核数量相当于容量，钱相当于价值。</p><p>但是这时就有了一个问题：我怎么确定内核的数量？</p><p>注意到题目中还有另一个条件——时钟频率。因为客户要求有一个对于时钟频率的限制，换句话说，就是<strong>每一个客户能使用的最大内核数量是确定的</strong>。</p><p>所以我们可以把计算机和客户的单子放在一个结构体数组里面，拿一个 <code>bool</code> 区分一下计算机和客户。然后，按照时钟频率排序。</p><p>此时，对于任意一个客户的单子，它<strong>前面的</strong>所有内核数量之和就是对于它来说可以使用的最大内核数。</p><p>这里需要注意一点：如果时钟频率一样，计算机排在前面。如果类型和时钟频率都一样，计算机把价格低的排在前面，客户把价格高的排在前面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.f != y.f)</span><br><span class="line">        <span class="keyword">return</span> x.f &gt; y.f;</span><br><span class="line">    <span class="keyword">if</span>(x.data != y.data)</span><br><span class="line">        <span class="keyword">return</span> x.data &lt; y.data;</span><br><span class="line">    <span class="keyword">if</span>(!x.data) </span><br><span class="line">        <span class="keyword">return</span> x.v &lt; y.v;</span><br><span class="line">    <span class="keyword">return</span> x.v &gt; y.v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>接着就到了比较难的地方。</p><p>设 $dp_{i,j}$ 代表处理了前 $i$ 个请求之后还剩下 $j$ 个可用的内核时能获得的最大利润。</p><p>经上文分析，对于计算机和客户都有两种状态。那么，选择哪种更优呢？</p><p>我们用一个变量 $C$ 来统计<strong>到目前为止</strong>内核的总数量，相当于一个前缀和。然后分析：</p><h4 id="对于计算机"><a href="#对于计算机" class="headerlink" title="对于计算机"></a>对于计算机</h4><p>买的话，需要花钱，但是内核数量会增加。那么相对买之前来说，买后内核数量增加了 $c_i$，也就是说买之前内核数量比现在少 $c_i$，而买后，现在有的钱数量相较于买之前减少了 $v_i$，所以结果表达式如下：</p><script type="math/tex; mode=display">dp_{i-1,j - c_i} - v_i</script><p>至于 $j$ 的循环范围很简单，保证数组下标不超过 $0\sim n$ 的范围即可。</p><p>所以就有对于计算机的状态转移方程：</p><script type="math/tex; mode=display">dp_{i,j}=\max^{C}_{j=c_i}\{dp_{i-1,j-c_i}-v_i\}</script><p>对了，记得在转移之前把前缀和加上。</p><h4 id="对于客户"><a href="#对于客户" class="headerlink" title="对于客户"></a>对于客户</h4><p>接客户的单子，可用的内核数量会减少，但会收获钱。那么接后相对于接前少了 $c_i$ 个内核，但钱增加了 $v_i$，所以结果表达式如下：</p><script type="math/tex; mode=display">dp_{i-1,j+c_i}+v_i</script><p>那状态转移方程就是这样：</p><script type="math/tex; mode=display">dp_{i,j}=\max^{C-c_i}_{j=0}\{dp_{i-1,j+c_i}+v_i\}</script><hr><h3 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h3><p>开二维数组空间不够，于是自然想到了让数组打滚。然而，滚起来之后，$j$ 到底该从小到大还是从大往小？</p><p>这个顺序只取决于一个因素，就是这个状态转移方程<strong>所使用的</strong> $dp$ 值在<strong>需要求的值</strong>的前面还是后面。如果在前面，就需要倒着枚举，如果在后面，就要正着枚举，以保证利用的是本来为 $dp_{i-1,?}$ 而非 $dp_{i,?}$。</p><p>所以，处理购买计算机的请求要从大到小枚举，处理客户单子需要从小到大枚举。</p><p>注意一下初始值，数组赋极小值，$dp_{0}=0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!a[i].data) &#123; <span class="comment">// 计算机 </span></span><br><span class="line">        C += a[i].c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = C; j &gt;= a[i].c; j--)</span><br><span class="line">            dp[j] = std :: <span class="built_in">max</span>(dp[j], dp[j - a[i].c] - a[i].v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 客户 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= C - a[i].c; j++) </span><br><span class="line">            dp[j] = std :: <span class="built_in">max</span>(dp[j], dp[j + a[i].c] + a[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="求答案"><a href="#求答案" class="headerlink" title="求答案"></a>求答案</h3><p>非常简单，长这样：</p><script type="math/tex; mode=display">ans=\max_{i=0}^{C}\{dp_i\}</script><p>注意，$i$ 的初始值为 $0$。</p><p>我最开始做的时候以为这个地方初始值是 $1$，因为 $ans$ 初始值就是 $0$ 嘛！于是喜提 $\text{18pts}$……</p><p>其实最终 $dp_0$ 不一定是没有购买计算机，也有可能是<strong>内核数量刚好消耗完</strong>。</p><p><del>Peter：这其实就和牛顿第一定律一样嘛，要么不受外力，要么合力为零，两种情况嘛。</del></p><p><del>我承认你说得很有道理，但是你是物理学疯了？</del></p><hr><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>不开 <code>long long</code> 见祖宗。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>) <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> c, f, v; <span class="keyword">bool</span> data; &#125; a[<span class="number">4005</span>];</span><br><span class="line"><span class="keyword">int</span> C, n, m, num, ans, dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.f != y.f)</span><br><span class="line">        <span class="keyword">return</span> x.f &gt; y.f;</span><br><span class="line">    <span class="keyword">if</span>(x.data != y.data)</span><br><span class="line">        <span class="keyword">return</span> x.data &lt; y.data;</span><br><span class="line">    <span class="keyword">if</span>(!x.data) </span><br><span class="line">        <span class="keyword">return</span> x.v &lt; y.v;</span><br><span class="line">    <span class="keyword">return</span> x.v &gt; y.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;a[i].c, &amp;a[i].f, &amp;a[i].v);</span><br><span class="line">        a[i].data = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;a[i].c, &amp;a[i].f, &amp;a[i].v);</span><br><span class="line">        a[i].data = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num = m + n;</span><br><span class="line">    std :: <span class="built_in">stable_sort</span>(a + <span class="number">1</span>, a + num + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">for(int i = 1; i &lt;= num; i++) </span></span><br><span class="line"><span class="comment">printf(&quot;%d %d %d %d\n&quot;, a[i].c, a[i].f, a[i].v, a[i].data);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!a[i].data) &#123; <span class="comment">// 计算机 </span></span><br><span class="line">            C += a[i].c;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = C; j &gt;= a[i].c; j--)</span><br><span class="line">                dp[j] = std :: <span class="built_in">max</span>(dp[j], dp[j - a[i].c] - a[i].v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 客户 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= C - a[i].c; j++) </span><br><span class="line">                dp[j] = std :: <span class="built_in">max</span>(dp[j], dp[j + a[i].c] + a[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= C; i++)</span><br><span class="line">        ans = std :: <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/record/62378782">AC 记录</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP2021 游记</title>
      <link href="/posts/CSP2021-%E6%B8%B8%E8%AE%B0/"/>
      <url>/posts/CSP2021-%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初二 CQ OIer，去年卡线省一（不会 <code>sort</code> 捞了 $\text{15pts}$），今年 CSP 划水。</p><p>感觉要退役了 qwq。</p><p>至于去年为啥没游记，我去年都不知道什么是游记……</p><hr><h2 id="初赛篇"><a href="#初赛篇" class="headerlink" title="初赛篇"></a>初赛篇</h2><h3 id="Day"><a href="#Day" class="headerlink" title="Day ???"></a>Day ???</h3><p><del>我去 TG 不就是去划水的吗。</del></p><p>因为双减似乎课没法上了，于是搞 OI 的时间变成了每天中午的中午训练。</p><p>mjl 真好玩，一天（一个小时）布置的任务如下：</p><ul><li><p>某年的 PJ <strong>和</strong> TG 初赛卷子</p></li><li><p>一道题（难度绿及以上）</p></li></ul><p>【我看不懂，但我大受震撼 orz】.jpg</p><p>放弃了 c++ 的题目，去搞初赛了。</p><hr><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>中午发了准考证。</p><p>然而，我突然发现我们学校为了省墨用的是黑白。</p><p>本来也没啥的，但是大家都知道，准考证上有本人照片……</p><p>于是机房就【数据删除】了（</p><p>看了下准考证号，PJ 600多，TG 200多。</p><hr><p>下楼的时候。</p><p>Peter：我觉得这次大题选 A 的几率特别高！（<code>flag</code>）</p><hr><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>本来说的是 7:30 起床，结果 7:00 就醒了。吃早饭之后发了个 <code>rp++</code>，就去考前颓废了（</p><p>提前半个小时到了我们学校高中部（考点），看了安排表，发现我们学校的大巨佬都在这儿了（甚至还有两个来拉高过关线的高三 NOI 金牌大佬），小蒟蒻十分紧张/kel。</p><p>初一初二一群人在科技楼一楼打打闹闹了至少 15 分钟，<del>期间我们甚至欣赏到了 XSC062 的可爱萝莉音（大雾）</del>。</p><p>然后社长<del>(cháng)</del>说他看到有人去 6 楼了，于是我们一行人坐电梯到六楼看到了 mjl……</p><h4 id="上午-TG"><a href="#上午-TG" class="headerlink" title="上午-TG"></a>上午-TG</h4><p>emm 我忘带身份证了？mjl 说穿着校服就行。哦那没事了。</p><p>9:30 开始考试，第一题是个啥？</p><p>继续做题，后面的题（指选择题）还好，不是很毒瘤。</p><p>开始做程序阅读。好家伙第一题就来立体几何？出题人我谢谢您。</p><blockquote><p>对了，话说 <code>acos(0.5)</code> 是什么啊？</p><p>Update：问了数学竞赛的同学，原来是反三角函数，当时我连这个数的近似值都不知道，肯定没办法手动模拟。</p></blockquote><p>第二题看上去是一个莫名其妙的求区间最大值，那个 Node 看了我好久，不过最终还是看明白了（大概吧？），希望不要出锅（小声 bb）。</p><p>第三题……好家伙直接手算 <code>base64</code>。出题人我谢谢您。</p><p>做完程序阅读只剩下了 20 分钟，有点慌。</p><p>开<del>完形填空</del>完善程序！</p><p>第一题乍一看是个数学题，再一看是个模拟题，因为时间不够了就大概看了下，随便口胡了几个上去。（T4 我故意选了个带 $r$ 的，然后就没了）</p><blockquote><p>我有个 $r$，诶，我不用，就是玩儿~</p></blockquote><p>出题人我谢谢您。</p><p>五分钟搞完第一题，开第二题。</p><p>第一眼：我看到了一个 <code>001</code>？感觉不妙。<del>去年 90 多行的手动模拟队列已经够了吧。</del></p><p>第二眼：RMQ？？<del>又是什么奇奇怪怪的数据结构。</del> 等等，现学？？出题人我谢谢您。</p><p>此时我又想起了昨天 Peter 的 <code>flag</code>。</p><p>于是我写了 6 个 A 上去。我倒是要看看他押题的能力怎么样（</p><p>于是 TG 就这么裂开了。</p><p>中午在机房看了民间答案之后的估分：$39.5$</p><hr><p>从考场出来之后，某个人因为太饿了，于是随手拔起一根草塞进了嘴里……</p><p>XSC062：这啥啊，怎么是酸的？</p><p>我：草（真·一种植物）。</p><p>和 Peter 还有 XSC062 聊了一下，发现我选择 T1 做错了（我不知道为什么我选成了 <code>cd</code>，答案应该是 <code>ls</code>），还了解到最后一道大题 D 最多。</p><p>我觉得我药丸了。</p><hr><h4 id="下午-PJ"><a href="#下午-PJ" class="headerlink" title="下午-PJ"></a>下午-PJ</h4><p>选择原题一堆，程序阅读继续手算 <code>base64</code>（</p><p>阅读 T2 好像是个奇奇怪怪的欧拉筛，不过那四个数组是啥没看懂 qwq。<del>像极了我平时敲代码乱取变量名的样子。</del></p><p><del>出题人，我错了，我以后再也不乱取变量名了！能不能饶了我！</del></p><p>其余不做评价……</p><p>估分：$62.5$</p><hr><h3 id="Day-n"><a href="#Day-n" class="headerlink" title="Day n"></a>Day n</h3><blockquote><p>指 9.27。</p></blockquote><p>出分了！</p><p>PJ：$72.5$</p><p>TG：$47$</p><p>TG 卡线过了，喜大普奔（</p><hr><h2 id="复赛篇"><a href="#复赛篇" class="headerlink" title="复赛篇"></a>复赛篇</h2><h3 id="Day-？"><a href="#Day-？" class="headerlink" title="Day ？"></a>Day ？</h3><p>因为我去年已经卡线 PJ1= 了，所以我妈没给我报 PJ，只报了 TG。</p><p>所以要求别那么高吧，我只是想要个 2= + 六级蓝勾勾 qwq。</p><hr><h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>上午补初赛游记，复习了下图论和高精的板子 <del>（然后根本没用上）</del>。</p><p>$\text{CSP 2021 rp++!}$</p><hr><p>下午到的比较早，找了了 xzj 和 zm<del>一起膜拜高年级的大佬</del>。其他人因为参加了普及还在学校里面的。</p><p>等了一会儿进去了，然后又是<del>互相膜拜，膜拜初三高中的巨佬</del>和奶题（zm：这次肯定有数据结构！），和初一初二的同学会合，然后进行传统艺能——照<del>遗</del>合照。</p><p>话说 BS 为什么不发三明治啊！去年 NK 都发了！！</p><p>到了机房，按照老师说的，新建文件，关机重启，下载 C++ 编译器，打框架。</p><p>然后密码发下来了。<del>什么鬼怎么是乱码，CCF 您可以用心一点吗。</del></p><p>打开题，通览一遍，直接确认 T4 是到不可做题。然后大概看了下，T1 是最简单的（Update：其实应该是 T3，但是当时没想到 T3 比 T1 简单，结果把 T1 的近似正解硬刚出来了），于是开始想 T1。</p><p>不过我想了很久，都只能想到 $O(n^2)$。然后突然想到可以用优先队列，貌似可以优化时间复杂度 <del>（虽然最后做出来还是两层循环……）</del></p><p>做了很久，中途突然发现做法假了样例过不了，后来才回忆起有结构体这回事……</p><p>差点忘了运算符重载……幸好想起来了。（<code>flag</code>）</p><p>时间复杂度 $O(n\log n)$，估分 $100\text{pts}$ 吧。</p><p>去上了个厕所，喝了点水，但是 T2T3 还是没思路。</p><p>然后我发现 T2 虽然感觉在哪里看到过但就是十分令人自闭（我的区间 DP 烂到不行），于是开始敲 T3 $O(2^{2n})$ 暴搜。这个暴搜很简单，一会儿就敲完了。</p><p>估分 $\text{28pts}$。</p><p>最后看了看 T2，因为想不出来十分自闭决定打全排列暴搜，结果暴搜都差点没打出来……因为不会判断字符串是否合法。</p><p>幸好最后 $10$ 分钟过样例了 qwq。</p><p>估分 $\text{15pts}$。</p><hr><p>出来之后又和 Peter 和 XSC062 聊（别问我为啥总是他们俩），得知基本上和我一样打暴搜，内心逐渐趋于平静……</p><hr><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>洛谷民间数据冲鸭！</p><p>结果出事了。</p><p>详情请见这个<a href="https://www.luogu.com.cn/discuss/371587">帖子</a>。</p><details class="folding-tag" blue><summary> 点击查看 CE 事件具体过程 </summary>              <div class='content'>              <p>帖子说得可能不太清楚……</p><p>我在考场上敲 T1 的时候忘了运算符重载怎么写，于是想了很久把 <code>operator</code> 这个单词想起来了，于是就敲了一句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node x, <span class="keyword">const</span> node y) &#123; <span class="keyword">return</span> x.Time &gt; y.Time; &#125;</span><br></pre></td></tr></table></figure><p>结果就少敲了前面的一个 <code>bool</code>，也就是说，正确的写法应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node x, <span class="keyword">const</span> node y) &#123; <span class="keyword">return</span> x.Time &gt; y.Time; &#125;</span><br></pre></td></tr></table></figure><p>好玩的是，CQ 没有提供 Linux 虚拟机，只提供了 Win7 的系统，然后这玩意儿正好在 Windows 系统可以过编译，然后在 Linux 上 CE 了……</p><p>更好玩的是，DJ 大佬在参加 PJ 的时候，T3 和我犯了一模一样的错误，和我一样挂了 $100$ 分，如果我们两个不挂这两道题的话，他就 AK 比赛了，我就有 7 级蓝勾了。</p><p>只可惜这个世界上没有什么如果。</p>              </div>            </details><p>我太 TM 高兴了，直接从 $143$ 挂到了 $43$，但凡我 T1 打个 $40$ 分的暴力也不至于这样。</p><hr><h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><p>向 mjl 吐槽 CCF 的测评环境问题导致我挂 100 分，他说没办法申诉。</p><p>然后因为是 Dev-C++ 的环境问题嘛，CQ 目测这几年还没办法搞 Linux 系统，所以 mjl 帮我测了一下 CodeBlocks，结果那个上面也能过。</p><p>所以这种问题只能依靠自己的力量了吗……</p><p>希望 CQ 明年可以有 NOI Linux 2.0 的虚拟机 QWQ。</p><hr><h3 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h3><p>过去了一周，mjl 叫我们补前三题。</p><p><em>(๑•̀ㅂ•́)و✧夹带私货：</em><a href="/posts/Solution-P7913"><em>CSP-S2021 T1 题解</em></a></p><p>然后晚上出分了。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/lut2vgpp.png" alt=""></p><p>和预估一样。</p><hr><h3 id="Day-n-1"><a href="#Day-n-1" class="headerlink" title="Day n"></a>Day n</h3><blockquote><p>指出结果的那一天。</p></blockquote><p>结果还算好，没打铁，得了个 3=。</p><p>还好还好有奖，就是不知道 NOIP 审核给不给过 QwQ……</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CSP-S 2021」廊桥分配 题解</title>
      <link href="/posts/Solution-P7913/"/>
      <url>/posts/Solution-P7913/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果您是从 ljt 的 CSP 游记过来的，那么您应该已经知道了 CE 惨案。如果您和我一样有这一类问题的话可以访问<a href="https://loj.ac/d/3422">这个帖子</a>，上面有一些值得采纳的建议。</p><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设 $s1_i$ 为国内航班有 $i$ 个停机位时能停在停机位的<strong>新增加</strong>的飞机个数。$s2_i$ 为国际，同理。</p><p>那么，我们需要一个结构体的优先队列来存每一个停机位的信息：会被占用到多久，停机位的编号。按照被占用截止时间从小到大排序。</p><p>而且，优先队列里只能存此时被占用的停机位。</p><hr><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p><strong>国内和国际分开枚举。</strong></p><p>拿一个 <code>bool</code> 数组 $is\_zhan$，$is\_zhan_i$ 代表第 $i$ 个停机位是否被占用。</p><p>每一次有一个飞机来的时候，就先把所被有占用截止时间小于这个飞机到达时间的停机位全部弹掉，然后从 $1$ 号机位开始统计，直到枚举到一个没有被占用的机位 $j$，就意味着这个飞机在机位数量至少为 $j$ 的时候可以停在停机坪上，所以：$s1_i ← s1_i + 1$。</p><p>国际同理。</p><p>最后再统计 $s1$ 和 $s2$ 的前缀和，枚举分配 $0\sim n$ 个机位给国内，找最大值。</p><p>时间复杂度 $O(M\log n + rp)$。（第二层循环不知道会卡多久）</p><hr><h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>cgy 大佬说我没有正确性证明，那我就来补一个吧。（不过这个东西感觉有点只可意会不可言传，可能我说得不清楚，见谅。）</p><p>我们打的优先队列在<strong>假设一种情况</strong>：有 $m$ 个停机位，从左到右编号为 $1, 2, \ldots, m$。这样可以保证所有飞机都能停到停机位里。</p><p>每一次有一个飞机到达的时候，我们就选择最左边的那个机位停飞机。此时，这个机位的编号就是它能停到停机位里所需要的最少的停机位数量。</p><p>为什么呢？</p><p>因为每一个飞机都在尽量往左边停，如果它停在了右边，就说明<strong>它来的时候左边的所有机位都被占领了，它只能停在右边。</strong> 我们假设它停在 $j$ 号位，刚才说的那个飞机停在 $i$ 号位，那么，对于任意一个停机位数量 $i\le k &lt; j$，都满足 $i$ 飞机可以停，但 $j$ 飞机不可以停的情况。</p><p>它右边的所有飞机都满足这个条件，而它左边的飞机都可以把它当做右边的飞机满足这个条件。所以 $i$ 飞机可以停的条件为 $i\le k$，而我们需要<strong>在可以停相同数量的飞机时，尽量节约停机位数量，使得另一个区域的飞机能停更多</strong>，所以上述条件成立。</p><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>需要把国内和国际的飞机按照<strong>到达时间</strong>排序。</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>) <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> s, t; &#125; a[maxn], b[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span> &#123;</span> <span class="keyword">int</span> Time, num; &#125;;</span><br><span class="line"><span class="keyword">int</span> n, tot, m1, m2, ans, s1[maxn], s2[maxn], sum1[maxn], sum2[maxn];</span><br><span class="line"><span class="keyword">bool</span> is_zhan[maxn];</span><br><span class="line">priority_queue &lt;que&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123; <span class="keyword">return</span> x.s &lt; y.s; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> que x, <span class="keyword">const</span> que y) &#123; <span class="keyword">return</span> x.Time &gt; y.Time; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;airport.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;airport.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m1, &amp;m2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i].s, &amp;a[i].t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m2; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;b[i].s, &amp;b[i].t);</span><br><span class="line">    <span class="built_in">stable_sort</span>(a + <span class="number">1</span>, a + m1 + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="built_in">stable_sort</span>(b + <span class="number">1</span>, b + m2 + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="comment">//国内</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>().Time &lt; a[i].s) &#123;</span><br><span class="line">            is_zhan[q.<span class="built_in">top</span>().num] = <span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        tot = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(is_zhan[tot]) ++tot;</span><br><span class="line">        is_zhan[tot] = <span class="number">1</span>;</span><br><span class="line">        ++s1[tot];</span><br><span class="line">        que qwq;</span><br><span class="line">        qwq.Time = a[i].t;</span><br><span class="line">        qwq.num = tot;</span><br><span class="line">        q.<span class="built_in">push</span>(qwq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(is_zhan, <span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(is_zhan));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">//国际 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m2; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>().Time &lt; b[i].s) &#123;</span><br><span class="line">            is_zhan[q.<span class="built_in">top</span>().num] = <span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        tot = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(is_zhan[tot]) ++tot;</span><br><span class="line">        is_zhan[tot] = <span class="number">1</span>;</span><br><span class="line">        ++s2[tot];</span><br><span class="line">        que qwq;</span><br><span class="line">        qwq.Time = b[i].t;</span><br><span class="line">        qwq.num = tot;</span><br><span class="line">        q.<span class="built_in">push</span>(qwq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//汇总 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum1[i] = sum1[i - <span class="number">1</span>] + s1[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum2[i] = sum2[i - <span class="number">1</span>] + s2[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = <span class="built_in">max</span>(ans, sum1[i] + sum2[n - i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>这个代码在洛谷和官方吸氧能过，但是我们 OJ 自造的毒瘤数据过不了（<del>而且教练死活不开 O2</del>）所以就有了优化。</p><p>大家注意到上面代码的一句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(is_zhan[tot]) ++tot;</span><br></pre></td></tr></table></figure><p>这玩意儿要是数据毒瘤能把时间复杂度卡到 $O(Mn\log n)$。</p><p>于是我们可以再开一个优先队列存没有被占用的机位，按照编号从小到大排序，每次只需要从这个序列里取第一个就行了。</p><p>所以 $is\_zhan$ 数组就这么退役了 qwq。</p><p>时间复杂度 $O(M\log n)$，跑得飞快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>) <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> s, t; &#125; a[maxn], b[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span> &#123;</span> <span class="keyword">int</span> Time, num; &#125;;</span><br><span class="line"><span class="keyword">int</span> n, tot, m1, m2, ans, s1[maxn], s2[maxn], sum1[maxn], sum2[maxn];</span><br><span class="line">priority_queue &lt;que&gt; q;</span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>, vector &lt;<span class="keyword">int</span>&gt;, greater &lt;<span class="keyword">int</span>&gt; &gt; no_zhan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123; <span class="keyword">return</span> x.s &lt; y.s; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> que x, <span class="keyword">const</span> que y) &#123; <span class="keyword">return</span> x.Time &gt; y.Time; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m1, &amp;m2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i].s, &amp;a[i].t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m2; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;b[i].s, &amp;b[i].t);</span><br><span class="line">    <span class="built_in">stable_sort</span>(a + <span class="number">1</span>, a + m1 + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="built_in">stable_sort</span>(b + <span class="number">1</span>, b + m2 + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="comment">//国内</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1; i++) no_zhan.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>().Time &lt; a[i].s) &#123;</span><br><span class="line">            no_zhan.<span class="built_in">push</span>(q.<span class="built_in">top</span>().num);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        tot = no_zhan.<span class="built_in">top</span>();</span><br><span class="line">        no_zhan.<span class="built_in">pop</span>();</span><br><span class="line">        ++s1[tot];</span><br><span class="line">        que qwq;</span><br><span class="line">        qwq.Time = a[i].t;</span><br><span class="line">        qwq.num = tot;</span><br><span class="line">        q.<span class="built_in">push</span>(qwq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!no_zhan.<span class="built_in">empty</span>()) no_zhan.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">//国际 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m2; i++) no_zhan.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m2; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>().Time &lt; b[i].s) &#123;</span><br><span class="line">            no_zhan.<span class="built_in">push</span>(q.<span class="built_in">top</span>().num);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        tot = no_zhan.<span class="built_in">top</span>();</span><br><span class="line">        no_zhan.<span class="built_in">pop</span>();</span><br><span class="line">        ++s2[tot];</span><br><span class="line">        que qwq;</span><br><span class="line">        qwq.Time = b[i].t;</span><br><span class="line">        qwq.num = tot;</span><br><span class="line">        q.<span class="built_in">push</span>(qwq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//汇总 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum1[i] = sum1[i - <span class="number">1</span>] + s1[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum2[i] = sum2[i - <span class="number">1</span>] + s2[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = <span class="built_in">max</span>(ans, sum1[i] + sum2[n - i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.10.16 考试总结</title>
      <link href="/posts/2021-10-16-%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/posts/2021-10-16-%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总分 $500$，得分 $90$。非常裂开，非常无语(ˉ▽ˉ；)…</p><p>欢迎收看《关于 ljt 是怎么挂掉 $\text{240pts}$ 的》。</p><hr><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>一道很简单的贪心，把运动员按照能力大小排序，统计运动员的总参赛时间，如果没到就加上这个运动员的能力值与参加比赛时间之积。另外，因为我们是按照能力值从大到小排序的，所以需要让排在前面的运动员尽量多一些时间，<del>也就是说，这道题里面我们要当万恶的资本家，把能力值最大的几个运动员都榨干</del>。</p><p>不开 <code>long long</code> 见祖宗，挂了 $\text{40pts}$。另外一定要注意 <code>long long</code> 要开全，否则会导致 $\text{65pts}$ 惨案。</p><p><del>zszz，<code>#define int long long</code> 是个好东西</del>。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> k, l; &#125; a[maxn];</span><br><span class="line"><span class="keyword">int</span> m, n, tot, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123; <span class="keyword">return</span> x.k &gt; y.k; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;marathon.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;marathon.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a[i].k, &amp;a[i].l);</span><br><span class="line">    <span class="built_in">stable_sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tot &gt;= <span class="number">6</span> * m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot + a[i].l &lt;= <span class="number">6</span> * m) &#123;</span><br><span class="line">            ans += a[i].k * a[i].l;</span><br><span class="line">            tot += a[i].l;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += a[i].k * (<span class="number">6</span> * m - tot);</span><br><span class="line">            tot = <span class="number">6</span> * m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><del>说句闲话：对了，你们有没有注意到 ljt 最近换码风了？我感觉之前那种太紧凑了不好调代码就换了 qwq。</del></p><hr><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>《关于 ljt 因为把 <code>Friday</code> 打成 <code>Firday</code> 而痛失 $\text{100pts}$ 这回事》</p><p>直接无语了。</p><p>小模拟，<del>觉得这道题不过瘾的可以去做做儒略日</del>，注意闰年的判断，以及初始值（$2011.1.1$ 是星期六）。</p><ol><li>普通年能被 $4$ 整除且不能被 $100$ 整除的为闰年。(如 $2004$ 年就是闰年，$1901$ 年不是闰年)</li><li>世纪年能被 $400$ 整除的是闰年。(如 $2000$ 年是闰年，$1900$ 年不是闰年)</li></ol><p>因为数据很大，而且是多组数据（考试范围写的是时间早于 $99999.12.31$ 后来数据只出到了 $3199.12.31$……离谱），我们可以使用一个办法来避免 TLE ——<strong>离线</strong>。</p><p>离线大概就是<strong>一次性把所有测试数据都存下来</strong>，按照大小排序，这样只用跑一遍从 $2011$ 到 $99999$ 的年份就可以判断完所有数据。</p><p>具体看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2011/01/01: Saturday</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =(<span class="keyword">int</span>)<span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> y, m, d, num, ans; &#125; a[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> M[<span class="number">2</span>][<span class="number">13</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;, &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> date = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// sunday,monday,tuesday,wednesday,thursday,friday,saturday</span></span><br><span class="line"><span class="keyword">char</span> ans[<span class="number">7</span>][<span class="number">15</span>] = &#123; <span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">earlier</span><span class="params">(<span class="keyword">int</span> y1, <span class="keyword">int</span> m1, <span class="keyword">int</span> d1, <span class="keyword">int</span> y2, <span class="keyword">int</span> m2, <span class="keyword">int</span> d2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y1 &lt; y2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(y1 &gt; y2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(m1 &lt; m2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m1 &gt; m2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(d1 &lt; d2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(node x, node y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">earlier</span>(x.y, x.m, x.d, y.y, y.m, y.d); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(node x, node y)</span> </span>&#123; <span class="keyword">return</span> x.num &lt; y.num; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y % <span class="number">4</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(y % <span class="number">100</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(y % <span class="number">400</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="built_in">freopen</span>(<span class="string">&quot;date.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">     <span class="built_in">freopen</span>(<span class="string">&quot;date.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>, Num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a[tot].y, &amp;a[tot].m, &amp;a[tot].d) != EOF) &#123;</span><br><span class="line">        a[tot].num = tot;</span><br><span class="line">        ++tot;</span><br><span class="line">    &#125;</span><br><span class="line">    --tot;</span><br><span class="line">    <span class="built_in">stable_sort</span>(a + <span class="number">1</span>, a + tot + <span class="number">1</span>, cmp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> year = <span class="number">2011</span>; year &lt;= a[tot].y; year++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> month = <span class="number">1</span>; month &lt;= <span class="number">12</span>; month++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">run</span>(year) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> day = <span class="number">1</span>; day &lt;= M[t][month]; day++) &#123;</span><br><span class="line">                <span class="keyword">while</span>(year == a[Num].y &amp;&amp; month == a[Num].m &amp;&amp; day == a[Num].d) &#123;</span><br><span class="line">                    a[Num].ans = date;</span><br><span class="line">                    ++Num;</span><br><span class="line">                &#125;</span><br><span class="line">                date = (date + <span class="number">1</span>) % <span class="number">7</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stable_sort</span>(a + <span class="number">1</span>, a + tot + <span class="number">1</span>, cmp2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ans[a[i].ans]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>出题人语文显然需要重修。</p><p>这道题是什么呢，大概就是给一个数 $m$，要求从 $1\sim m$ 中找到一个数 $n$ 使得 $1\sim n$ 中与 $m$ 互质的数的数量与 $n$ 之比最小。</p><p>数据范围是 $1\le m\le 10^{40}$，这不仅告诉我们要开高精，还告诉我们这题肯定有一些奇奇怪怪的性质。</p><p>通过分析样例：</p><p>样例输入 1：<code>10</code></p><p>样例输出 1：<code>6</code></p><p>$6=2\times 3$</p><p>也就是 $3$ 及以内的所有质数相乘。</p><p>样例输入 2：<code>10000000000</code></p><p>样例输出 2：<code>6469693230</code></p><p>$6469693230=2×3×5×7×11×13×17×19×23×29$</p><p>也就是 $29$ 及以内的质数相乘。<del>别问我要怎么看出来，这是 zm 说的，我也不知道。</del></p><p>为什么是 $29$ 呢？因为如果取 $31$ 的话，就超过 $m$ 了，而选用 $29$ 是不超过 $m$ 中最大的那个。</p><p>到这里思路就很明显了：线性筛质数，然后疯狂相乘找答案。时间复杂度是 $O\text{(质数的个数)}$，绝对不会超过 $10^5$。</p><p>需要的高精是高精乘和高精比较，你们爱复制板子就去复制板子吧。<del>反正我也是复制的板子。</del></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>)<span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">string m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> g[maxn], tot;</span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn &gt;&gt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f[i]) g[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t = i * g[j];</span><br><span class="line">            <span class="keyword">if</span> (t &gt; maxn) <span class="keyword">break</span>;</span><br><span class="line">            f[t] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i % g[j])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">mul</span><span class="params">(string a1, string b1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10005</span>] = &#123;&#125;, b[<span class="number">10005</span>] = &#123;&#125;, c[<span class="number">10005</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (a1 == <span class="string">&quot;0&quot;</span> || b1 == <span class="string">&quot;0&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string c1;</span><br><span class="line">    <span class="keyword">int</span> lena = a1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lenb = b1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena; i++) a[lena - i] = a1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenb; i++) b[lenb - i] = b1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> lenc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenb; j++) &#123;</span><br><span class="line">            lenc = i + j - <span class="number">1</span>;</span><br><span class="line">            c[lenc] += a[i] * b[j];</span><br><span class="line">            c[lenc + <span class="number">1</span>] += c[lenc] / <span class="number">10</span>;</span><br><span class="line">            c[lenc] %= <span class="number">10</span>;</span><br><span class="line">            lenc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lenc = lena + lenb;</span><br><span class="line">    <span class="keyword">while</span> (!c[lenc]) lenc--;</span><br><span class="line">    <span class="keyword">while</span> (lenc &gt;= <span class="number">1</span>) c1 += c[lenc--] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Max</span><span class="params">(string x, string y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">size</span>() &gt; y.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x.<span class="built_in">size</span>() &lt; y.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i] &gt; y[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x[i] &lt; y[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        a += x % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) b += a[i];</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;flower.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;flower.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">Prime</span>();</span><br><span class="line">    string qwq = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn - <span class="number">5</span>; i++) &#123;</span><br><span class="line">        string r = qwq;</span><br><span class="line">        qwq = <span class="built_in">mul</span>(<span class="built_in">str</span>(g[i]), qwq);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Max</span>(qwq, m)) &#123;</span><br><span class="line">            cout &lt;&lt; r;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>LIS 板子题，LIS 普通版板子都能写挂我也是服了自己了。</p><p>首先初始长度（不斜对角穿）肯定是 $100\times(m+n)$，然后考虑穿对角线的情况。我们把所有允许穿对角线的方块按照 $x$ 值从小到大排序，然后找 $y$ 值的 LIS 即可。</p><p>来自 cgy：<code>sqrt(2)</code> 打成 <code>1.414</code>，精度挂了 $\text{60pts}$。<del>为 cgy 大佬默哀。</del></p><p>LIS 是板子，不需要我讲了吧？</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> x, y; &#125; a[maxk];</span><br><span class="line"><span class="keyword">int</span> m, n, k, qaq, dp[maxk]; <span class="comment">// LIS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123; <span class="keyword">return</span> x.x &lt; y.x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;metro.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;metro.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">    <span class="built_in">stable_sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="comment">//LIS</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j].y &lt; a[i].y) t = <span class="built_in">max</span>(t, dp[j] + <span class="number">1</span>);</span><br><span class="line">            qaq = <span class="built_in">max</span>(qaq, t);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="keyword">int</span>)<span class="built_in">round</span>(((m + n) * <span class="number">100</span> - qaq * (<span class="number">200</span> - <span class="number">100</span> * (<span class="keyword">long</span> <span class="keyword">double</span>)<span class="built_in">sqrt</span>(<span class="number">2</span>)))));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h3><p>骗分能拿 $\text{30pts}$：如果修改的次数大于等于掉头指令的个数，就把所有掉头改成前进，然后疯狂改一个指令根据奇偶性判断是不是能改到前进指令从而判断答案。</p><p>正解是 dp：</p><ul><li><p>$dp_{i,j,0,0/1}$ 代表执行前 $i$ 条指令，改 $j$ 次指令，目前头朝正轴方向，在 正数区/负数区 离原点的最远距离。</p></li><li><p>$dp_{i,j,1,0/1}$ 代表执行前 $i$ 条指令，改 $j$ 次指令，目前头朝负轴方向，在 正数区/负数区 离原点的最远距离。</p></li></ul><p>代码鸽掉了。</p>]]></content>
      
      
      <categories>
          
          <category> 考试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP2021 刷题记录之模拟板块</title>
      <link href="/posts/CSP2021-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%A8%A1%E6%8B%9F%E6%9D%BF%E5%9D%97/"/>
      <url>/posts/CSP2021-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%A8%A1%E6%8B%9F%E6%9D%BF%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>不保证所有代码的正确性，它们仅仅是通过了所有数据点而已。</p><p>整体难度：红~黄（PJ 模拟不会有什么难题哒 qwq）</p><hr><h2 id="T1-计算器的改良"><a href="#T1-计算器的改良" class="headerlink" title="T1 计算器的改良"></a>T1 计算器的改良</h2><p>AC at 2021-07-31 14:34:08.</p><p>难度：黄</p><p>解一元一次方程，就是把未知数的系数移到等号左边，常数移到等号右边，然后再除一下就可以了。</p><p>我们设置两个变量 $l,r$，分别代表未知数系数计算后的结果和常数的计算结果。最后模拟就可以了。记得“移项变号”，而且往左移和往右移是相反的，如果写成一样了的可以像我一样在任意一边加一个负号，不影响结果。</p><p>不过这个模拟还是有些讲究的。</p><p>首先要把整个字符串分为 $3$ 个部分：等号左边、等号和等号右边。</p><p>先遍历等号左边，如果看到数字了就把这个连续是一段数字的字符给转化为整数类型，然后再看这到底是系数还是常数；再再看正负。关于正负可以使用布尔变量来标记。</p><p>如果是系数就甩到 $l$ 变量，是常数就甩到 $r$ 变量。注意怎么甩，要移项变号。这时候可能要移项也有可能不移，要注意。</p><p>遇到减号，把布尔变量设为真。</p><p>遇到加号，把布尔变量设为假。（因为我们默认的系数和常数的符号是正，所以加号并没有什么用，只需要布尔变量归零就可以了）</p><p>遇到字母特判（经过数字的判断之后，这个字母就是系数为 $±1$ 的未知数），也需移项变号。</p><p>等号右边同理。</p><p>记得存未知数的字母，别像我一样最后有一个测试点未知数只在等号右边，但是我处理那一块的时候没写存未知数字母的语句[捂脸]。</p><p>废话不多说，上代码。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> fh,a[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> len,h,l,r;</span><br><span class="line"><span class="keyword">bool</span> is_fu; <span class="comment">//用来判断这个系数 or 常数是不是负数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a+<span class="number">1</span>);</span><br><span class="line">    len=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//等号左边 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">            h=i+<span class="number">1</span>;</span><br><span class="line">            is_fu=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">&#x27;+&#x27;</span>) is_fu=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">&#x27;-&#x27;</span>) is_fu=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(a[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                k=k*<span class="number">10</span>+a[i]-<span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">if</span>(a[i+<span class="number">1</span>]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;a[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;z&#x27;</span>||a[i+<span class="number">1</span>]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;a[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123; <span class="comment">//未知数 </span></span><br><span class="line">                fh=a[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(is_fu)&#123;</span><br><span class="line">                    l-=k;</span><br><span class="line">                    is_fu=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> l+=k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//数字 </span></span><br><span class="line">                <span class="keyword">if</span>(is_fu)&#123;</span><br><span class="line">                    r-=k;</span><br><span class="line">                    is_fu=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> r+=k;</span><br><span class="line">            &#125;</span><br><span class="line">            k=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等号右边 </span></span><br><span class="line">    is_fu=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;+&#x27;</span>) is_fu=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">&#x27;-&#x27;</span>) is_fu=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(a[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                k=k*<span class="number">10</span>+a[i]-<span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">if</span>(a[i+<span class="number">1</span>]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;a[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;z&#x27;</span>||a[i+<span class="number">1</span>]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;a[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123; <span class="comment">//未知数 </span></span><br><span class="line">                fh=a[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(is_fu)&#123;</span><br><span class="line">                    l+=k;</span><br><span class="line">                    is_fu=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> l-=k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//数字 </span></span><br><span class="line">                <span class="keyword">if</span>(is_fu)&#123;</span><br><span class="line">                    r+=k;</span><br><span class="line">                    is_fu=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> r-=k;</span><br><span class="line">            &#125;</span><br><span class="line">            k=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c=%.3lf&quot;</span>,fh,-r*<span class="number">1.0</span>/l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h2 id="T2-税收与补贴问题"><a href="#T2-税收与补贴问题" class="headerlink" title="T2 税收与补贴问题"></a>T2 税收与补贴问题</h2><p>AC at 2021-08-06 9:44:39.</p><p>难度：黄</p><p><del>我寻思着这出题人语文该从小学重修叭。</del></p><p>大概意思就是先让你补全一个价格和购买人数关系的表，然后在价格上统一加（补贴）或减（收税）一个数，<strong>但是购买的人数不变</strong>，然后使得政府给出的这个价位获得的<strong>利润</strong>是所有价位都经过这个变化后中最大的。</p><p>实现我们可以用两个数组，一个用来输入，另一个，下标表示价格，数组里的值代表这个下标的价格所对应的人数。</p><p>这个问题有两个部分：</p><h3 id="1-补全表格（此题最难部分）"><a href="#1-补全表格（此题最难部分）" class="headerlink" title="1.补全表格（此题最难部分）"></a>1.补全表格（此题最难部分）</h3><p>题目有一个隐藏条件：在任意两个给定了人数的价格之间如果有没有给定人数的价格，那么中间所有没有给定人数的价格的人数都是“均匀地下降”，就是每两个价格所对应的人数差是一样的。</p><p>所以，遇到没有输入人数的价格时，就有三种情况：</p><ol><li><p>这个价格小于给定人数的最大价格。</p></li><li><p>这个价格大于给定人数的最大价格。 </p></li><li><p>这个价格是不合法的。（即小于成本价或者购买人数是负数）</p></li></ol><p>为了避免计算不合法的价格，我们从成本价往上枚举价格，如果计算出来的人数是负数或 $0$ 就立刻跳出循环。</p><p>思考如何计算第一种情况。假设我们已经枚举到了价格 $=i$。</p><p>我们需要确定这个价格两端最近的已经确定人数的价格是多少，因为我们是从小到大算，所以价格为 $i-1$ 时的价格肯定已经算出。至于比它大的，枚举可以找出，在枚举的同时我们可以用一个 $num$ 变量统计一下这中间价格的数量。</p><p>然后我们需要计算它对应的人数。怎么算呢？为了好理解我们把它分成两步：</p><p>第一步，算出两两价格之间的差值。</p><p>公式：$d=\dfrac{b_{i-1}-b_R}{num}$，可以根据等差公式得出，也可以自己推（难度不大）。</p><p>其中 $b$ 是上述提及实现方式的那个下标代表价格的数组。</p><p>第二步，根据 $i-1$ 算出 $i$。</p><p>这个就很简单啦， $b_i=b_{i-1}+d$ 即可。</p><p>然后再看看第二种情况。这个很简单，只需要在前面的基础上减去最后输入的那个数就可以了。</p><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l=a[<span class="number">0</span>].money;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//只要没有强制退出就一直循环</span></span><br><span class="line">        <span class="keyword">if</span>(b[l])&#123; <span class="comment">//这个价格输入中有对应，直接跳过</span></span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[l<span class="number">-1</span>]-p&lt;=<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//如果这个价格不合法，退出循环</span></span><br><span class="line">        <span class="keyword">if</span>(l&lt;Max)&#123; <span class="comment">//情况一</span></span><br><span class="line">            <span class="keyword">int</span> R=l,num=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!b[R]) R++,num++; <span class="comment">//统计数量，找右端点</span></span><br><span class="line">            b[l]=b[l<span class="number">-1</span>]-(b[l<span class="number">-1</span>]-b[R])/num;</span><br><span class="line">        &#125;<span class="keyword">else</span> b[l]=b[l<span class="number">-1</span>]-p; <span class="comment">//情况二</span></span><br><span class="line">        l++;</span><br><span class="line">        Maxr=<span class="built_in">max</span>(Maxr,l); <span class="comment">//寻找合法价格的最右端点</span></span><br><span class="line">    &#125;</span><br><span class="line">    Maxr--; <span class="comment">//需要 -1，因为在此之前 l 加了 1</span></span><br></pre></td></tr></table></figure><h3 id="2-计算答案"><a href="#2-计算答案" class="headerlink" title="2.计算答案"></a>2.计算答案</h3><p>过了难点我们就可以快乐地模拟了！</p><p>枚举补贴/收税的钱数，范围随意，能 A 就行/xyx。</p><p>大概思路就是暴力把每一个价位下补贴/收税后的利润做对比，如果政府规定的那个价格是最大的就可以输出。</p><p>比较简单（指我错了 $10^9+7$ 遍，细节比较多 (〃＞目＜)），看代码理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=MAXN<span class="number">-5</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//补贴i元</span></span><br><span class="line">        <span class="keyword">int</span> maxnum=<span class="number">0</span>; <span class="comment">//这个变量是用来统计最大的获利</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a[<span class="number">0</span>].money;j&lt;=Maxr;j++)&#123;</span><br><span class="line">            maxnum=<span class="built_in">max</span>(maxnum,(j+i-a[<span class="number">0</span>].money)*b[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxnum==(n+i-a[<span class="number">0</span>].money)*b[n])&#123; <span class="comment">//最大获利地数量等于政府规定地价格，输出结束</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//收税i元 </span></span><br><span class="line">        maxnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a[<span class="number">0</span>].money;j&lt;=Maxr;j++)&#123;</span><br><span class="line">            maxnum=<span class="built_in">max</span>(maxnum,(j-i-a[<span class="number">0</span>].money)*b[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxnum==(n-i-a[<span class="number">0</span>].money)*b[n])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-%d&quot;</span>,i); <span class="comment">//注意有负号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><p>最后加上预处理、特判等。</p><p>特别注意输入，坑死我……&lt;( ￣^￣)-+——。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> money,num;&#125;a[MAXN];</span><br><span class="line"><span class="keyword">int</span> Max,Maxr,n,p,tot,b[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//输入及预处理 </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;a[<span class="number">0</span>].money,&amp;a[<span class="number">0</span>].num);</span><br><span class="line">    b[a[<span class="number">0</span>].money]=a[<span class="number">0</span>].num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ++tot;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[tot].money,&amp;a[tot].num);</span><br><span class="line">        <span class="keyword">if</span>(a[tot].money==<span class="number">-1</span>&amp;&amp;a[tot].num==<span class="number">-1</span>)&#123;</span><br><span class="line">            --tot;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Max=<span class="built_in">max</span>(Max,a[tot].money);</span><br><span class="line">        b[a[tot].money]=a[tot].num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    <span class="comment">//for(int i=a[0].money;i&lt;=Max;i++) printf(&quot;%d %d\n&quot;,i,b[i]);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p);</span><br><span class="line">    <span class="comment">//补全条件</span></span><br><span class="line">    <span class="keyword">int</span> l=a[<span class="number">0</span>].money;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[l])&#123;</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[l<span class="number">-1</span>]-p&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;Max)&#123;</span><br><span class="line">            <span class="keyword">int</span> R=l,num=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!b[R]) R++,num++;</span><br><span class="line">            b[l]=b[l<span class="number">-1</span>]-(b[l<span class="number">-1</span>]-b[R])/num;</span><br><span class="line">        &#125;<span class="keyword">else</span> b[l]=b[l<span class="number">-1</span>]-p;</span><br><span class="line">        l++;</span><br><span class="line">        Maxr=<span class="built_in">max</span>(Maxr,l);</span><br><span class="line">    &#125;</span><br><span class="line">    Maxr--;</span><br><span class="line">    <span class="comment">//枚举</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=MAXN<span class="number">-5</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//补贴i元</span></span><br><span class="line">        <span class="keyword">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a[<span class="number">0</span>].money;j&lt;=Maxr;j++)&#123;</span><br><span class="line">            maxnum=<span class="built_in">max</span>(maxnum,(j+i-a[<span class="number">0</span>].money)*b[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxnum==(n+i-a[<span class="number">0</span>].money)*b[n])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//收税i元 </span></span><br><span class="line">        maxnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a[<span class="number">0</span>].money;j&lt;=Maxr;j++)&#123;</span><br><span class="line">            maxnum=<span class="built_in">max</span>(maxnum,(j-i-a[<span class="number">0</span>].money)*b[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxnum==(n-i-a[<span class="number">0</span>].money)*b[n])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-%d&quot;</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NO SOLUTION&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="T3-乒乓球"><a href="#T3-乒乓球" class="headerlink" title="T3 乒乓球"></a>T3 乒乓球</h2><p>AC at 2021-07-31 14:50:38.</p><p>难度：橙</p><p>模拟水题，按照一轮一轮枚举。注意一轮结束需要同时满足两个条件，否则不要结束。</p><p>这题坑比较多，这里列两个我错过的：</p><ol><li><p>如果给出的字符串刚刚好到一轮结束，需要在后面再输出一个“0:0”（也不知道为什么）；</p></li><li><p>如果第一个字符是“E”记得输出两个“0:0”。</p></li></ol><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b)</span></span><br><span class="line"><span class="keyword">int</span> len,tot;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">25</span>],a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>)!=EOF)&#123;</span><br><span class="line">        len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>||s[i]==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;E&#x27;</span>) <span class="keyword">goto</span> type1;</span><br><span class="line">            a[++tot]=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    type1:</span><br><span class="line">    <span class="keyword">int</span> w,l;</span><br><span class="line">    <span class="keyword">if</span>(!tot)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0:0\n\n0:0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//11</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        w=<span class="number">0</span>,l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((w&lt;<span class="number">11</span>&amp;&amp;l&lt;<span class="number">11</span>||<span class="built_in">abs</span>(w-l)&lt;<span class="number">2</span>)&amp;&amp;i&lt;=tot)&#123;</span><br><span class="line">            w+=(a[i]==<span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">            l+=(a[i]==<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">if</span>(i==tot)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,w,l);</span><br><span class="line">            <span class="keyword">if</span>(w==<span class="number">11</span>||l==<span class="number">11</span>) <span class="built_in">printf</span>(<span class="string">&quot;0:0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,w,l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">//21</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        w=<span class="number">0</span>,l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((w&lt;<span class="number">21</span>&amp;&amp;l&lt;<span class="number">21</span>||<span class="built_in">abs</span>(w-l)&lt;<span class="number">2</span>)&amp;&amp;i&lt;=tot)&#123;</span><br><span class="line">            w+=(a[i]==<span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">            l+=(a[i]==<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">if</span>(i==tot)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,w,l);</span><br><span class="line">            <span class="keyword">if</span>(w==<span class="number">21</span>||l==<span class="number">21</span>) <span class="built_in">printf</span>(<span class="string">&quot;0:0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,w,l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="T4-不高兴的津津"><a href="#T4-不高兴的津津" class="headerlink" title="T4 不高兴的津津"></a>T4 不高兴的津津</h2><p>AC at 2021-07-30 21:25:42.</p><p>难度：红</p><p>这真的没什么好说的了，模拟即可 <del>，有手就行</del>。/cy</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b) </span></span><br><span class="line"><span class="keyword">int</span> Max,ans,a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(Max&lt;a+b) ans=i;</span><br><span class="line">        Max=<span class="built_in">max</span>(a+b,Max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Max&lt;=<span class="number">8</span>) ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="T5-花生采摘"><a href="#T5-花生采摘" class="headerlink" title="T5 花生采摘"></a>T5 花生采摘</h2><p>AC at 2021-07-31 14:12:53.</p><p>难度：橙</p><p>为什么我觉得这道题应该算这套题里面比较难的了？</p><p>首先注意一个大坑：<strong>采花生需要时间！</strong>（这个我错了很久）</p><p>然后如果您认真读题，就会发现它并不是一个 dp，而是一个不大的模拟(￣y▽,￣)╭ 。（因为 mjl 归类的是模拟板块，我想如果这是考场上我八成会犯这个错误）。</p><p>首先把所有花生的坐标和果子数量存到一个结构体数组里面，然后按照果子数量从大到小排序，因为采摘花生的顺序是按照从大到小排的。</p><p>【未完待更 qwq】</p>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P7179 [COCI2014-2015#4] STANOVI 题解</title>
      <link href="/posts/Solution-P7179/"/>
      <url>/posts/Solution-P7179/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7179">题目链接</a></p><p>记忆化搜索，其实思路不太难吧，但是优化比较难想，建议评蓝。</p><hr><p>题意简述：</p><p>有一个 $m\times n$ 的方格矩阵，把这个矩阵分为若干部分，且要求每一个矩阵都要与边界相邻。令 $k$ 为标准面积，不满意度为{所有矩阵面积减去 $k$ 的平方}之和。求最小的不满意度。</p><hr><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>lg 题库里有道题叫<a href="https://www.luogu.com.cn/problem/P4160">生日快乐</a>（这道题是蓝的，但是难度严重虚高，个人觉得最多是绿），其实思路相仿，不过这题要难一些。</p><p>我们假设拿到了一个<strong>已知所有信息、且满足四周有边界的矩阵</strong>，我们要对它进行搜索。</p><p>首先我们要解决<strong>传参问题</strong>：什么算已知条件，而且如何判断这个矩阵是不是满足条件呢？</p><p>首先长和宽是有必要的。而且因为这道题要求<strong>每一个矩阵都要挨着边界</strong>，所以我们需要知道它四面挨着边界的情况。</p><p>dfs 函数中传 $6$ 个参数：</p><ul><li><p><code>int</code> 类型：$x$ （矩阵的长），$y$ （矩阵的宽）。</p></li><li><p><code>bool</code> 类型：<code>up</code> （此矩阵上面那条边是否挨着边界），<code>down</code> （下面那条边是否挨着边界），<code>left</code> （左边那条边是否挨着边界），<code>right</code> （右边那条边是否挨着边界）。</p></li></ul><hr><p>解决完了 dfs 函数的传参问题，那怎么搜索呢？</p><p>我们先来分析出口。</p><p>由于题目要求，只要已知一个矩阵四面都没挨着边界，就直接返回一个极大值。</p><p>对于一个满足条件且已知的矩阵，有两种思路：</p><ol><li><p>直接把它作为一个最终划分的矩阵；</p></li><li><p>把它继续分成更小的矩阵。</p></li></ol><p>第一种思路很好解决，直接按照长、宽求就行了。</p><p>关键是第二种。</p><p>为了方便大家理解，我随便画了一个矩阵举例说明：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ipcadd46.png" alt=""></p><p>（<del>Excel 真好用啊</del>，蓝色为边界的<strong>外面那一圈</strong>）</p><p>对于这个矩阵，我们又有两种划分的方法：</p><ol><li>横着切；</li></ol><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/763xd6p8.png" alt=""></p><p>（红色的地方就是能切的地方。）</p><ol><li>竖着切。</li></ol><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/x10vt7q5.png" alt=""></p><p>那我们只需要分两种情况，分别枚举切割的地方，寻找最小值就可以了。（比如说，枚举上面/左边那个矩阵的长/宽）</p><p>最后再看一下哪种情况会更好。</p><p>注意一个细节：横着切需满足 $x&gt;1$，竖着切需满足 $y&gt;1$。</p><p>核心代码大概长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(up||down||left||right)) <span class="keyword">return</span> inf; <span class="comment">//不沿海 </span></span><br><span class="line">ll ans1=<span class="built_in">pow</span>(x*y-k,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;y==<span class="number">1</span>) <span class="keyword">return</span> ans1;</span><br><span class="line">ll ans2=inf;</span><br><span class="line"><span class="keyword">bool</span> u1,u2,d1,d2,l1,l2,r1,r2;</span><br><span class="line"><span class="comment">//横着分开</span></span><br><span class="line">u1=up,u2=<span class="number">0</span>,d1=<span class="number">0</span>,d2=down,l1=l2=left,r1=r2=right;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;x;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="built_in">dfs</span>(i,y,u1,d1,l1,r1)+<span class="built_in">dfs</span>(x-i,y,u2,d2,l2,r2);</span><br><span class="line">        ans2=<span class="built_in">min</span>(ans2,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//竖着分开 </span></span><br><span class="line">u1=u2=up,d1=d2=down,l1=left,l2=<span class="number">0</span>,r1=<span class="number">0</span>,r2=right;</span><br><span class="line"><span class="keyword">if</span>(y&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;y;i++)&#123;</span><br><span class="line">   <span class="keyword">int</span> t=<span class="built_in">dfs</span>(x,i,u1,d1,l1,r1)+<span class="built_in">dfs</span>(x,y-i,u2,d2,l2,r2);</span><br><span class="line">        ans2=<span class="built_in">min</span>(ans2,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(ans1,ans2);</span><br></pre></td></tr></table></figure><hr><h3 id="记忆化"><a href="#记忆化" class="headerlink" title="记忆化"></a>记忆化</h3><p>开一个六维的数组 $dp$，每一维都对应一个传的参数，把 dfs 的值存在里面即可。</p><p>这个时候有人就会说了：可是不一样的矩阵可能六个参数都一样，那这个如何判断？</p><p>答案是不需要判断。虽然的确这种情况是存在的，但是，如果六个参数都一样，算出来的结果肯定也一样，这不会影响结果，还会减小运行的时间。</p><hr><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><ul><li><strong>可行性剪枝</strong></li></ul><p>观察一下上面的图，不难发现，有一些情况是不能做横着或者竖着的分割的，比如说这种：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ols6p9jk.png" alt=""></p><p>这个东西就不能竖着切，因为如果竖着切了，左边的那个矩阵就不挨着边界了。</p><p>那我们可以写出矩阵要横着切和竖着切的条件：</p><ul><li><p>横着：<code>up&amp;&amp;down||left||right</code></p></li><li><p>竖着：<code>left&amp;&amp;right||up||down</code></p></li></ul><p>为什么呢？以横着切举例：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/glxngxbg.png" alt=""></p><p>现在四面是否挨着边界不知道。</p><p>如果要求成功，就必须满足下列<strong>至少一个</strong>条件：</p><ol><li><p>上面和下面<strong>都挨着边界</strong>。</p></li><li><p>左边挨着边界，<strong>或者</strong>右边挨着边界。</p></li></ol><p>你们自己去想一想，竖着也类似。</p><ul><li><strong>最优性剪枝</strong></li></ul><p>很好想，要是一个矩阵的面积小于 $k$，就不继续切了，直接返回。</p><ul><li><strong>等价性剪枝</strong></li></ul><p>zszz 矩阵是可以转的对吧？</p><p>拿到一个矩阵之后，我们可以尝试把它转一下：可以向左旋转 $0^{\circ},90^{\circ},180^{\circ},270^{\circ}$，每一种旋转都可以查看是否已求出结果，如果有，直接返回。</p><p>代码比较简单，但是思考的过程比较绕：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dp[x][y][up][down][left][right]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[x][y][up][down][left][right]; <span class="comment">//正常 </span></span><br><span class="line"><span class="keyword">if</span>(dp[x][y][down][up][right][left]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[x][y][down][up][right][left]; <span class="comment">//倒立 </span></span><br><span class="line"><span class="keyword">if</span>(dp[y][x][left][right][down][up]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[y][x][left][right][down][up]; <span class="comment">//往左转 </span></span><br><span class="line"><span class="keyword">if</span>(dp[y][x][right][left][up][down]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[y][x][right][left][up][down]; <span class="comment">//往右转 </span></span><br></pre></td></tr></table></figure><p>剪枝就这三个。虽然不多，但足以通过这道题。</p><p><del>最后再卡一下常。</del></p><hr><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a)&lt;(b)?(a):(b);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=(ll)<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line">ll dp[maxn][maxn][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">bool</span> up,<span class="keyword">bool</span> down,<span class="keyword">bool</span> left,<span class="keyword">bool</span> right)</span></span>&#123; <span class="comment">//bool 类型记录是否四个方向沿海 </span></span><br><span class="line">    <span class="keyword">if</span>(dp[x][y][up][down][left][right]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[x][y][up][down][left][right]; <span class="comment">//正常 </span></span><br><span class="line">    <span class="keyword">if</span>(dp[x][y][down][up][right][left]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[x][y][down][up][right][left]; <span class="comment">//倒立 </span></span><br><span class="line">    <span class="keyword">if</span>(dp[y][x][left][right][down][up]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[y][x][left][right][down][up]; <span class="comment">//往左转 </span></span><br><span class="line">    <span class="keyword">if</span>(dp[y][x][right][left][up][down]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[y][x][right][left][up][down]; <span class="comment">//往右转 </span></span><br><span class="line">    <span class="keyword">if</span>(!(up||down||left||right)) <span class="keyword">return</span> inf; <span class="comment">//不沿海 </span></span><br><span class="line">    ll ans1=<span class="built_in">pow</span>(x*y-k,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;y==<span class="number">1</span>||x*y&lt;k) <span class="keyword">return</span> dp[x][y][up][down][left][right]=ans1;</span><br><span class="line">    ll ans2=inf;</span><br><span class="line">    <span class="keyword">bool</span> u1,u2,d1,d2,l1,l2,r1,r2;</span><br><span class="line">    <span class="comment">//横着分开 </span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>&amp;&amp;(up&amp;&amp;down||left||right))&#123;</span><br><span class="line">        u1=up,u2=<span class="number">0</span>,d1=<span class="number">0</span>,d2=down,l1=l2=left,r1=r2=right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;x;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=<span class="built_in">dfs</span>(i,y,u1,d1,l1,r1)+<span class="built_in">dfs</span>(x-i,y,u2,d2,l2,r2);</span><br><span class="line">            ans2=<span class="built_in">min</span>(ans2,t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//竖着分开 </span></span><br><span class="line">    <span class="keyword">if</span>(y&gt;<span class="number">1</span>&amp;&amp;(left&amp;&amp;right||up||down))&#123;</span><br><span class="line">        u1=u2=up,d1=d2=down,l1=left,l2=<span class="number">0</span>,r1=<span class="number">0</span>,r2=right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;y;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=<span class="built_in">dfs</span>(x,i,u1,d1,l1,r1)+<span class="built_in">dfs</span>(x,y-i,u2,d2,l2,r2);</span><br><span class="line">            ans2=<span class="built_in">min</span>(ans2,t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x][y][up][down][left][right]=<span class="built_in">min</span>(ans1,ans2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;m,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">dfs</span>(m,n,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA 10004 Bicoloring 题解</title>
      <link href="/posts/Solution-UVA10004/"/>
      <url>/posts/Solution-UVA10004/</url>
      
        <content type="html"><![CDATA[<h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>给定多个连通无向图，判断这些图是不是二分图。</p><hr><h3 id="Step-1-建图"><a href="#Step-1-建图" class="headerlink" title="Step 1 建图"></a>Step 1 建图</h3><p>$2\le n\le 199$，邻接矩阵和邻接表大家都随意，根据自己的习惯来。我这里用的是 <code>vector</code> 实现邻接表。</p><p>另外，因为结点的编号是从 $0\sim n-1$，我不太习惯，于是在建图的时候就擅自每个结点的编号都 $+1$，把编号变成了 $1\sim n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">    map1[u+<span class="number">1</span>].<span class="built_in">push_back</span>(v+<span class="number">1</span>);</span><br><span class="line">    map1[v+<span class="number">1</span>].<span class="built_in">push_back</span>(u+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Step-2-发出开始染色的指令"><a href="#Step-2-发出开始染色的指令" class="headerlink" title="Step 2 发出开始染色的指令"></a>Step 2 发出开始染色的指令</h3><p><del>（没错我在凑字数）</del></p><p>Tips：以下内容都把结点编号当成 $1\sim n$。</p><p>因为是连通图，所以我们从 $1$ 结点开始染色。</p><p>我们定义一个 $a$ 数组，$a_i$ 代表 $i$ 结点的颜色：$0$ 代表还没有染色，$1$ 和 $2$ 代表两种不同的颜色。$1$ 号结点随便染一个颜色。</p><p>函数里可以传一个参数（遍历到的结点编号），也可以传两个参数（遍历到的结点编号和这个结点染的颜色）。我传的是两个参数。</p><p>主函数的执行异常简单，用三目运算符可以压缩为一行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>)?<span class="string">&quot;BICOLORABLE\n&quot;</span>:<span class="string">&quot;NOT BICOLORABLE\n&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="Step-3-染色"><a href="#Step-3-染色" class="headerlink" title="Step 3 染色"></a>Step 3 染色</h3><p>染色我们采用 dfs 来执行。其实 bfs 也可以实现，但是显然 dfs 码量比 bfs 少亿丶丶，而且 bfs 要开结构体队列，内存更大，所以我们就使用 dfs 了。</p><p>dfs 的思路和遍历图差不多。因为只有两个颜色，所以定了 $1$ 结点的颜色后，染色的方案是唯一的。我们先找到给定点的所有直接后继，然后一个一个看：</p><ul><li><p>如果它的某个直接后继与它要求染的颜色相同，这个图就不是二分图，直接 <code>return false</code> 即可。</p></li><li><p>如果它的某个直接后继和他要求染的颜色不同，那么直！接！跳！过！</p></li><li><p>如果它的某个直接后继没有染色，那么就给这个直接后继染上与它不同的颜色，接着继续遍历这个刚被染色的直接后继的直接后继。如果此直接后继后面染色不成功，说明这个图不是二分图（因为方案唯一！），直接 <code>return false</code>。</p></li></ul><p>如果遍历完了，就 <code>return true</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>;&#125; <span class="comment">//取相反颜色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">    a[x]=color;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;map1[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[map1[x][i]]==color) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[map1[x][i]]==<span class="built_in">f</span>(color)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(map1[x][i],<span class="built_in">f</span>(color))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Step-4-其它"><a href="#Step-4-其它" class="headerlink" title="Step 4 其它"></a>Step 4 其它</h3><p>一定要初始化！一定要初始化！一定要初始化！</p><p>要初始化的是图和记录染色的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(map1,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(map1)); <span class="comment">//vector可以直接这么初始化</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br></pre></td></tr></table></figure><p>另外这是邻接表的检查代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;map1[i].<span class="built_in">size</span>();j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,map1[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>最后双手献上 AC 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; map1[<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,u,v,a[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">    a[x]=color;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;map1[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[map1[x][i]]==color) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[map1[x][i]]==<span class="built_in">f</span>(color)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(map1[x][i],<span class="built_in">f</span>(color))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">10000000000000000000ull</span>&gt;<span class="number">9999999999999999999ull</span>)&#123; <span class="comment">//没问题是吧</span></span><br><span class="line">        <span class="built_in">memset</span>(map1,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(map1));</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            map1[u+<span class="number">1</span>].<span class="built_in">push_back</span>(v+<span class="number">1</span>);</span><br><span class="line">            map1[v+<span class="number">1</span>].<span class="built_in">push_back</span>(u+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">printf(&quot;%d: &quot;,i);</span></span><br><span class="line"><span class="comment">for(int j=0;j&lt;map1[i].size();j++) printf(&quot;%d &quot;,map1[i][j]);</span></span><br><span class="line"><span class="comment">printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>)?<span class="string">&quot;BICOLORABLE.\n&quot;</span>:<span class="string">&quot;NOT BICOLORABLE.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交记录：<a href="https://www.luogu.com.cn/record/55966469">Link</a>（没错我 UVA 登上了）</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>于是他们玄学的证明开始了</title>
      <link href="/posts/%E4%BA%8E%E6%98%AF%E4%BB%96%E4%BB%AC%E7%8E%84%E5%AD%A6%E7%9A%84%E8%AF%81%E6%98%8E%E5%BC%80%E5%A7%8B%E4%BA%86/"/>
      <url>/posts/%E4%BA%8E%E6%98%AF%E4%BB%96%E4%BB%AC%E7%8E%84%E5%AD%A6%E7%9A%84%E8%AF%81%E6%98%8E%E5%BC%80%E5%A7%8B%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>今天上课讨论的问题。</p><p>求证：任意一个位数为偶数的回文数，都可以被 $11$ 整除。</p><p>PS：此篇仅是笔者对于证明过程的理解，并不是标准的数学证明。</p><p><del>其实是因为笔者太太太菜了所以才需要这一篇文章来帮助理解的 qwq，相信这个简单的问题各位大佬们都没问题</del></p><hr><p>这个证明分为两个部分。</p><h2 id="Prat1"><a href="#Prat1" class="headerlink" title="Prat1"></a>Prat1</h2><p>首先两位数的回文数一定是 $11$ 的倍数。为什么呢？<del>观察可得。</del></p><p>我们知道两位的回文数一定是形如这样的：$aa$，$aa \div 11=a$。由于 $a$ 一定是一个大于 $0$ 小于 $10$ 的整数，所以可以证明两位数的回文数是可以被 $11$ 整除的。</p><p>那么，四位的回文数就可以被这么表示：</p><p>$\overline{abba}$</p><p>然后我们：</p><script type="math/tex; mode=display">\begin{equation*} \label{eqn2}  \begin{split}\overline{abba}&=1000a+100b+10b+a\\&=1001a+110b\\&=1001a+11\times 10b  \end{split}\end{equation*}</script><p>因为 $11\;|\;11\times 10b$，所以我们只需证明 $11\;|\;1001a$ 即可，也就是证明 $11\;|\;1001$。</p><p>再推广，假设我们已经证明了 $4$ 位的回文数是 $11$ 的倍数。</p><p>于是 $6$ 位的回文数就变成了这样：</p><script type="math/tex; mode=display">\begin{equation*} \label{eqn}  \begin{split}\overline{abccba}&=100000a+10000b+1000c+100c+10b+a\\&=100001a+10\times\overline{bccb}  \end{split}\end{equation*}</script><p>于是我们只需要证明 $100001\;|\;11$。</p><p>…………</p><p>这么推下去的话，我们会发现，这个过程本来就是一个递归的过程，每一次都把两端的数字去掉后，可以从两位的回文串推回来证明这个去掉两段后的回文数能被 $11$ 整除。现在我们只需要证明一个问题，那就是：</p><p>求证：$\begin{matrix} \underbrace{ 100\cdots 001 } \\ 2n+2 \end{matrix}\;|\;11$，其中 $n$ 为正整数。</p><hr><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><h3 id="法一（from-ywy-orz）"><a href="#法一（from-ywy-orz）" class="headerlink" title="法一（from ywy orz）"></a>法一（from ywy orz）</h3><p>从上面的推导中我们可以发现中间的 $0$ 的个数一定是偶数。先列竖式。</p><script type="math/tex; mode=display">\qquad 99\cdots</script><script type="math/tex; mode=display">\ \ \,\qquad\quad\ \_\_\_\_\_\_\_\_\_\_\_\_\_\_</script><script type="math/tex; mode=display">\ \ \,11\ / \quad 100\cdots 001</script><script type="math/tex; mode=display">99</script><script type="math/tex; mode=display">\ \ \,\qquad\quad\ \_\_\_\_\_\_\_\_\_\_\_\_\_\_</script><script type="math/tex; mode=display">\ \ \,\qquad 100</script><script type="math/tex; mode=display">\ \ \,\quad\ \, 99</script><script type="math/tex; mode=display">\ \ \,\qquad\quad\ \_\_\_\_\_\_\_\_\_\_\_\_\_\_</script><script type="math/tex; mode=display">\ \ \,\qquad\quad 100</script><script type="math/tex; mode=display">\ \ \,\qquad\quad \cdots\cdots</script><p>（$\LaTeX$ 除法竖式贼不好打……建议还是在自己的本子上列……）</p><p>对齐不难发现：每进行一次减法之后，被除数就会少两个 $0$，这样，如果中间的 $0$ 的个数是偶数个，那么最后这些 $0$ 会被全部消失，剩下两个 $1$ 组成 $11$，于是它就可以被 $11$ 整除了。</p><h3 id="法二（自己想出来的）"><a href="#法二（自己想出来的）" class="headerlink" title="法二（自己想出来的）"></a>法二（自己想出来的）</h3><script type="math/tex; mode=display">\begin{equation*} \label{eqn4}  \begin{split}100 \cdots 001 &= 10^{2n+1}+10^{2n}+\ldots +10^1+10^0-\big(10^{2n}+10^{2n-1}+\ldots +10^2+10^1\big)\\&=(10^{2n+1}+10^{2n})+\ldots +(10^1+10^0)-\big(10^{2n}+10^{2n-1}+\ldots +10^2+10^1\big)\\&=11 \times 10^{2n} + 11\times 10^{2n-2} + \ldots 11\times 10^0-10\times \big(11\times 10^{2n-2} + 11\times 10^{2n-4} + \ldots 11\times 10^0\big)\\&=11 \times \Big( 10^{2n} + 10^{2n-2}+ \ldots + 10^2 + 10^0- 10\times 11\times \big( 10^{2n-2} + 10^{2n-4} + \ldots 10^0 \big) \Big)  \end{split} \end{equation*}</script><hr><p>就这样吧。</p>]]></content>
      
      
      <categories>
          
          <category> 证明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2470 压缩 题解</title>
      <link href="/posts/Solution-P2470/"/>
      <url>/posts/Solution-P2470/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://www.luogu.com.cn/problem/P2470">题目传送门</a></p><p><strong>正解：区间/线性 dp</strong>（本篇题解介绍线性做法）</p><p>人生第一道紫题！</p><p>也是 7.17 考试看自闭了就没做的 T4，结果没想到是紫，虽然是一道水紫呢……</p><p><del>考试的 T5 是跳房子，蓝题 qwq。要不是前三题比较简单 + 骗分好骗（指靠直接输出字符串长度骗了十分）就真的自闭了。</del></p><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们观察到一个字符串压缩的程度和 “M”，“R”的个数是有关的，尤其是开始一段压缩区间的“M”，非常的重要，因为它的位置决定了压缩串的长度，也直接决定了最后字符串的长度。非常好的条件，可以利用。</p><p>所以，定义 $dp$ 数组状态为：</p><ul><li>$dp_{i,j}$ 代表前 $i$ 个字符，上一个“M”的位置在第 $j$ 个字符<strong>前</strong>所能达到的最短长度。</li></ul><p>$dp$ 数组的初始值：</p><p>当只有一个字符时，“M”只有可能在第一个字符前，而且长度为 $1$。所以，$dp_{1,1}=1$。</p><p>于是我们可以分析出以下三种情况。</p><ol><li><p>直接在前面 $i-1$ 个字符的情况下，加上一个字符。</p></li><li><p>添加压缩的字符串。</p></li><li><p>新建一个压缩字符串部分的开头。</p></li></ol><h3 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h3><p>如果只是直接加一个，这样 $j$ 的值是不会变的，因为我们没有考虑“M”和“R”的情况。这样得到的答案就是 $dp_{i-1,j}+1$。</p><h3 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h3><p>我们知道，当且仅当某<strong>两</strong>个字符子串<strong>完全相同</strong>时，我们才能对这两个字符串进行一次压缩。</p><p>至于这个压缩的地方加在哪里呢？因为最近的“M”的位置已经确定，所以这个“M”（坐标为 $j-1$ 和 $j$）<strong>之前</strong>（并不包括第 $j$ 个字符）的所有字符串情况已经确定，无法改动（因为 dp 不能有后效性）。</p><p>所以我们确定被复制了一遍的区域在 $[j,i]$，从中间切开这份字符串，看看两边是不是相等的，如果是就可以考虑这种情况。注意这段区域的的长度为奇数是是一定不可能的。</p><p>判断字符串是否相等的函数很简单，就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> mid,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((r-l+<span class="number">1</span>)&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果长度是奇数直接不可能</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mid-l;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l+i]!=a[mid+<span class="number">1</span>+i]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//出现不一样的字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//全部都一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后考虑如何状态转移，很明显，这样的长度就是 $j$ 之前的那些字符的最短长度 + 压缩后 $[j,i]$ 段的长度 + $1$（那个“R”字符）。转化为<strong>情况二的</strong>动态转移方程即为：</p><script type="math/tex; mode=display">dp_{i,j}=\min_{j=1}^{i-1}\{dp_{\lfloor \frac{i+j}{2} \rfloor,j}\}+1</script><p>其中 $\lfloor \dfrac{i+j}{2} \rfloor$ 表示的是被<strong>切成两段</strong>的那一部分的<strong>前面那个字符串</strong>的最后一个字符串的下标（好绕啊）。</p><h3 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h3><p>因为要新建一个“M”，意思就是再开一个可重复的字符串并将新开的“M”的下标作为 $dp$ 数组的第二个值。因为我们枚举到 $i$ 了，所以最方便的就是把这个“M”加在 $i-1$ 和 $i$ 之间，这样每一次循环都能考虑到一层，就全部考虑到了。</p><p>那转移方程是什么呢？我们继续观察，现在我们考虑的范围就已经缩小到了 $1$ 到现在添加的“M”（坐标为 $i-1$ 和 $i$ 之间）中间的这一段。很明显 $i$ 已经在这个“M”后面了，此时我们不需要考虑，所以只需考虑 $[1,i-1]$ 压缩后的最小长度。</p><p>那第二个下标呢？因为考虑前面的时候并没有考虑添加的“M”（这是两个情况），所以依然是枚举 $j$。</p><p>对了，这个值还要 $+2$，一个是添加的“M”字符，另一个是下标为 $i$ 的字符。（是的！这个也要算进去！因为此字符是在添加的“M”后面的，前面的式子并没有考虑到）。</p><p>所以，情况三的转移方程是：</p><script type="math/tex; mode=display">dp_{i,i}=\min_{j=1}^{i-1}\{dp_{i-1,j}+2\}</script><p>将三个合并一下，不过记得，要保存前面情况的最优解。除了上述的特殊初始值外，因为求的是最小值，所以 $dp$ 初始值设为 $\text{INF}$（极大值）。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span> <span class="comment">// INT_MAX的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a)&lt;(b)?(a):(b)</span></span><br><span class="line"><span class="keyword">int</span> n,dp[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> mid,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((r-l+<span class="number">1</span>)&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mid-l;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l+i]!=a[mid+<span class="number">1</span>+i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;compress.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;compress.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">127</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(j,(j+i<span class="number">-1</span>)/<span class="number">2</span>,i)) dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[(i+j<span class="number">-1</span>)/<span class="number">2</span>][j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++) dp[i][i]=<span class="built_in">min</span>(dp[i][i],dp[i<span class="number">-1</span>][j]+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">min</span>(ans,dp[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>考试竟然有个 dalao （zdj 大佬！）写出来了啊……%%%。</p><p>虽然听着不难但是思路很难想呢 qwq。</p><p>最后请随手点个赞吧，<del>毕竟赠人玫瑰手有余香嘛</del>。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.7.17 考试总结</title>
      <link href="/posts/2021-7-17-%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/posts/2021-7-17-%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>得分：$100+90+100+10+0=300$</p><p>排名 $\text{rk9}$</p><p>只能说把我这个月的 $rp$ 都用光了……</p><p>（话说要是我 T2 不是因为没特判丢了 $10$ 分我就可以 $\text{rk6}$ 了 qwq</p><h2 id="考试过程"><a href="#考试过程" class="headerlink" title="考试过程"></a>考试过程</h2><p>$00:00$</p><p>考试开始电脑出毛病了，收不到试卷（</p><p>稳了下心态，告诉了 mjl，然后他用他的 U 盘给我拷到电脑上了……</p><p>$00:05$</p><p>开始看试卷。看到 T1 先推了一下发现了规律，但是看了一下数据以为循环会超时（最多就 $60^+$次循环怎么会超呢<del>我又被降智了真的是</del>），然后跑过去看 T2。</p><p>$00:10$</p><p>看到 T2 挺适合记忆化暴搜的就写了，然后过了样例之后手造了一个极限数据看时间也没超限就跑了（然鹅并没有加特判 qwq。</p><p>$00:25$</p><p>回头看 T1，心想着就先打一个 <code>log2</code> 试试有没有这个函数吧……（顺便加了个 <code>cmath</code>）结果发现真的有？太好了，然后测了一下样例发现没过，经过手动分析<del>和手动打表</del>发现要加向上取整（虽然不知道为啥）然后把 T1 写出来了。</p><p>$00:35$</p><p>看了一下后面 $3$ 道，等等，T5 我好像见过，是区间 dp……但是想不起来了，再加上我记得它是道蓝题（应该是吧），然后 T4 又看得我自闭，就去切 T3 了（本来看到树不想做的……）</p><p>$00:40$</p><p>惊奇发现需要建树（其实并不需要），然而我又不会根据两个遍历的序列建树……考前问了 mjl 的，他也给我讲了，可是我没理解。</p><p>没办法只能硬着头皮上了……</p><p>$01:10$</p><p>程序弄好了，然后，递归层数超限了。</p><p>$01:30$</p><p>bug 没改过来，然后突然发现建树要用 bfs。当时<del>脑子 what 一心只想建树没想到 bfs 直接输出就行了 qwq</del> 心灰意冷把 dfs 全删了之后开始写 bfs……</p><p>$01:45$</p><p><del>rnm</del> bfs 还是错的！（核心代码没改……）</p><p>$02:00$</p><p>草……原来我分析的时候把中序和后序搞混了吗……改过来就好了。</p><p>$02:30$</p><p>分析完了怎么把孩子求出来，写好了结果发现没用，又不想删掉，就注释掉了（喜提 $\text{3k}$ 代码……）。</p><p>$02:45$</p><p>添加了层数的条件并修好了几个小 bug，过了样例。</p><p>$02:50$ </p><p>自己造了几组数据，都没有问题，准备去看后面<del>骗分啦</del>。</p><p>$03:00$</p><p>草草草没多少时间了！赶紧看了看 T4，没思路，于是开始写 T5 $O(n^3)$ 暴力……并且过了两个样例。</p><p>$03:20$ </p><p>开始养老，直至结束。</p><hr><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="http://222.180.160.110:1024/contest/1794/problem/1">T1</a></h3><p>想到思路应该是不难的，但是要证明……emm……</p><p>首先<del>观察可得</del>每个小白鼠都有死和活两种情况，所以，$k$ 只小白鼠可以找出最多 $2^k$ 瓶酒中的毒药。</p><p>进一步，有 $n$ 瓶毒酒，当且仅当 $k$ 满足 $2^{k-1}&lt;n\le 2^k$ 时，$k$ 为 $n$ 的正确答案。</p><p>那怎么证明呢？用二进制。</p><p>假如说有 $6$ 瓶酒，我们把它们编号为 $0,1,2,3,4,5$。</p><p>二进制：</p><script type="math/tex; mode=display">0\ \ \ \ \ 000</script><script type="math/tex; mode=display">1\ \ \ \ \ 001</script><script type="math/tex; mode=display">2\ \ \ \ \ 010</script><script type="math/tex; mode=display">3\ \ \ \ \ 011</script><script type="math/tex; mode=display">4\ \ \ \ \ 100</script><script type="math/tex; mode=display">5\ \ \ \ \ 101</script><p>酒的编号的二进制的 $1/0$ 其实代表了这一位代表的老鼠（最高位代表第一只老鼠，后面以此类推）喝/不喝这瓶酒。</p><p>那么就推出了方案：</p><p>第一只喝 $4,5$</p><p>第二只喝 $2,3$</p><p>第三只喝 $1,3,5$</p><p>所以也可以看出有些情况有多种解是因为 $0\sim 2^k-1$ 中选 $n$ 个不同的数字可以任意选，可能有多种选法。</p><p>关于代码的实现，异常简单，异常暴力，可以用 <code>cmath</code> 头文件里的 <code>log2</code> 函数。记得向上取整和开 <code>long long</code>。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll bottle,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;wine.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;wine.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;bottle);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(ll)<span class="built_in">ceil</span>(<span class="built_in">log2</span>(bottle)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="http://222.180.160.110:1024/contest/1794/problem/2">T2</a></h3><p>记忆化暴搜。<strong>记得特判 $-1$。</strong></p><p>$dp_{i,j}$ 代表前 $i$ 首曲子弹完音量为 $j$ 的情况是否存在，如果存在直接存 $j$ 更加方便。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b)</span></span><br><span class="line"><span class="keyword">int</span> begin,MAX,n,c[<span class="number">55</span>],dp[<span class="number">55</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==n+<span class="number">1</span>) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">if</span>(dp[t][v]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[t][v];</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(v-c[t]&gt;=<span class="number">0</span>) a=<span class="built_in">dfs</span>(t+<span class="number">1</span>,v-c[t]);</span><br><span class="line">    <span class="keyword">if</span>(v+c[t]&lt;=MAX) b=<span class="built_in">dfs</span>(t+<span class="number">1</span>,v+c[t]);</span><br><span class="line">    <span class="keyword">return</span> dp[t][v]=<span class="built_in">max</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;volume.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;volume.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;begin,&amp;MAX);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">dfs</span>(<span class="number">1</span>,begin);</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="http://222.180.160.110:1024/contest/1794/problem/3">T3</a></h3><p>bfs 每层遍历，需要记录层数。</p><p>那如何根据后序遍历和中序遍历来确定一棵树呢？</p><p>首先我们知道后序遍历是按照“左——右——根”的顺序遍历的，所以每一个部分的根节点都必然在那个区域的最后。在中序遍历里找到这个根节点，把左右两边分为左子树和右子树，然后再在后序遍历里面找到这两个子树的节点所在的区域（它们一定是连续的）。然后再继续求解两个子树……（注意因为是 bfs 所以这一层的会先求解完再求解子树）。</p><p>我打得很麻烦，相当于把树建出来了，删掉注释部分就差不多可以了 qwq。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data,l,r,f;</span><br><span class="line">&#125;tree[<span class="number">305</span>]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> L,R,root,midr,f;</span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">305</span>],l[<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_tree</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    t1.root=a,t1.L=b,t1.R=c,t1.midr=d,t1.f=e;</span><br><span class="line">    q.<span class="built_in">push</span>(t1);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        t1=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l[t1.root]==m[i])&#123;</span><br><span class="line">                mid=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存结点</span></span><br><span class="line">        tree[++t].data=l[t1.root];</span><br><span class="line">        tree[t].f=t1.f;</span><br><span class="line">        <span class="keyword">int</span> long_r=t1.midr-mid;</span><br><span class="line">        <span class="comment">//左子树入队</span></span><br><span class="line">        <span class="keyword">if</span>(t1.R-long_r-t1.L)&#123;</span><br><span class="line">            t2.L=t1.L,t2.R=t1.R-long_r<span class="number">-1</span>,t2.root=t1.R-long_r<span class="number">-1</span>,t2.midr=mid<span class="number">-1</span>,t2.f=t1.f+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//tree[t].l=l[t2.R];</span></span><br><span class="line">            q.<span class="built_in">push</span>(t2);</span><br><span class="line">        &#125;<span class="keyword">else</span> tree[t].l=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//右子树入队 </span></span><br><span class="line">        <span class="keyword">if</span>(long_r)&#123;</span><br><span class="line">            t2.L=t1.root-long_r,t2.R=t1.root<span class="number">-1</span>,t2.root=t1.root<span class="number">-1</span>,t2.midr=t1.midr,t2.f=t1.f+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//tree[t].r=l[t2.R];</span></span><br><span class="line">            q.<span class="built_in">push</span>(t2);</span><br><span class="line">        &#125;<span class="keyword">else</span> tree[t].r=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;z.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;z.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;l[i]);</span><br><span class="line">    <span class="built_in">find_tree</span>(n,<span class="number">1</span>,n,n,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//根据 l 和 r 的 data 值对应其下标 </span></span><br><span class="line">    <span class="comment">/*for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//左孩子</span></span><br><span class="line"><span class="comment">if(tree[i].l!=-1)&#123;</span></span><br><span class="line"><span class="comment">int s=0;</span></span><br><span class="line"><span class="comment">for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line"><span class="comment">if(tree[i].l==tree[j].data)&#123;</span></span><br><span class="line"><span class="comment">s=j;</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">tree[i].l=s;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//右孩子 </span></span><br><span class="line"><span class="comment">if(tree[i].r!=-1)&#123;</span></span><br><span class="line"><span class="comment">int s=0;</span></span><br><span class="line"><span class="comment">for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line"><span class="comment">if(tree[i].r==tree[j].data)&#123;</span></span><br><span class="line"><span class="comment">s=j;</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">tree[i].r=s;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">    <span class="comment">//test </span></span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=n;i++) printf(&quot;%d %d %d %d %d\n&quot;,i,tree[i].data,tree[i].l,tree[i].r,tree[i].f);</span></span><br><span class="line">    <span class="comment">//输出 </span></span><br><span class="line">    <span class="keyword">int</span> maxf=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) maxf=<span class="built_in">max</span>(maxf,tree[i].f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tree[<span class="number">1</span>].data);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">2</span>,r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxf;i++)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; print;</span><br><span class="line">        l=r+<span class="number">1</span>,r=l;</span><br><span class="line">        <span class="keyword">while</span>(tree[r].f==i) r++;</span><br><span class="line">        r--;</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d %d\n&quot;,i,l,r);</span></span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123; <span class="comment">// &lt;-</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=r;j&gt;=l;j--) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tree[j].data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// -&gt;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tree[j].data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">4 2 5 1 6 3 7</span></span><br><span class="line"><span class="comment">4 5 2 6 7 3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a><a href="http://222.180.160.110:1024/contest/1794/problem/4">T4</a></h3><p><a href="/posts/Solution-P2470/">Click here!</a></p><hr><h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a><a href="http://222.180.160.110:1024/contest/1794/problem/5">T5</a></h3><p>二分 + $\text{check}$ 函数。</p><p>二分需要的金币数量，这个没啥好说的。</p><p>$\text{check}$ 函数的话，我没用单调队列的优化，而是 dp。我的想法是用 $dp_i$ 代表跳到第 $i$ 个格子能获得的最大数字之和。于是用两层循环，第一层 $i$ 从 $1$ 到 $n$，代表走到第几个格子了，第二层 $j$ 把走过的都扫一遍，然后求最大值：<code>dp[i]=max(dp[i],dp[j]+a[i]位置的数字大小)</code>。</p><p>注意如果目前枚举到的地方比较靠近边缘，有可能是没有办法跳到的，所以可以加一个关于是否能跳到的优化，如果跳不到可以直接 <code>break</code> 掉第二层循环。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=(<span class="keyword">int</span>)<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,d,sum,l,r;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">square</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,s;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="comment">//check函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">128</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    l=k-mid;</span><br><span class="line">    r=k+mid;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].x-a[j].x&gt;r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i].x-a[j].x&lt;l) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+a[i].s);</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;=d) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分函数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) <span class="keyword">return</span> <span class="built_in">f</span>(l,mid);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">f</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">freopen</span>(<span class="string">&quot;jump.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"> <span class="built_in">freopen</span>(<span class="string">&quot;jump.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;n,&amp;k,&amp;d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;a[i].x,&amp;a[i].s);</span><br><span class="line">        sum+=(a[i].s&gt;<span class="number">0ll</span>)?a[i].s:<span class="number">0ll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%lld %lld\n&quot;,sum,d);</span></span><br><span class="line">    <span class="keyword">if</span>(sum&lt;d)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">f</span>(<span class="number">0ll</span>,<span class="number">1000ll</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉还行？就是 T2 没特判，T5 暴力没骗到分……</p><p>去学 whk 了，拜拜ヾ(•ω•`)o~</p>]]></content>
      
      
      <categories>
          
          <category> 考试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF559B Equivalent Strings 题解</title>
      <link href="/posts/Solution-CF559B/"/>
      <url>/posts/Solution-CF559B/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://www.luogu.com.cn/problem/CF559B">题目传送门</a></p><p><strong>正解：模拟，递归。</strong></p><p>考试的 T4，还是想复杂了 qwq。</p><p><strong>这题不要用 STL，会被卡常数……</strong></p><span id="more"></span><hr><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p><del>翻译够简了。</del></p><p>对了给一下样例解释的翻译：</p><p>第一个样例的第一组测试数据中，对于 $a=aaba$ 和 $b=abaa$，可以分成 $a1=aa,a2=ba,b1=ab,b2=aa$；其中 $a1$ 和 $b2$ 全等。对于 $a=ba$ 和 $b=ab$，可以分成 $a1=b,a2=a,b1=a,b2=b$；其中 $a1$ 和 $b2$ 全等，$a2$ 和 $b1$ 全等。所以 $aaba$ 和 $abaa$ 相似。</p><p>第一个样例的第二组测试数据中，$aabb$ 和 $abab$ 不满足相似。</p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>鉴于数据的特殊性 <del>（简称水）</del>，我们可以直接按照题意递归即可。</p><p>因为输入的是两个字符串，而每次递归都需要两个新的字符串，而这两个新的字符串都是在以前的字符串上<strong>截取一段</strong>形成的。所以，我们根本不需要传字符串，只需要传在输入的字符串中<strong>截取的部分开始、结束的下标</strong>即可。</p><p>当然，因为每次判断都要传两个字符串，所以需要有两对参数，这里，$l1,r1$ 代表第一个字符串（从输入的第一个字符串中截取），$l2,r2$ 代表第二个字符串（从输入的第二个字符串中截取）。</p><p>首先，两个不同的判断条件打成两个函数 $\operatorname{f1}$ 和 $\operatorname{f2}$，分别判断奇数和偶数字符串长度的相似判定。</p><p>$\operatorname{f1}$ 的实现是很简单的，只需要逐字判断是否相等即可。</p><p>不过需要<strong>注意细节</strong>，在计算字符串的长度时，<strong>不需要</strong> $+1$。具体原因：本来计算长度的时候是要 $+1$ 的，但是因为 $l1$ 和 $l2$ 已经提供了字符串开始的地方，所以我们在这两个数的基准上<strong>加的数</strong>就是从 $0\sim r1-l1$ 共 $r1-l1+1$ 个数字，就不需要 $+1$ 了。</p><p>具体函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=r1-l1; <span class="comment">//计算需要枚举判断的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=t;i++) <span class="keyword">if</span>(a[l1+i]!=b[l2+i]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//不一样直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//所有的都一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着分析较难的递归函数 $\operatorname{f2}$。这个函数也是我们在主函数中调用的函数。</p><p>首先看传过来的字符串长度是奇数还是偶数。如果是奇数，直接返回 $\operatorname{f1}$ 的判断就可以了。</p><p>如果是偶数，那么就需要判断一分为二之后是否相似。定义两个变量 $mid1,mid2$ 分别表示两个字符串中间的下标，也就是分开的地方（注意这两个变量表示的是分开后前面那个字符串的最后一个元素），接着根据题意模拟即可，因为有两组配对，所以两组都要判断。注意先 <code>&amp;&amp;</code> 再 <code>||</code>。</p><p>这个地方容易打错，记得好好检查。</p><p>（对了提醒大家一定要记得<strong>不要把函数名给打掉了</strong>，我就是这么错的 qwq。）</p><p>$\operatorname{f2}$ 的代码如下（别在意多余的空格，因为放一个框框里怕是有点不美观，我格式化了一下代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((r1 - l1 + <span class="number">1</span>) &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f1</span>(l1, r1, l2, r2);</span><br><span class="line">    <span class="keyword">int</span> mid1 = (l1 + r1) &gt;&gt; <span class="number">1</span>, mid2 = (l2 + r2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f2</span>(l1, mid1, l2, mid2) &amp;&amp; <span class="built_in">f2</span>(mid1 + <span class="number">1</span>, r1, mid2 + <span class="number">1</span>, r2) ||</span><br><span class="line">           <span class="built_in">f2</span>(l1, mid1, mid2 + <span class="number">1</span>, r2) &amp;&amp; <span class="built_in">f2</span>(mid1 + <span class="number">1</span>, r1, l2, mid2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后写好主函数，就可以把这道题切了 qwq。</p><hr><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">200005</span>], b[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = r1 - l1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[l1 + i] != b[l2 + i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((r1 - l1 + <span class="number">1</span>) &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f1</span>(l1, r1, l2, r2);</span><br><span class="line">    <span class="keyword">int</span> mid1 = (l1 + r1) &gt;&gt; <span class="number">1</span>, mid2 = (l2 + r2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f2</span>(l1, mid1, l2, mid2) &amp;&amp; <span class="built_in">f2</span>(mid1 + <span class="number">1</span>, r1, mid2 + <span class="number">1</span>, r2) ||</span><br><span class="line">           <span class="built_in">f2</span>(l1, mid1, mid2 + <span class="number">1</span>, r2) &amp;&amp; <span class="built_in">f2</span>(mid1 + <span class="number">1</span>, r1, l2, mid2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    len = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f2</span>(<span class="number">1</span>, len, <span class="number">1</span>, len))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>题目不难，细节有点多。<strong>大家打代码一定一定要注意细节啊 awa。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递推，递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AT4828 [ABC152D] Handstand 2 题解</title>
      <link href="/posts/Solution-AT4828/"/>
      <url>/posts/Solution-AT4828/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://www.luogu.com.cn/problem/AT4828">题目链接</a></p><p>来一点不一样的方法。</p><p><strong>正解：动态规划 / <del>打表</del>数据暴力分析</strong></p><p>考试半小时想出方法，最后输在了两个细节上。</p><p>写一篇题解以此纪念。</p><span id="more"></span><hr><h3 id="打表暴力程序"><a href="#打表暴力程序" class="headerlink" title="打表暴力程序"></a>打表暴力程序</h3><p>最开始打的暴力对拍，没想到最后只能交这个上去了。</p><p>思路：两层循环枚举两个数，判断是否符合要求。</p><h3 id="Code（第一种）"><a href="#Code（第一种）" class="headerlink" title="Code（第一种）"></a>Code（第一种）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=x%<span class="number">10</span>,d=y%<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">10</span>) x/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(y&gt;=<span class="number">10</span>) y/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==d&amp;&amp;y==c) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;out1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!i%<span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i,j)) &#123;<span class="comment">//printf(&quot;%d %d\n&quot;,i,j);</span></span><br><span class="line">            ans++;&#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>这个方法很简单啊！！！</p><p>$dp_{i,j}$ 代表以 $i$ 开头以 $j$ 结尾的不超过 $n$ 的数的个数。</p><p>求一个数字首位的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">one</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(m&gt;=<span class="number">10</span>) m/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为要保证 $1\le m\le 9$，所以 $dp$ 开 $10\times 10$ 即可。</p><p>最后 $9\times 9$ 的循环枚举满足题意的数量。</p><p>因为要求两个数的开头结尾互相对应，所以若一个数以 $i$ 开头，以 $j$ 结尾，那么它就有 $dp_{j,i}$ 个数对。而这样的数一共有 $dp_{i,j}$ 个，根据小学学的可能性总数需要用乘法，可以看出前面是 $i\ldots j$ 数字的数对个数为 $dp_{i,j}\times dp_{j,i}$。答案累加就可以了。</p><h3 id="Code（第二种）"><a href="#Code（第二种）" class="headerlink" title="Code（第二种）"></a>Code（第二种）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,ans,dp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">one</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(m&gt;=<span class="number">10</span>) m/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[<span class="built_in">one</span>(i)][i%<span class="number">10</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line">            ans+=dp[i][j]*dp[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>考试想到的方法。</p><p>方法与 <a href="https://gugeblog.blog.luogu.org/at4828-abc152d-handstand-2-ti-xie">@CQBZJJH</a> 相同，但是我们俩都是考试的时候想出来的，我只是调代码比他慢啊 awa！！1 <del>这个不要 face 的人竟然说版权是他的，IEE。</del></p><p>我来说说这个思路是怎么出来的。</p><p>首先第一层循环肯定是枚举 $1\sim n$，看每个数字有多少个数字对。</p><p>用第一个程序打表 $2020$，可以得到如下的输出：<a href="https://www.luogu.com.cn/paste/pcgevhwj">Link</a></p><p><del>等等好像复制不完诶，不过没关系这点够了。</del></p><p>然后我们先通览全篇，然后仔细观察一下 $1\sim 9$ 的数字对。</p><p>发现如下规律：</p><p>设 $x$ 为 $n$ 的首位，$k$ 为 $n$ 的位数。</p><p>分析：对于每个数 $i$，因为它的数字对的那个搭档的首尾两个数字已经定下来了，所以，中间夹着的数字就可以分析出：中间没有数字的情况，中间有一个数字的情况，中间有两个数字的情况……也就是说，如果没有 $n$ 的限制，那么这个数有的数字对的数量计算公式就是：$10^0+10^1+10^2+\ldots$。</p><p>但是这道题当中是有 $n$ 的限制的（<del>不然这道题还有什么意义呢</del>），所以就要分析下列三种情况讨论：</p><p><strong>1. 若 $i \bmod 10&lt;x$，即 $i$ 的搭档数首位小于 $x$。</strong></p><p>非常简单的情况，这个时候，中间数字数量可以从 $0$ 取到 $k-2$，而且不管怎么取它的搭档数都不会超过 $n$ 的，因为它的首位小于 $x$，而且位数不会大于 $k$。</p><p>所以直接：</p><p>$ans←ans+10^{k-2}$</p><p>即可。</p><p><strong>2. 若 $i \bmod 10&gt;x$，即 $i$ 的搭档数首位大于 $x$。</strong></p><p>也是非常简单的情况，这个时候，只要此搭档数的位数等于 $k$，就一定会大于 $n$，此点<del>显然易证</del>，就不需要我多哔哔了吧？所以中间掐头去尾的数字的数量可以从 $0$ 取到 $k-3$，所以可以：</p><p>$ans←ans+10^{k-3}$。</p><p><strong>3. 若 $i \bmod 10=x$，即 $i$ 的搭档数首位与 $x$ 相等。</strong></p><p>这个情况就比较复杂了。<a href="https://gugeblog.blog.luogu.org/at4828-abc152d-handstand-2-ti-xie">@CQBZJJH</a> 奆佬用了很巧妙的方法推出了简洁的式子，但是我太蒟蒻了，不会那些<del>花里胡哨的东西</del>，所以就有了一个朴素的第二层循环 qwq。</p><p>我的想法就是这样的：既然你这个数无法确定位数为 $k$ 的时候到底是否大于 $n$，那么你就一点一点枚举呗！定义第二层循环 $j$ 为中间的数字（$j÷10$ 一定是一个 $k-2$ 位数，位数不够前面补 $0$），其中 $j$ 一定是 $10$ 的倍数（因为要保留最后一位，从倒数第二位开始改），每次枚举时这个 $i$ 的搭档数就是：</p><p>$x\times 10^{k-1}+j+\operatorname{one}(i)$</p><p>其中 $\operatorname{one}(i)$ 是指求 $i$ 的首位的函数（前面有）。</p><p>可以看出，只要这个数小于 $n$，那循环就可以继续下去；但是如果这个数超出了 $n$，因为 $j$ 只会越来越大，不可能后面还有满足的，直接退出循环即可。</p><p>最后说一下 $j$ 的枚举范围：$0\sim 10^{k-1}-1$（不能加到首位上去）。</p><hr><h3 id="一个小优化"><a href="#一个小优化" class="headerlink" title="一个小优化"></a>一个小优化</h3><p>适用于第三种方法，因为这个方法时间复杂度比较大，所以想到了这个。</p><p>试想一下：如果一个数的首位是相同的，那么它的数对的数量就相当于它末尾这个一位数的数对数量。所以，$1\sim 9$ 可以与上面分开枚举，枚举 $i$ 时把答案加在 $b_i$ 里面，最后 $ans←ans+b_i$ 即可。</p><p>（<strong>注意一定要考虑和自己组成数对即一位数的情况，所以最后 $b_i$ 需要 $+1$！！！</strong> 考试就栽在这个细节上了。）</p><p>其实想到了这个之后，就离想到上述的动态规划简单做法不远了……考试没想到有点可惜 qaq。</p><h3 id="Code-（第三种）"><a href="#Code-（第三种）" class="headerlink" title="Code （第三种）"></a>Code （第三种）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k=<span class="number">1</span>,x,a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line">ll ans,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">one</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(m&gt;=<span class="number">10</span>) m/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buxian</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) s+=<span class="built_in">pow</span>(<span class="number">10</span>,i);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求n的位数</span></span><br><span class="line">    a[<span class="number">1</span>]=n;</span><br><span class="line">    x=<span class="built_in">one</span>(n);</span><br><span class="line">    <span class="keyword">int</span> u=n;</span><br><span class="line">    <span class="keyword">while</span>(u)&#123;</span><br><span class="line">        u/=<span class="number">10</span>;</span><br><span class="line">        a[++k]=u;</span><br><span class="line">    &#125; </span><br><span class="line">    k--;</span><br><span class="line">    <span class="comment">//求数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;x) b[i]+=<span class="built_in">buxian</span>(k<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==x)&#123;</span><br><span class="line">            b[i]+=<span class="built_in">buxian</span>(k<span class="number">-3</span>);</span><br><span class="line">            <span class="keyword">int</span> y=<span class="built_in">pow</span>(<span class="number">10</span>,k<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=y;j+=<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x*y+j+<span class="built_in">one</span>(i)&lt;=n) b[i]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> b[i]+=<span class="built_in">buxian</span>(k<span class="number">-3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) b[i]++,ans+=b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">11</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(i%<span class="number">10</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        t=i%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">one</span>(i)==t)&#123;</span><br><span class="line">            ans+=b[t];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;x)&#123;</span><br><span class="line">            ans+=<span class="built_in">buxian</span>(k<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==x)&#123;</span><br><span class="line">            ans+=<span class="built_in">buxian</span>(k<span class="number">-3</span>);</span><br><span class="line">            <span class="keyword">int</span> y=<span class="built_in">pow</span>(<span class="number">10</span>,k<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=y;j+=<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x*y+j+<span class="built_in">one</span>(i)&lt;=n) ans++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//t&gt;x</span></span><br><span class="line">        ans+=<span class="built_in">buxian</span>(k<span class="number">-3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=9;i++) printf(&quot;%d &quot;,b[i]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度的话……大概 $O\big(9+\frac{1}{10}\times (n-9)^2+\frac{4}{5}\times (n-9)\big)$？？反正能过，极限数据大概 $1.5$ 秒跑完。</p><hr><h3 id="说句闲话"><a href="#说句闲话" class="headerlink" title="说句闲话"></a>说句闲话</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>其实第三种方法根本不需要第二层循环，因为对于中间的那个数来说其实就是每次加一，我们还不如直接看中间那个数是多少，然后判断一下刚好卡着那个数行不行就可以了。这样直接把第二层循环给弄掉。</p><hr><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p>还有更<del>玄学</del>厉害的，我们机房的一群大佬说可以把方法二和方法三结合起来，这样复杂度就是 $O(81)$​，直接常数级别了，详见 zqw 大佬的题解链接：<a href="https://www.luogu.com.cn/blog/cqbzzqw/solution-at4828">点这里</a>。</p><hr><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>送给大家一句来自初三教练的名言：</p><blockquote><p>你思维的深度决定你代码的长度。</p></blockquote><p>这道题体现得淋漓尽致啊。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递推，递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.6.26 考试总结</title>
      <link href="/posts/2021-6-26-%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/posts/2021-6-26-%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近考试考得挺多的……这次算，考得还行？$\text{rk16}$。</p><p>话说 Peter 崛起了啊，$\text{rk7}$……</p><p>然鹅我和他都因为数组开小少得了 $\text{60pts}$​。以后别犯这种低级错误了啊……</p><p>OJ 最终成绩：$40+100+55+5+0=200$​</p><p>Lemon 上不知道。</p><span id="more"></span><h2 id="快乐的题解时间"><a href="#快乐的题解时间" class="headerlink" title="快乐的题解时间"></a><del>快乐的</del>题解时间</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="http://222.180.160.110:1024/contest/1734/problem/1">T1</a></h3><p>题意简述：</p><p>有 $T$ 组数据，每组数据给定 $n$ 个数字，记为 $a_1,a_2,\ldots a_n$。在这一组数据中选出 $5$ 个数字使得这 $5$ 个数字的乘积最大。</p><p>果然是不开 <code>long long</code> 见祖宗啊……</p><p>还有就是<strong>数组开小</strong>，后 $10$ 个点全 RE 了……</p><p>我直接 AC $\text{100pts}→$ WA + RE $\text{40pts}$……</p><hr><h3 id="法一：贪心"><a href="#法一：贪心" class="headerlink" title="法一：贪心"></a>法一：贪心</h3><p>我们知道乘积要最大，一定要让它<strong>尽量为正数</strong>。</p><p>那么，首先我们先按照<strong>绝对值的大小</strong>将数组从大到小排序。然后我们看一看：</p><ol><li><p>如果前 $5$ 个数字中有 $0$，那说明这组数据中不为 $0$ 的数少于 $5$ 个。那么结果一定为 $0$。</p></li><li><p>如果前 $5$ 个数字的乘积为正数，那么这个乘积一定是最优解。证明很简单，相信大家都明白。</p></li></ol><p>那么如果这 $5$ 个数的乘积是负数呢？</p><p>那么首先我们分析最小那个数（即第 $5$ 个数）是否可以被换成一个和它正负相反的数字。因为我们知道，当一个乘积为负的时候，只需要换一个就可以了。找当然是从前往后找，找到一个就立刻输出，然后 <code>return</code>。因为这已经是最优解了。</p><p>继续，如果找不到怎么办？那我们就找与 $a_4,a_3,a_2,a_1$ 正负相反的数来代替它（此时的 $a$ 数组已经排过序，还是按照绝对值从大往小找保证找到的是最优解，当然，前 $4$ 个数字要从小往大找）。</p><p>那如果还是找不到呢？那么，这组数据一定是不能凑出正数。那么我们就只能找绝对值最小的 $5$ 个数（包括 $0$）来凑乘积了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,n,a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">bool</span> f;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(x)&gt;<span class="built_in">abs</span>(y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(x)&lt;<span class="built_in">abs</span>(y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> b[<span class="number">15</span>]=&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        b[i]=(a[i]&lt;<span class="number">0</span>);</span><br><span class="line">        h+=(<span class="keyword">int</span>)b[i];</span><br><span class="line">        <span class="keyword">if</span>(!a[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(h&amp;<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[<span class="number">1</span>]*a[<span class="number">2</span>]*a[<span class="number">3</span>]*a[<span class="number">4</span>]*a[<span class="number">5</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> d=!b[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">6</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((a[i]&lt;<span class="number">0</span>)==d)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[<span class="number">1</span>]*a[<span class="number">2</span>]*a[<span class="number">3</span>]*a[<span class="number">4</span>]*a[i]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]!=b[<span class="number">5</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> y=a[<span class="number">1</span>]*a[<span class="number">2</span>]*a[<span class="number">3</span>]*a[<span class="number">4</span>]*a[<span class="number">5</span>];</span><br><span class="line">            y/=a[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">6</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((a[j]&lt;<span class="number">0</span>)!=b[i])&#123;</span><br><span class="line">                    y*=a[j];</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,y);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[<span class="number">1</span>]*a[<span class="number">2</span>]*a[<span class="number">3</span>]*a[<span class="number">4</span>]*a[<span class="number">5</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;maximum.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;maximum.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        f=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),f=f|(!a[i]);</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">        <span class="built_in">s</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="法二：DP"><a href="#法二：DP" class="headerlink" title="法二：DP"></a>法二：DP</h3><p>As we all know，最大的乘积是有可能从最小的数（绝对值比较大）乘一个负数得到~</p><p>所以，如果我们使用 DP 来求解这个问题的话，需要开两个 $dp$ 数组来分别存最大值和最小值。</p><p>如果要求最大值（至少得是个正数吧），有两种方法来求：</p><ol><li><p>两个正数（其中一个是前面的最大值）相乘；</p></li><li><p>两个负数（其中一个是前面的最小值）相乘。</p></li></ol><p>求最小值也有两种方法，不过我现在用的这个电脑输入法实在是太不好用了，所以我真的不想写了。。。</p><p>见代码……</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,n,a[<span class="number">100005</span>];</span><br><span class="line">ll dp1[<span class="number">100005</span>][<span class="number">6</span>],dp2[<span class="number">100005</span>][<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;maximum.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;maximum.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp1,<span class="number">128</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp1));</span><br><span class="line">        <span class="built_in">memset</span>(dp2,<span class="number">127</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp2));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp1[i][<span class="number">0</span>]=dp2[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,(<span class="keyword">int</span>)<span class="number">5</span>);j++)&#123;</span><br><span class="line">                dp1[i][j]=<span class="built_in">max</span>(<span class="built_in">max</span>(dp1[i<span class="number">-1</span>][j<span class="number">-1</span>]*a[i],dp2[i<span class="number">-1</span>][j<span class="number">-1</span>]*a[i]),dp1[i<span class="number">-1</span>][j]);</span><br><span class="line">                dp2[i][j]=<span class="built_in">min</span>(<span class="built_in">min</span>(dp1[i<span class="number">-1</span>][j<span class="number">-1</span>]*a[i],dp2[i<span class="number">-1</span>][j<span class="number">-1</span>]*a[i]),dp2[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp1[n][<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="http://222.180.160.110:1024/contest/1734/problem/2">T2</a></h3><p>水题，打表即可……</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有亿点长的打表代码 qwq</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> I,V,X,L,C,D,M,n;</span><br><span class="line"><span class="function">string <span class="title">sc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> qian=x/<span class="number">1000</span>;</span><br><span class="line">    x%=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> bai=x/<span class="number">100</span>;</span><br><span class="line">    x%=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> shi=x/<span class="number">10</span>;</span><br><span class="line">    x%=<span class="number">10</span>;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="comment">//千位</span></span><br><span class="line">    <span class="keyword">if</span>(qian==<span class="number">1</span>) s=<span class="string">&quot;M&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(qian==<span class="number">2</span>) s=<span class="string">&quot;MM&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(qian==<span class="number">3</span>) s=<span class="string">&quot;MMM&quot;</span>;</span><br><span class="line">    <span class="comment">//百位</span></span><br><span class="line">    <span class="keyword">if</span>(bai==<span class="number">1</span>) s+=<span class="string">&quot;C&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bai==<span class="number">2</span>) s+=<span class="string">&quot;CC&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bai==<span class="number">3</span>) s+=<span class="string">&quot;CCC&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bai==<span class="number">4</span>) s+=<span class="string">&quot;CD&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bai==<span class="number">5</span>) s+=<span class="string">&quot;D&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bai==<span class="number">6</span>) s+=<span class="string">&quot;DC&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bai==<span class="number">7</span>) s+=<span class="string">&quot;DCC&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bai==<span class="number">8</span>) s+=<span class="string">&quot;DCCC&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bai==<span class="number">9</span>) s+=<span class="string">&quot;CM&quot;</span>;</span><br><span class="line">    <span class="comment">//十位</span></span><br><span class="line">    <span class="keyword">if</span>(shi==<span class="number">1</span>) s+=<span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(shi==<span class="number">2</span>) s+=<span class="string">&quot;XX&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(shi==<span class="number">3</span>) s+=<span class="string">&quot;XXX&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(shi==<span class="number">4</span>) s+=<span class="string">&quot;XL&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(shi==<span class="number">5</span>) s+=<span class="string">&quot;L&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(shi==<span class="number">6</span>) s+=<span class="string">&quot;LX&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(shi==<span class="number">7</span>) s+=<span class="string">&quot;LXX&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(shi==<span class="number">8</span>) s+=<span class="string">&quot;LXXX&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(shi==<span class="number">9</span>) s+=<span class="string">&quot;XC&quot;</span>;</span><br><span class="line">    <span class="comment">//个位 </span></span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>) s+=<span class="string">&quot;I&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>) s+=<span class="string">&quot;II&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">3</span>) s+=<span class="string">&quot;III&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">4</span>) s+=<span class="string">&quot;IV&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">5</span>) s+=<span class="string">&quot;V&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">6</span>) s+=<span class="string">&quot;VI&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">7</span>) s+=<span class="string">&quot;VII&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">8</span>) s+=<span class="string">&quot;VIII&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">9</span>) s+=<span class="string">&quot;IX&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;introduction.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;introduction.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        string s=<span class="built_in">sc</span>(i);</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;I&#x27;</span>) I++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;V&#x27;</span>) V++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;X&#x27;</span>) X++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;L&#x27;</span>) L++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;C&#x27;</span>) C++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;D&#x27;</span>) D++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;M&#x27;</span>) M++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(I) <span class="built_in">printf</span>(<span class="string">&quot;I %d\n&quot;</span>,I);</span><br><span class="line">    <span class="keyword">if</span>(V) <span class="built_in">printf</span>(<span class="string">&quot;V %d\n&quot;</span>,V);</span><br><span class="line">    <span class="keyword">if</span>(X) <span class="built_in">printf</span>(<span class="string">&quot;X %d\n&quot;</span>,X);</span><br><span class="line">    <span class="keyword">if</span>(L) <span class="built_in">printf</span>(<span class="string">&quot;L %d\n&quot;</span>,L);</span><br><span class="line">    <span class="keyword">if</span>(C) <span class="built_in">printf</span>(<span class="string">&quot;C %d\n&quot;</span>,C);</span><br><span class="line">    <span class="keyword">if</span>(D) <span class="built_in">printf</span>(<span class="string">&quot;D %d\n&quot;</span>,D);</span><br><span class="line">    <span class="keyword">if</span>(M) <span class="built_in">printf</span>(<span class="string">&quot;M %d\n&quot;</span>,M);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="http://222.180.160.110:1024/contest/1734/problem/3">T3</a></h3><p>和 LIS 问题的普通版求解差不多，只是需要多开一维记录前一个是上升还是下降。</p><p>zmq 说也可以用贪心统计折点的数量再 $+1$，但是我交了之后只有 $\text{45pts}$，也不知道是我实现错了还是他说错了。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,num,dp[<span class="number">10005</span>][<span class="number">2</span>],a[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">10005</span>];<span class="comment">//0为上升，1为下降</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sawtooth.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sawtooth.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>]=dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[j]) dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i][<span class="number">0</span>],dp[j][<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j]) dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i][<span class="number">1</span>],dp[j][<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num=<span class="built_in">max</span>(num,<span class="built_in">max</span>(dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a><a href="http://222.180.160.110:1024/contest/1734/problem/4">T4</a></h3><p>$dp_{i,j}$ 表示前 $i$ 只 <del>mjl</del> 马进前 $j$ 个马棚产生的最小不愉快系数。</p><p>对于每一只 <del>mjl</del> 马，我们可以把它和它前面的 一些 <del>mjl</del> 马一起装在一个马棚里，说具体点，就是再用一层循环，$q$ 代表从第 $q$ 只 <del>mjl</del> 马开始就和第 $i$ 只 <del>mjl</del> 马装在一个马棚里。这样产生的不愉快系数就是 $dp_{q-1,j-1}$ + 这个马棚里的不愉快系数。那这个不愉快系数怎么算呢？用前缀和统计一下这个区间里黑 <del>mjl</del> 马和白 <del>mjl</del> 马的数量再相乘就可以了。具体看代码。</p><p>$dp$ 初始化成 $\text{INF}$，$dp_{0,0}=0$。</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,a[<span class="number">505</span>],b[<span class="number">505</span>],w[<span class="number">505</span>],dp[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;horse.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;horse.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">127</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        w[i]=w[i<span class="number">-1</span>]+(!a[i]);</span><br><span class="line">        b[i]=b[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,k);j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=j;q&lt;=i;q++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[q<span class="number">-1</span>][j<span class="number">-1</span>]+(w[i]-w[q<span class="number">-1</span>])*(b[i]-b[q<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a><a href="http://222.180.160.110:1024/contest/1734/problem/5">T5</a></h3><p>$50$ 分就是一个分组背包。</p><p>$100$ 分好像是要开专门记录有或者没有奖励子弹的情况。</p><p>没太听明白，放个代码留在这吧。</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> m,n,k;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="keyword">bool</span> h[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">205</span>][<span class="number">205</span>],dn[<span class="number">205</span>][<span class="number">205</span>],dpy[<span class="number">205</span>][<span class="number">205</span>],dpn[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;m,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>,&amp;f[i][j],&amp;a);</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="string">&#x27;Y&#x27;</span>) h[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化dy和dn的值 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">//列 </span></span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=m;l;l--)&#123; <span class="comment">//行 </span></span><br><span class="line">            <span class="keyword">if</span>(h[l][i])&#123;</span><br><span class="line">                dy[i][tot]+=f[l][i];</span><br><span class="line">                <span class="comment">//dn[i][tot]=dy[i][tot];</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tot++;</span><br><span class="line">                dn[i][tot]=dy[i][tot<span class="number">-1</span>]+f[l][i];</span><br><span class="line">                dy[i][tot]=dn[i][tot];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态转移 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">//列 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;j++)&#123; <span class="comment">//子弹的数量 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;=<span class="built_in">min</span>(k,j);q++)&#123; <span class="comment">//当前这一列子弹的数量 </span></span><br><span class="line">                <span class="comment">//打第i列最后打到Y，并且把这个奖励子弹用在后面 </span></span><br><span class="line">                dpy[i][j]=<span class="built_in">max</span>(dpy[i][j],dpy[i<span class="number">-1</span>][j-q]+dy[i][q]);</span><br><span class="line">                <span class="comment">//打第i列打到N</span></span><br><span class="line">                <span class="keyword">if</span>(q) dpn[i][j]=<span class="built_in">max</span>(dpn[i][j],dpy[i<span class="number">-1</span>][j-q]+dn[i][q]);</span><br><span class="line">                <span class="comment">//打第1~i-1列的N</span></span><br><span class="line">                <span class="keyword">if</span>(j-q) dpn[i][j]=<span class="built_in">max</span>(dpn[i][j],dpn[i<span class="number">-1</span>][j-q]+dy[i][q]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dpn[n][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中考假 &amp; 端午节做题记录</title>
      <link href="/posts/%E4%B8%AD%E8%80%83%E5%81%87-%E7%AB%AF%E5%8D%88%E8%8A%82%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/posts/%E4%B8%AD%E8%80%83%E5%81%87-%E7%AB%AF%E5%8D%88%E8%8A%82%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>端午和中考假连在一起了，放六天假，好耶！ヽ(✿ﾟ▽ﾟ)ノ</p><p>个人认为难度：</p><p>T1（难在读题）&lt;T4（代码较长，思路简单）&lt;T2（有一定的思维量，较为经典的要排序的 01 背包问题）&lt;T5（广搜）&lt;T3（难在读题 + 坑点较多的模拟）&lt;T6（线性 DP）&lt;T7（紫题劝退）</p><span id="more"></span><hr><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="http://222.180.160.110:1024/contest/1688/problem/1">T1</a></h3><p>$AC\ \ on\ \ 2021.06.11$</p><p><del>这题是来考语文的吗？</del></p><p>题目老长，愣是看了半天才看懂。</p><p>读懂题后：这不就是给一串数处理之后加在一起咩？？</p><p>处理也很简单 <del>（事实证明这道题最难的地方在读题）</del>，直接看灯是什么颜色：如果是绿的就变为 $0$，如果是红的就不变，如果是黄的就加上 $r$。</p><p><del>结果打完之后代码 CE 了后来我才发现 <code>time</code> 是 c++ 的关键词，无语……</del></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,a,b,r,y,g,Time; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;r,&amp;y,&amp;g,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(!a||a==<span class="number">1</span>) Time+=b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">2</span>) Time+=b+r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Time);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="http://222.180.160.110:1024/contest/1688/problem/2">T2</a></h3><p>$AC\ \ on\ \ 2021.06.13$</p><p><del>吃石头可海星。</del></p><p>背包，考点是怎么排序。</p><p>假设要吃两个石头 $x$ 和 $y$，先吃 $x$ 比先吃 $y$ 好。</p><p>设 $first$ 为石头的初始能量值，$lost$ 为每秒石头会浪费的能量值，$time$ 为吃一块石头要用的时间。</p><p>为了方便我们不考虑石头能量值流完的情况。</p><p>那么先吃 $x$ 的表达式为：</p><script type="math/tex; mode=display">energy1=x_{first}+y_{first}-x_{time}\times y_{lost}</script><p>先吃 $y$ 的表达式为：</p><script type="math/tex; mode=display">energy2=y_{first}+x_{first}-y_{time}\times x_{lost}</script><p>我们知道 $energy1&gt;energy2$</p><p>代入原式：</p><script type="math/tex; mode=display">x_{first}+y_{first}-x_{time}\times y_{lost}>y_{first}+x_{first}-y_{time}\times x_{lost}</script><p>把相同的地方抵消了就变成：</p><script type="math/tex; mode=display">-x_{time}\times y_{lost}>-y_{time}\times x_{lost}</script><p>把负号搞掉：</p><script type="math/tex; mode=display">x_{time}\times y_{lost}<y_{time}\times x_{lost}</script><p>嗯，式子出来了，排序后再用一个 01 背包就可以了。</p><p>注意两点：</p><ol><li>背包 dp 初始化是 $128$（因为这代表的是时间点要算还剩多少能量值），只有 $dp_0$ 初始化为 $0$；</li><li>开 <code>long long</code>。</li></ol><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> T,n,ans,dp[<span class="number">10005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rock</span>&#123;</span><span class="keyword">int</span> t,lost,first;&#125;a[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(rock x,rock y)</span></span>&#123;<span class="keyword">return</span> x.t*y.lost&lt;y.t*x.lost;&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;=T;r++)&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">128</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;a[i].t,&amp;a[i].first,&amp;a[i].lost);</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">10000</span>;j&gt;=a[i].t;j--)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-a[i].t]+a[i].first-(j-a[i].t)*a[i].lost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10000</span>;i++) ans=<span class="built_in">max</span>(ans,dp[i]); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%lld: %lld\n&quot;</span>,r,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="http://222.180.160.110:1024/contest/1688/problem/3">T3</a></h3><p>$AC\ \ on\ \ 2021.06.13$</p><p>就大模拟，没啥好说的，代码调了一个下午。</p><p>一定要注意几点（踩过的坑）：</p><ol><li>读题。（数字里不能有 $0$，也不能有相同数字）；</li><li>循环里要<strong>先 <code>n++</code></strong>；</li><li>注意反转数串；</li><li>每个数都只能走一遍。</li></ol><p><del>橙题调这么久我还有救吗 qwq</del></p><h3 id="Code​"><a href="#Code​" class="headerlink" title="Code​"></a>Code​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//把i转换为数串形式</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">15</span>]=&#123;&#125;,c[<span class="number">15</span>]=&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> weishu=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i)&#123;</span><br><span class="line">        c[++weishu]=(<span class="keyword">int</span>)i%(ll)<span class="number">10</span>;</span><br><span class="line">        i/=(ll)<span class="number">10</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转！ </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=weishu;i++) a[i]=c[weishu-i+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//无重复数字 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=weishu;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//去0判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=weishu;i++) <span class="keyword">if</span>(!a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//开始模拟 </span></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> b[<span class="number">15</span>]=&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=weishu;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=a[x];</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">if</span>(x==weishu+<span class="number">1</span>) x=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[x]&amp;&amp;x!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        b[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=weishu;i++) flag&amp;=b[i];</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,n);</span></span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(n))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,n);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a><a href="http://222.180.160.110:1024/contest/1688/problem/4">T4</a></h3><p>$AC\ \ on\ \ 2021.06.13$</p><p>嗯，看来 mjl 是爱上大模拟了（逃。</p><p>直接模拟，每一步根据横，竖，左上右下斜，右上左下斜四个方向判断赢了没有。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,x,y,a[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> zt=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=n;t++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>) zt=<span class="string">&#x27;A&#x27;</span>,a[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> zt=<span class="string">&#x27;B&#x27;</span>,a[x][y]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">15</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//横着的 </span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-1</span>][j]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-2</span>][j]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-3</span>][j]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-4</span>][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;A %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-1</span>][j]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-2</span>][j]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-3</span>][j]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-4</span>][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;B %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=<span class="number">11</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">1</span>][j]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">2</span>][j]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">3</span>][j]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">4</span>][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;A %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">1</span>][j]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">2</span>][j]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">3</span>][j]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">4</span>][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;B %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//竖着的 </span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>&amp;&amp;a[i][j<span class="number">-1</span>]==<span class="number">1</span>&amp;&amp;a[i][j<span class="number">-2</span>]==<span class="number">1</span>&amp;&amp;a[i][j<span class="number">-3</span>]==<span class="number">1</span>&amp;&amp;a[i][j<span class="number">-4</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;A %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">2</span>&amp;&amp;a[i][j<span class="number">-1</span>]==<span class="number">2</span>&amp;&amp;a[i][j<span class="number">-2</span>]==<span class="number">2</span>&amp;&amp;a[i][j<span class="number">-3</span>]==<span class="number">2</span>&amp;&amp;a[i][j<span class="number">-4</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;B %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;=<span class="number">11</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>&amp;&amp;a[i][j+<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[i][j+<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;a[i][j+<span class="number">3</span>]==<span class="number">1</span>&amp;&amp;a[i][j+<span class="number">4</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;A %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">2</span>&amp;&amp;a[i][j+<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[i][j+<span class="number">2</span>]==<span class="number">2</span>&amp;&amp;a[i][j+<span class="number">3</span>]==<span class="number">2</span>&amp;&amp;a[i][j+<span class="number">4</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;B %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左上右下斜</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;=<span class="number">5</span>&amp;&amp;j&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-2</span>][j<span class="number">-2</span>]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-3</span>][j<span class="number">-3</span>]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-4</span>][j<span class="number">-4</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;A %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-2</span>][j<span class="number">-2</span>]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-3</span>][j<span class="number">-3</span>]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-4</span>][j<span class="number">-4</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;B %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span>(i&lt;=<span class="number">11</span>&amp;&amp;j&lt;=<span class="number">11</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">2</span>][j+<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">3</span>][j+<span class="number">3</span>]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">4</span>][j+<span class="number">4</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;A %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">2</span>][j+<span class="number">2</span>]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">3</span>][j+<span class="number">3</span>]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">4</span>][j+<span class="number">4</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;B %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左下右上斜</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">5</span>&amp;&amp;i&lt;=<span class="number">11</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">2</span>][j<span class="number">-2</span>]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">3</span>][j<span class="number">-3</span>]==<span class="number">1</span>&amp;&amp;a[i+<span class="number">4</span>][j<span class="number">-4</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;A %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">2</span>][j<span class="number">-2</span>]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">3</span>][j<span class="number">-3</span>]==<span class="number">2</span>&amp;&amp;a[i+<span class="number">4</span>][j<span class="number">-4</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;B %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=<span class="number">5</span>&amp;&amp;j&lt;=<span class="number">11</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-1</span>][j+<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-2</span>][j+<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-3</span>][j+<span class="number">3</span>]==<span class="number">1</span>&amp;&amp;a[i<span class="number">-4</span>][j+<span class="number">4</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;A %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(a[i][j]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-1</span>][j+<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-2</span>][j+<span class="number">2</span>]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-3</span>][j+<span class="number">3</span>]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-4</span>][j+<span class="number">4</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;B %d&quot;</span>,t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tie&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>据说有个小五打了 5.6K，好可怕</del></p><hr><h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a><a href="http://222.180.160.110:1024/contest/1688/problem/5">T5</a></h3><p>$AC\ \ on\ \ 2021.06.14$</p><p>广搜（数据范围很水），不过要注意，在算这个点能不能走到终点的时候，必须老老实实地从这个点出发走到终点，不能从终点倒回来枚举 <del>（别问我怎么知道的）。</del></p><p>不会 T 掉，数据范围是真的水。</p><p>这里我打了两个差不多的 bfs 函数，只不过一个没有返回值一个是 <code>bool</code> 型的。其实这里可以用数组实现，一个 bfs 函数就够了，但是<del>我懒得打，反正能 A</del>。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> m,n,sx,sy,tx,ty;</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">55</span>][<span class="number">55</span>],c[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> x,y;&#125;t1,t2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    t1.x=x,t1.y=y;</span><br><span class="line">    q.<span class="built_in">push</span>(t1);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        t1=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> dx,dy;</span><br><span class="line">        <span class="keyword">int</span> start,end; <span class="comment">//循环开始与结束 </span></span><br><span class="line">        <span class="keyword">if</span>(a[t1.x][t1.y]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;a[t1.x+<span class="number">1</span>][t1.y]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[t1.x][t1.y]==<span class="string">&#x27;+&#x27;</span>||a[t1.x][t1.y]==<span class="string">&#x27;S&#x27;</span>||a[t1.x][t1.y]==<span class="string">&#x27;T&#x27;</span>) start=<span class="number">0</span>,end=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[t1.x][t1.y]==<span class="string">&#x27;-&#x27;</span>) start=<span class="number">0</span>,end=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[t1.x][t1.y]==<span class="string">&#x27;|&#x27;</span>) start=<span class="number">2</span>,end=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[t1.x][t1.y]==<span class="string">&#x27;.&#x27;</span>) start=<span class="number">3</span>,end=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">            dx=t1.x+dir[i][<span class="number">0</span>];</span><br><span class="line">            dy=t1.y+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dx&gt;=<span class="number">1</span>&amp;&amp;dx&lt;=m&amp;&amp;dy&gt;=<span class="number">1</span>&amp;&amp;dy&lt;=n&amp;&amp;a[dx][dy]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(b[dx][dy]) <span class="keyword">continue</span>;</span><br><span class="line">                b[dx][dy]=<span class="number">1</span>;</span><br><span class="line">                t2.x=dx,t2.y=dy;</span><br><span class="line">                q.<span class="built_in">push</span>(t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否能到达终点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    t1.x=x,t1.y=y;</span><br><span class="line">    q.<span class="built_in">push</span>(t1);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        t1=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t1.x==tx&amp;&amp;t1.y==ty) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> dx,dy;</span><br><span class="line">        <span class="keyword">int</span> start,end; </span><br><span class="line">        <span class="keyword">if</span>(a[t1.x][t1.y]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;a[t1.x+<span class="number">1</span>][t1.y]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[t1.x][t1.y]==<span class="string">&#x27;+&#x27;</span>||a[t1.x][t1.y]==<span class="string">&#x27;S&#x27;</span>||a[t1.x][t1.y]==<span class="string">&#x27;T&#x27;</span>) start=<span class="number">0</span>,end=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[t1.x][t1.y]==<span class="string">&#x27;-&#x27;</span>) start=<span class="number">0</span>,end=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[t1.x][t1.y]==<span class="string">&#x27;|&#x27;</span>) start=<span class="number">2</span>,end=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[t1.x][t1.y]==<span class="string">&#x27;.&#x27;</span>) start=<span class="number">3</span>,end=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">            dx=t1.x+dir[i][<span class="number">0</span>];</span><br><span class="line">            dy=t1.y+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dx&gt;=<span class="number">1</span>&amp;&amp;dx&lt;=m&amp;&amp;dy&gt;=<span class="number">1</span>&amp;&amp;dy&lt;=n&amp;&amp;a[dx][dy]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[dx][dy]) <span class="keyword">continue</span>;</span><br><span class="line">                c[dx][dy]=<span class="number">1</span>;</span><br><span class="line">                t2.x=dx,t2.y=dy;</span><br><span class="line">                q.<span class="built_in">push</span>(t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;S&#x27;</span>) sx=i,sy=j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;T&#x27;</span>) tx=i,ty=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(sx,sy);</span><br><span class="line">    <span class="keyword">if</span>(!b[tx][ty])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m stuck!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">bfs2</span>(i,j)&amp;&amp;b[i][j]) sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="T6"><a href="#T6" class="headerlink" title="T6"></a><a href="http://222.180.160.110:1024/contest/1688/problem/6">T6</a></h3><p>$AC\ \ on\ \ 2021.06.15$（只可惜比赛已经结束了 qwq）</p><p><del>30 分一定是万恶的全排列了 qwq</del></p><p>不！我们不能思想只停留在部分分！</p><p>好吧这题是道 DP。</p><p>思路和大家的差不多，<del>不讲！</del></p><p><del>话说我竟然不看 TJ 想到了这个思路就很那啥。</del></p><p><del>最关键的是我竟然没想到区间求和的优化就很那啥。</del></p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,sum,dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">10000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            sum=(sum+dp[i<span class="number">-1</span>][j])%p;</span><br><span class="line">            dp[i][j]=sum;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&gt;=i) sum=(sum-dp[i<span class="number">-1</span>][j-i+<span class="number">1</span>]+p)%p; <span class="comment">//括号里要加上取余的数不然会取爆 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T7"><a href="#T7" class="headerlink" title="T7"></a><a href="http://222.180.160.110:1024/contest/1688/problem/7">T7</a></h3><p><del>易证：mjl 爱上了大模拟之后一定又爱上了 HAOI……</del></p><p>紫题搞毛线啊。</p><p>溜了溜了。</p><h3 id="The-end"><a href="#The-end" class="headerlink" title="The end."></a>The end.</h3>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6855「EZEC-4.5」走方格 题解</title>
      <link href="/posts/Solution-P6855/"/>
      <url>/posts/Solution-P6855/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://www.luogu.com.cn/problem/P6855">题目传送门</a></p><p><strong>正解：动态规划</strong></p><p>难度较大的一道题 qwq。</p><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个 $n\times m$ 大小的方格阵，可以把方格中的任意一个数改为 $0$，每次从 $(1,1)$ 到 $(n,m)$​ 的得分为路上所有数字的和。求每次改动数字后能得到的最大值的最小值。</p><span id="more"></span><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>PS1：因为此篇题解前后改动较多，如果有什么错误请各位奆佬提出，本蒟蒻感激不尽 ovo。</p><p>PS2：因为我习惯用 $m$ 表示行 $n$ 表示列，所以下列题解就会这么写。</p><p>有点麻烦。</p><p>如果每个点只能遍历一次，那么必须不变值和变为 $0$ 这两种情况需要同时考虑。</p><p>首先我们可以考虑先求出从 $(1,1)$ 点出发走到 $(i,j)$ 点和从 $(m,n)$出发走到 $(i,j)$ 点能拿到的最大分数，分别存在 $dp1$ 数组和 $dp2$ 数组里。</p><p>这两个数组很好求，按照每个初学 DP 者都要打的取数板子就珂以了。至于为什么要求这两个数组，我先卖个关子，待会儿就知道了（逃。</p><p>我们知道，如果你从 $(1,1)$ 出发，在走的时候不经过某个坐标为 $(i,j)$ 的点（也就是绕过这个点），你有两种情况可以绕开它：</p><ol><li><p>从左边绕。</p></li><li><p>从上边绕。</p></li></ol><p>给这两种方法更严谨的定义 $(i&gt;0)$ ：</p><ol><li><p>从左边绕：经过点 $(x,y-i)$。</p></li><li><p>从上边绕：经过点 $(x-i,y)$。</p></li></ol><p>对于这两种情况，我们可以分别用两个二维数组 $l$ （左边绕）和 $d$ （上边绕）来存：</p><ul><li><p>$l_{i,j}$ 表示从左边绕过 $(i,j)$ 点能获得的最大值。</p></li><li><p>$d_{i,j}$ 表示从上边绕过 $(i,j)$ 点能获得的最大值。</p></li></ul><p>但是如何求这两个数组呢？</p><p>直接切入可能比较麻烦。这个时候我们可以先分析这种情况：</p><p><img src="https://i.loli.net/2021/10/01/Pm52gjXCsSAznw8.jpg" alt="贴着走的情况"></p><p>不管是往哪边绕，也不管前面怎么走，都<strong>紧贴</strong>着点 $(i,j)$ 过路方便分析，即，从左绕一定经过点 $(i,j-1)$，从上绕一定经过点 $(i-1,j)$。</p><p>首先分析从左边绕的情况。</p><p><img src="https://i.loli.net/2021/10/01/k9WT5caJNDf3HY7.png" alt="上边绕的情况"></p><p>看图，蓝色区域表示从 $(1,1)$​ 出发到点 $(i,j-1)$​ <strong>有可能</strong>会经过的区域，红色区域表示从点 $(i+1,j-1)$​ 到 $(m,n)$​ 有可能会经过的区域。至于为什么选这两个点呢，相信大家看图也能明白，因为选择这两个点可以做到<strong>可能经过的格子不重不漏</strong>，考虑到每种情况。</p><p>如果这么算，那么从点 $(i,j-1)$ 绕过去能拿到的最大分数就是：</p><script type="math/tex; mode=display">score=dp1_{i,j-1}+dp2_{i+1,j-1}</script><p>现在大家知道两个 $dp$ 数组的意义了吧，就是用来求<strong>某个区域的最大分数</strong>的。因为如果每次循环到一个点就计算此点到终点的分数还需要两层循环会超时，基于走方格的方向是可逆的，我们只需要计算终点到每个点的最大分数就可以啦 OvO。</p><p>那我们现在只求了最贴近点 $(i,j)$ 的绕法，那我们如何求出往左绕的所有情况的最大值呢？</p><p>我们之前不是用了一个数组来存往左边绕的值吗？因为循环的顺序是<strong>从上到下，从左到右</strong>的，所以在求点 $(i,j)$ 的值时，我们已经把它左上方的所有值都求出来了。现在我们可以利用这些值，每一次，我们求当前 $score$ 与之前最大分数的较大值，那每次都求最大值就是所有情况中的最大值。</p><p>那么最后的结果就是：</p><script type="math/tex; mode=display">l_{i,j}=\max(dp1_{i,j-1}+dp2_{i+1,j-1},i_{i,j-1})</script><p>至于为什么我们利用的是 $l_{i,j-1}$，大家可以自己画图感知，这个格子就位于我们前面求的必须经过的那个格子 $(i,j-1)$，那么绕过它我们就会求必须经过点 $(i,j-2)$，这样我们就又需要考虑绕过这个格子的情况，就又必须经过点 $(i,j-3)$……这么一层一层往左推，最后可以推到点 $(i,1)$，从而把每种情况都考虑到。</p><p>从上面绕分析方法也差不多，这里不多说画张图让读者感知一下。</p><p><img src="https://i.loli.net/2021/10/01/HVxqsdDY8f3v6KX.png" alt="左边绕的情况"></p><p><del>（您看看这两张图多像，连大小都差不多26 KB）</del></p><p>最后求出 $d_{i,j}$ 的式子为：</p><script type="math/tex; mode=display">d_{i,j}=\max(dp1_{i-1,j}+dp2_{i-1,j+1},d_{i-1,j})</script><p>最后求答案有些麻烦，因为题目要求的是<strong>变化后最能获得的最大分数的最小值</strong>，所以 $\max$ 和 $\min$ 是真的挺容易用混的，这里需要特别注意。</p><p>首先每对一个格子进行操作，最后得到的答案会是下列三种情况中的一种：</p><ol><li>从左边绕过去得到的最大分数。</li><li>从上边绕过去得到的最大分数。</li><li>经过这个格子得到的最大分数。</li></ol><p>前两个我们已经求解了，但其实第三种情况是灰常简单的！因为要保证经过点 $(i,j)$，所以我们只需要求 $dp1_{i,j}+dp2_{i,j}$ 就可以了。但是上面那个式子算了两次 $(i,j)$ 的值，而我们因为把它变成 $0$ 了，就一次都不能算。所以还需要减去两个 $a_{i,j}$。</p><p>所以最后的答案终于可能被更新了 owo：</p><script type="math/tex; mode=display">ans=\min\big(ans,\max(l_{i,j},d_{i,j},dp1_{i,j}+dp2_{i,j}-2\times a_{i,j})\big)</script><p><strong>最后再强调一遍要注意最大值和最小值别用反了啊！</strong> <del>别问我为什么知道（悲）。</del></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long <span class="comment">//记得要开long long哦！</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//温馨提示细节：因为最后答案还是求的最小值，所以 ans 需要定义极大值</span></span><br><span class="line">ll m,n,ans=LONG_LONG_MAX,a[<span class="number">2005</span>][<span class="number">2005</span>],dp1[<span class="number">2005</span>][<span class="number">2005</span>],dp2[<span class="number">2005</span>][<span class="number">2005</span>],l[<span class="number">2005</span>][<span class="number">2005</span>],d[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//求两个 dp 数组的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dp1[i][j]=<span class="built_in">max</span>(dp1[i<span class="number">-1</span>][j],dp1[i][j<span class="number">-1</span>])+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j;j--)&#123;</span><br><span class="line">            dp2[i][j]=<span class="built_in">max</span>(dp2[i+<span class="number">1</span>][j],dp2[i][j+<span class="number">1</span>])+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//核心代码开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            l[i][j]=<span class="built_in">max</span>(l[i][j<span class="number">-1</span>],dp1[i][j<span class="number">-1</span>]+dp2[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            d[i][j]=<span class="built_in">max</span>(d[i<span class="number">-1</span>][j],dp1[i<span class="number">-1</span>][j]+dp2[i<span class="number">-1</span>][j+<span class="number">1</span>]);</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(<span class="built_in">max</span>(l[i][j],d[i][j]),dp1[i][j]+dp2[i][j]<span class="number">-2</span>*a[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//核心代码结束，输出答案</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>这真的是一道很好的动态规划题，很考验思维，也有很多需要注意的细节。最后，看在本人写了那么久的份上，就请您随手点一下左下角那个小小的赞吧 qwq。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF201C Fragile Bridges 题解</title>
      <link href="/posts/Solution-CF201C/"/>
      <url>/posts/Solution-CF201C/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://www.luogu.com.cn/problem/CF201C">题目链接</a></p><p><strong>正解：动态规划</strong></p><p>思路不是很好想，想出来了应该就没有多大问题了，但是需要处理的细节较多，<del>再加上水水的样例</del>，难度应该是偏难的。个人感觉应该是绿到蓝的亚子。</p><p>Update: 已经有评级了，绿的，针不戳。</p><hr><h3 id="先说说思路的来源"><a href="#先说说思路的来源" class="headerlink" title="先说说思路的来源"></a>先说说思路的来源</h3><blockquote><p>错误解法，不想看请跳过。</p></blockquote><p>中午打开题目，第一反应：这不是一个暴搜部分分到手吗？</p><p>打了个无脑暴搜，深搜+回溯，分别向往左走和往右走的方向进行搜索，只是需要注意变量初始化和判断是否可以走。</p><p>时间复杂度 $Θ(2^{n})$，校内 OJ $15pts$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,ans,a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=sum,right=sum;</span><br><span class="line">    <span class="keyword">if</span>(!a[i<span class="number">-1</span>]&amp;&amp;!a[i+<span class="number">1</span>]) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span>(a[i<span class="number">-1</span>])&#123; <span class="comment">//可以往左走</span></span><br><span class="line">        a[i<span class="number">-1</span>]--; <span class="comment">//要耗费一次桥的耐久度</span></span><br><span class="line">        left=<span class="built_in">dfs</span>(i<span class="number">-1</span>,sum+<span class="number">1</span>);</span><br><span class="line">        a[i<span class="number">-1</span>]++; <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[i+<span class="number">1</span>])&#123; <span class="comment">//可以往右走</span></span><br><span class="line">        a[i+<span class="number">1</span>]--; <span class="comment">//要耗费一次桥的耐久度</span></span><br><span class="line">        right=<span class="built_in">dfs</span>(i+<span class="number">1</span>,sum+<span class="number">1</span>);</span><br><span class="line">        a[i+<span class="number">1</span>]++; <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left,right); <span class="comment">//返回最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="built_in">dfs</span>(i,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><del>可是 CF 的题都是绑在一个点上的啊</del>，于是<del>还没把正解想出来的</del>我开始想怎么优化。</p><p>我先想到了一个<del>假</del>优化：使用一个前缀和 $pre$ 数组统计一下前面最多可能得多少分，如果现在得的分 + 往左/右走能拿到的最多的分都不可以更新答案的话就不用搜这一边了。</p><p>程序不做展示，但是我发现样例竟然没过……</p><p>淦，那到底是哪里出问题了呢？</p><p>经过短暂的思考我们可以发现，完全有这么一种可能：</p><blockquote><p>假设你现在从第 $i$ 个平台往左走，在左边尽量赚到最多的分数之后回到第 $i$ 个平台，然后再往右边走，再在右边的平台结束游戏。</p></blockquote><p>此时的得分完全是有可能高于 $pre_{i-1}+sum$ 或 $ans$ 的。</p><hr><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>上面的枝我们减错了，但是事情却有了一点眉目：</p><p>这道题好像每次的状态转移都与他<strong>离开之后回不回来</strong>有关系。</p><p>为了方便，我们将第 $i$ 与 $i+1$ 个平台中的桥定义为 $i$ 号桥，这也与输入的数组下标对应。</p><p>所以可以定义 $dp$ 数组意义如下：</p><ul><li><p>$dp_{i,0}$ 代表往左边走且不回来。</p></li><li><p>$dp_{i,1}$ 代表往左边走且<strong>必须</strong>回来。</p></li><li><p>$dp_{i,2}$ 代表往右边走且不回来。</p></li><li><p>$dp_{i,3}$ 代表往右边走且必须回来。</p></li></ul><p>PS：关于必须回来这一个点，现有的题解说的是<strong>不保证回来</strong>，那么就有两种情况，较难判断。所以设置绝对一点较好思考。</p><p>首先思考 $dp_{i,0}$ 的情况。如果我们从第 $i$ 个平台往左边走（而且可以走），就一定会走到第 $i-1$ 个桥上。</p><p>而因为不回第 $i$ 个平台，所以我们无需考虑到了第 $i-1$ 个平台后再往左走（不考虑直接返回），还能不能回到第 $i-1$ 的平台。因此，对于走到第 $i-1$ 个平台能获得的最大分数，就为 $dp<em>{i-1,0}$ 和 $dp</em>{i-1,1}$ 的最大值。</p><p>然后再求从第 $i$ 个平台到第 $i-1$ 个平台能获得的最大分数。</p><p>首先要明确，我们是不回来的，所以最优的方式就是把这座桥尽量“榨干”，即能走断就走断，在两个平台之间反复横跳。但是若是要走到对面，需要走桥的次数必须是奇数。所以，如果桥当前还能走的最大次数是偶数，那就必须留一次走的机会（不然就走回去走不过来了）。</p><p>所以可以得出，往返这两个平台间能获得的最大分数（暂时叫 $score$）为：</p><script type="math/tex; mode=display">score=   \begin{cases}   a_{i-1},2\not\!|\;a_{i-1}\\    a_{i-1}-1,2\;|\;a_{i-1}  \end{cases}</script><p>在 c++ 中，我们可以用更加简洁的三目运算符表示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>])+((a[i<span class="number">-1</span>]&amp;<span class="number">1</span>)?a[i<span class="number">-1</span>]:(a[i<span class="number">-1</span>]<span class="number">-1</span>));</span><br></pre></td></tr></table></figure><p>接着看必须回来的情况。如果要保证回到第 $i$ 个平台，那么必须保证要先回到第 $i-1$ 个平台，然后还要能从中间那座桥走过去。所以前面加上的是 $dp_{i-1,1}$，没有别的情况。</p><p>像之前那样考虑在中间走能拿到的最大分数。因为要回去，我们需要经过偶数次桥。如果当前桥能走的次数是奇数，那就只能浪费一次机会达到能回来的目的。</p><script type="math/tex; mode=display">score=   \begin{cases}   a_{i-1}-1,2\not\!|\;a_{i-1}\\    a_{i-1},2\;|\;a_{i-1}  \end{cases}</script><p>同样可以用三目运算符解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+((a[i<span class="number">-1</span>]&amp;<span class="number">1</span>)?(a[i<span class="number">-1</span>]<span class="number">-1</span>):a[i<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><p>不过这样还是不对，大家是否注意到这个程序没有关于<strong>无法走动的判断</strong>？现在这个判断来了！</p><p>如果这座桥能走的次数为 $1$，那我走过去这座桥就断了，无法回来。为此，我只能放弃前面的所有分数。</p><p>所以上述程序只有在 $a_i&gt;1$ 时才能执行，当 $a_i=1$ 时，$dp_{i,1}$ 的值为 $0$（不用赋值）。</p><p>右边同理。只是循环要倒着枚举而已。</p><p>最后我们需要知道答案时什么。因为每一个平台都有可能作为出发点，所以需要枚举求解最优解。</p><p>那么，对于每一个点，我们可以先往左边走回来再往右边不回来，也可以先往右边回来再往左边不回来。所以答案就为：</p><script type="math/tex; mode=display">ans=\max_{i=1}^{n}\{dp_{i,0}+dp_{i,3},dp_{i,1}+dp_{i,2}\}</script><p><strong>提示：打代码的时候一定要注意你的这个下标到底代表的是平台还是桥！</strong> 在这道题中，$dp$ 数组代表的是平台，$a$ 数组代表的是桥。</p><h3 id="Code​"><a href="#Code​" class="headerlink" title="Code​"></a>Code​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,n,a[<span class="number">100005</span>],dp[<span class="number">100005</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>])+((a[i<span class="number">-1</span>]&amp;<span class="number">1</span>)?a[i<span class="number">-1</span>]:(a[i<span class="number">-1</span>]<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]&gt;<span class="number">1</span>) dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+((a[i<span class="number">-1</span>]&amp;<span class="number">1</span>)?(a[i<span class="number">-1</span>]<span class="number">-1</span>):a[i<span class="number">-1</span>]); <span class="comment">//注意加特判 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)&#123;</span><br><span class="line">        dp[i][<span class="number">2</span>]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][<span class="number">2</span>],dp[i+<span class="number">1</span>][<span class="number">3</span>])+((a[i]&amp;<span class="number">1</span>)?a[i]:(a[i]<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;<span class="number">1</span>) dp[i][<span class="number">3</span>]=dp[i+<span class="number">1</span>][<span class="number">3</span>]+((a[i]&amp;<span class="number">1</span>)?(a[i]<span class="number">-1</span>):a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(dp[i][<span class="number">0</span>]+dp[i][<span class="number">3</span>],dp[i][<span class="number">1</span>]+dp[i][<span class="number">2</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>比暴力还短吼</del></p><p>提交记录作证 qwq：<a href="https://www.luogu.com.cn/record/51511192">link</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF877B Nikita and string 题解</title>
      <link href="/posts/Solution-CF877B/"/>
      <url>/posts/Solution-CF877B/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果此题解有什么问题的话欢迎各位大巨佬提出。</p><p>题目链接：<a href="https://www.luogu.com.cn/problem/CF877B">CF877B</a></p><p>题目类型：dp，一讲就会，一做就废(；′⌒`)。</p><span id="more"></span><hr><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>2021/5/31：因为帮同学调代码添加了新发现的滚动数组问题。</p><hr><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>给定一个只含有 “a” 和 “b” 的字符串，求这个字符串中最长的<strong>子序列</strong>，子序列满足以下条件之一：</p><ol><li>全为 “a”。</li><li>全为 “b”。</li><li>开头和结尾是<strong>连续</strong>的 “a”，中间是<strong>连续</strong>的 “b”。</li></ol><p>字符串长度 $\leq 5000$。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>算法：动态规划</strong></p><p>首先可以发现一个“美丽”的字符串由<strong>三个部分</strong>组成，所以我们可以开一个二维的 $dp$ 数组。其含义如下：</p><ul><li><p>$dp_{i,1}$ 代表字符串只包含第一部分，从 $1\sim i$ 能取到的最长长度；</p></li><li><p>$dp_{i,2}$ 代表字符串包含第一部分和第二部分，从 $1\sim i$ 能取到的最长长度；</p></li><li><p>$dp_{i,3}$ 代表字符串包含所有部分，从 $1\sim i$ 能取到的最长长度。</p></li></ul><p>因为<strong>每个部分都可以是空串</strong>，所以最后的答案可以为 $dp_{i,1},dp_{i,2},dp_{i,3}$ 的<strong>任意一种</strong>，取最大值。</p><p>然后思考如何转移状态。</p><p>首先 $dp_{i,1}$ 是很好求的，我们只需要求解字符串里面有多少个 “a” 就可以了。这个很好想，要求解一个字符串中最长的只包含 “a” 或为空的子序列，只需统计 “a” 的个数，让所有的 “a” 都加入子序列。</p><p>当然我们不需要每次都用一个循环求解，可以参照前缀和的方式求解 “a” 的个数：</p><script type="math/tex; mode=display">dp_{i,j}=dp_{i-1,1}+(a[i]=='a');</script><p>（如果这个字符是 “a” 就 $+1$，反之不加）</p><p>接着考虑 $dp_{i,2}$ 的求法。实际上，我们可以用另一种方式理解前面求 $dp_{i,1}$，把它当做<strong>动态转移方程</strong>而并不是一个简单的求<strong>前缀和</strong>的式子：</p><ul><li>如果这个字符是 “a”，那么一定要选，然后再加上前 $i-1$ 个字符能拿到的最长的长度。</li></ul><p>那么，$dp_{i,2}$ 的解法就呼之欲出了：</p><script type="math/tex; mode=display">dp_{i,2}=\max\{dp_{i-1,1},dp_{i-1,2}\}+(a[i]=='b');</script><p>因为第一部分和第二部分都可以是空串，所以一个全为 “a” 的字符串同样可以作为第二部分的结果，所以需要求最大值。最后的那个 “b” 也是一样的，因为如果这个字符串不是一个全为 “a” 的字符串，就必须以 “b” 结束。所以只有后面是 “b” 才能增加字符串的长度，若答案全是 “a” 那就是 $dp_{i,1}$，与 $dp_{i,2}$ 的求解是无关的。</p><p>$dp_{i,3}$ 方法类似，需要考虑空串的情况，考虑 $dp$ 前两维的情况；也需要根据结尾的 “a” 判断不为空的最大值，<del>读者自证不难</del>。</p><script type="math/tex; mode=display">dp[i][3]=\max\{dp_{i-1,1},dp_{i-1,2},dp_{i-1,3}\}+(a[i]=='a');</script><p>最后可以看到：</p><p>我们只有 “$1,3$ 不空，$2$ 空”和 “$1,3$ 空，$2$ 不空”的情况没有考虑到。但是由于第一个部分和第三个部分本质上是一样的，所以这两种情况可以分别对应到另外两种我们已经考虑过的情况——全为 “a” 或全为 “b”。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">5005</span>][<span class="number">4</span>],n;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+(a[i]==<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        dp[i][<span class="number">2</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>])+(a[i]==<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">        dp[i][<span class="number">3</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>],dp[i<span class="number">-1</span>][<span class="number">3</span>]))+(a[i]==<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">max</span>(dp[n][<span class="number">1</span>],<span class="built_in">max</span>(dp[n][<span class="number">2</span>],dp[n][<span class="number">3</span>])));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="关于滚动数组"><a href="#关于滚动数组" class="headerlink" title="关于滚动数组"></a>关于滚动数组</h3><p>我有个同学一直没过让我帮他调代码，然后我发现他用的是滚动数组。</p><p>首先要明确这道题是不能在上述代码中直接修改的。因为如果打滚动，例如求 $dp_{i,3}$ 时需要用到 $dp_{i-1,2}$ 的值，但是如果打滚动这个值就已经被更新为 $dp_{i,2}$ 了。</p><p>如果要打滚动呢？</p><p>很简单，先求 $dp_{i,3}$，再求 $dp_{i,2}$，最后求 $dp_{i,1}$ 就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF474D Flowers 题解</title>
      <link href="/posts/Solution-CF474D/"/>
      <url>/posts/Solution-CF474D/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：CF474D-Flowers"><a href="#题目：CF474D-Flowers" class="headerlink" title="题目：CF474D Flowers"></a>题目：CF474D Flowers</h3><p><a href="https://www.luogu.com.cn/problem/CF474D">传送门</a></p><span id="more"></span><hr><h3 id="DP？递推？"><a href="#DP？递推？" class="headerlink" title="DP？递推？"></a>DP？递推？</h3><p>首先可以很快看出这是一道 DP 的题目，但与其说是 DP，还不如说是<strong>递推</strong>。</p><p>大家还记得刚学递推时教练肯定讲过的一道经典例题吗？就是爬楼梯，一个有 $n$ 阶的楼梯，一个人爬上去，每次可以爬一阶也可以爬两阶，问有多少种爬法？其实这道题也是一样的，只不过把 $2$ 换成了 $k$ 而已。</p><p>于是我们开始分析，定义 $dp[i]$ 为吃 $i$ 个蛋糕的吃法总数。</p><p>很容易看出，如果 $i&lt;k$，就不可以一口气吃掉，只能一个一个吃，方法为 $1$ 种。</p><p>如果 $i==k$，就既可以一个一个吃掉，也可以一口气全部吃完，方法为 $2$ 种。</p><p>如果 $i&gt;k$，就有两种吃法，既可以先吃 $i-1$ 个，然后再吃一个，也可以先吃 $i-k$ 个，再吃 $k$ 个。方法为 $dp[i-1]+dp[i-k]$ 种。</p><p>最后记得要开 <strong>long long</strong>，而且要一边加一边模 $1000000007$。</p><p>核心代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dp[i])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;k)</span><br><span class="line">    dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==k)</span><br><span class="line">    dp[i]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dp[i]=(dp[i<span class="number">-1</span>]+dp[i-k])%<span class="number">1000000007</span>;</span><br><span class="line">sum[i]=(sum[i<span class="number">-1</span>]+dp[i])%<span class="number">1000000007</span>;</span><br></pre></td></tr></table></figure></p><p>因为一组数据只有一个 $k$，但是有很多组关于这个 $k$ 的测试点，所以可以用一个前缀和数组统计 $dp_1\sim dp_i$ 的和，然后根据题目中 $mod\ 1000000007$。</p><hr><h3 id="玄学优化"><a href="#玄学优化" class="headerlink" title="玄学优化"></a><del>玄学</del>优化</h3><p>其实这个优化也不难想到。既然一组数据中只会有一个 $k$，那么说明不管怎么算，$dp[i]$ 的值算出来都是相等的。那么可以判断一下当前出现的最大 $x_2$，如果一组输入的 $x_2$ 值小于最大值，就说明 $dp[x_2]$ 已经计算过，直接输出即可。</p><hr><p>Code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,k,x1,x2,Max=<span class="number">1</span>;</span><br><span class="line">ll dp[<span class="number">100005</span>],sum[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;t,&amp;k);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x1,&amp;x2);</span><br><span class="line">        <span class="keyword">if</span>(Max&gt;=x2)&#123; <span class="comment">//优化：判断x2和max（x2）的大小</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(sum[x2]-sum[x1<span class="number">-1</span>])%<span class="number">1000000007</span>);</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//直接跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Max;i&lt;=x2;i++)&#123;<span class="comment">//只计算没计算过的</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;k)</span><br><span class="line">                dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==k)</span><br><span class="line">                dp[i]=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i]=(dp[i<span class="number">-1</span>]+dp[i-k])%<span class="number">1000000007</span>;</span><br><span class="line">            sum[i]=(sum[i<span class="number">-1</span>]+dp[i])%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(sum[x2]-sum[x1<span class="number">-1</span>])%<span class="number">1000000007</span>);</span><br><span class="line">        Max=x2;<span class="comment">//更新Max的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="究竟是什么地方错了？"><a href="#究竟是什么地方错了？" class="headerlink" title="究竟是什么地方错了？"></a>究竟是什么地方错了？</h3><p>然后你交上去发现WA了！</p><p>这也就是一个本蒟蒻在做题时犯的错误。</p><p>一般要取余的题都是一边计算一边取模，所以可能会造成<strong>dp数组中前面的值大于后面的值的情况</strong>。在最终计算 $x_1\sim x_2$ 的时候做的减法运算<strong>可能是负数</strong>，负数取模就出事了。</p><p>那如何解决呢？其实很简单，只需要在取模之前再加上一个 $1000000007$ 就可以了。</p><p>$Code$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,k,x1,x2,Max=<span class="number">1</span>;</span><br><span class="line">ll dp[<span class="number">100005</span>],sum[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;t,&amp;k);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x1,&amp;x2);</span><br><span class="line">        <span class="keyword">if</span>(Max&gt;=x2)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(sum[x2]-sum[x1<span class="number">-1</span>]+<span class="number">1000000007</span>)%<span class="number">1000000007</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Max;i&lt;=x2;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;k)</span><br><span class="line">                dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==k)</span><br><span class="line">                dp[i]=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i]=(dp[i<span class="number">-1</span>]+dp[i-k])%<span class="number">1000000007</span>;</span><br><span class="line">            sum[i]=(sum[i<span class="number">-1</span>]+dp[i])%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(sum[x2]-sum[x1<span class="number">-1</span>]+<span class="number">1000000007</span>)%<span class="number">1000000007</span>);</span><br><span class="line">        Max=x2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于A了！www</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 递推，递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度算法学习笔记</title>
      <link href="/posts/High-Accuracy-Algorithm/"/>
      <url>/posts/High-Accuracy-Algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>之前做题，有时候会听到老师说：“这道题数据很大，要高精度。”</p><p>有些题的数据范围可以毒瘤到连开挂神器 <code>__int128</code> 都救不了你，这个时候我们就会选择：</p><p>让电脑跟我们人一样计算！毕竟人只要时间够，不管多大的数都是可以算出来的。</p><p>这就是高精度算法。</p><span id="more"></span><hr><h2 id="高精度的那些板子计算"><a href="#高精度的那些板子计算" class="headerlink" title="高精度的那些板子计算"></a>高精度的那些板子计算</h2><p>说句闲话：高精度算法需要使用到 $string$ 类型的字符串，这里不提，请自行 BDFS。</p><h3 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1.高精度加法"></a>1.高精度加法</h3><p>要做高精度，首先需要了解人是怎么算的。</p><p><del>小学一年级内容出现了！（雾，大雾，伦敦雾</del></p><p>$$\ \ \ \ \ \ \ \ \ \ 3\ 2\ 8$$<br>$$+\ \ \ \ \ \ \ 1\ 3\ 7$$</p><script type="math/tex; mode=display">————————</script><p>$$\ \ \ \ \ \ \ \ \ \ 4\ 6\ 5$$</p><p>先看以上算式：</p><p>第一步：从低位往高位算，$8+7=15$。末位为5，往前进一位。</p><p><code>ans 0 1 5</code></p><p>第二步：算十位，$2+3+1=6$（1为进位），十位为6，不进位。</p><p><code>ans 0 6 5</code></p><p>第三步：算最高位，$3+1=4$，最高位为4。</p><p><code>ans 4 6 5</code></p><p>ans就是最终的答案了。</p><p>但是有个问题：上面这个例子两个加数的位数是一样的，那要是不一样呢？程序不就弄错了吗？</p><p>解决方法很简单：把两个加数倒着存就行了，这样因为数组初始化的原因，后面的数都会变成0，即会在前面自动补0。最后算出来的答案也是倒着的，再进行处理。</p><p>具体过程如下：<del>(没错我又在水博客了，巨佬们直接跳过吧【滑稽】)</del></p><p>1.倒序存储<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 8 2 3</span><br><span class="line">b 7 3 1</span><br><span class="line">c 0 0 0</span><br></pre></td></tr></table></figure><br>2.算第一位，进位直接存在下一位中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 8 2 3</span><br><span class="line">b 7 3 1</span><br><span class="line">c 5 1 0</span><br></pre></td></tr></table></figure><br>3.继续算，记得加上数组里本来就有的值（即进位）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 8 2 3</span><br><span class="line">b 7 3 1</span><br><span class="line">c 5 6 0</span><br></pre></td></tr></table></figure><br>4.一直循环，直到最后算完出结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 8 2 3</span><br><span class="line">b 7 3 1</span><br><span class="line">c 5 6 4</span><br></pre></td></tr></table></figure><br>5.把答案倒过来输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 6 4 --&gt; 465</span><br></pre></td></tr></table></figure></p><p>这样就是一个不完整的高精度加法的过程。</p><p>为什么不完整呢？因为程序可能会在计算位数的时候出错（程序会把和的位数计算为加数中位数较大的那一个数的位数+1，但是不一定会进位），所以在结束计算之后，需要判断和的第一位是否为0，如果是就需要去除。</p><p>这就完整了！</p><p>最后给出一份有注释的高精度加法板子代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5005</span>],b[<span class="number">5005</span>],c[<span class="number">5005</span>];<span class="comment">//定义全局，即初始化为0 </span></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a1,string b1)</span></span>&#123;</span><br><span class="line">    <span class="comment">//前置工作 </span></span><br><span class="line">    string c1;</span><br><span class="line">    <span class="keyword">int</span> lena=a1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lenb=b1.<span class="built_in">size</span>(); </span><br><span class="line">    <span class="comment">//倒序存储并转换为整数类型 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena;i++)&#123;</span><br><span class="line">        a[lena-i]=a1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenb;i++)&#123;</span><br><span class="line">        b[lenb-i]=b1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//做加法</span></span><br><span class="line">    <span class="keyword">int</span> lenc=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//做加法的次数为两个高精度数中较大的位数 </span></span><br><span class="line">    <span class="keyword">while</span>(lenc&lt;=lena||lenc&lt;=lenb)&#123;</span><br><span class="line">        c[lenc]+=a[lenc]+b[lenc]; <span class="comment">//加法 </span></span><br><span class="line">        c[lenc+<span class="number">1</span>]=c[lenc]/<span class="number">10</span>;     <span class="comment">//进位 </span></span><br><span class="line">        c[lenc]%=<span class="number">10</span>;              <span class="comment">//取个位 </span></span><br><span class="line">        lenc++; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">if</span>(!c[lenc])</span><br><span class="line">        lenc--;</span><br><span class="line">    <span class="comment">//把c存到c1里面</span></span><br><span class="line">    <span class="keyword">while</span>(lenc&gt;=<span class="number">1</span>)</span><br><span class="line">        c1+=c[lenc--]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a1,b1;</span><br><span class="line">    cin&gt;&gt;a1;</span><br><span class="line">    cin&gt;&gt;b1;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(a1,b1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="2-高精度减法"><a href="#2-高精度减法" class="headerlink" title="2.高精度减法"></a>2.高精度减法</h3><p>思路和高精度加法差不多，就是把进位换成退位，每次退位就让当前位数上的数加上10，然后让前面那个位数的答案-1。要注意前导0可能不止一个，需要连续去除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5005</span>],b[<span class="number">5005</span>],c[<span class="number">5005</span>];</span><br><span class="line"><span class="function">string <span class="title">sub</span><span class="params">(string a1,string b1)</span></span>&#123;</span><br><span class="line">    <span class="comment">//前置工作</span></span><br><span class="line">    <span class="keyword">if</span>(a1==b1)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string c1;</span><br><span class="line">    <span class="keyword">int</span> lena=a1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lenb=b1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//倒序存储并转换为整数类型 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena;i++)&#123;</span><br><span class="line">        a[lena-i]=a1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenb;i++)&#123;</span><br><span class="line">        b[lenb-i]=b1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//做减法</span></span><br><span class="line">    <span class="keyword">int</span> lenc=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//做减法的次数为两个高精度数中较大的位数 </span></span><br><span class="line">    <span class="keyword">while</span>(lenc&lt;=lena||lenc&lt;=lenb)&#123;</span><br><span class="line">        c[lenc]+=a[lenc]-b[lenc]; <span class="comment">//减法</span></span><br><span class="line">        <span class="keyword">if</span>(c[lenc]&lt;<span class="number">0</span>)&#123;            <span class="comment">//退位</span></span><br><span class="line">            c[lenc]+=<span class="number">10</span>;      <span class="comment">//借位</span></span><br><span class="line">            c[lenc+<span class="number">1</span>]=<span class="number">-1</span>;     <span class="comment">//前面的要-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        lenc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">while</span>(!c[lenc])</span><br><span class="line">        lenc--;</span><br><span class="line">    <span class="comment">//把c存到c1里面</span></span><br><span class="line">    <span class="keyword">while</span>(lenc&gt;=<span class="number">1</span>)</span><br><span class="line">        c1+=c[lenc--]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a1,b1;</span><br><span class="line">    cin&gt;&gt;a1;</span><br><span class="line">    cin&gt;&gt;b1;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sub</span>(a1,b1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-高精度乘法"><a href="#3-高精度乘法" class="headerlink" title="3.高精度乘法"></a>3.高精度乘法</h3><p>这个就有点意思了。</p><p>再来看一个竖式：</p><p>$$\ \ \ \ \ \ \ \ 1\ 5\ 3$$<br>$$\times\ \ \ \ \ \ \ \ 2\ 7$$</p><script type="math/tex; mode=display">————————</script><p>$$\ \ \ \ \ \ 1\ 0\ 7\ 1$$<br>$$\ \ \ 3\ 0\ 6$$</p><script type="math/tex; mode=display">————————</script><p>$$\ \ \ \ \ \ 4 \ 1\ 3\ 1$$</p><p>乘法又是怎么算的呢？</p><p>根据日常经验，我们能很快发现：需要先将一个数拆掉，一位一位去乘另一个数，然后把结果加起来，不过加起来的时候需要乘以10^{最小位数-1}。</p><p>那事情就变得容易了起来，一个双重循环，每一次循环让被拆掉的那个数的每一位乘以另一个数，加在答案里，进位和加法差不多，不过要注意进位可能不止一位。</p><p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5005</span>],b[<span class="number">5005</span>],c[<span class="number">10005</span>];</span><br><span class="line"><span class="function">string <span class="title">mul</span><span class="params">(string a1,string b1)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果有数为0直接返回0 </span></span><br><span class="line">    <span class="keyword">if</span>(a1==<span class="string">&quot;0&quot;</span>||b1==<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="comment">//前置工作</span></span><br><span class="line">    string c1;</span><br><span class="line">    <span class="keyword">int</span> lena=a1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lenb=b1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//倒序存储并转换为整数类型 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena;i++)&#123;</span><br><span class="line">        a[lena-i]=a1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenb;i++)&#123;</span><br><span class="line">        b[lenb-i]=b1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//做乘法</span></span><br><span class="line">    <span class="keyword">int</span> lenc;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">            lenc=i+j<span class="number">-1</span>;            <span class="comment">//存进去的位数 </span></span><br><span class="line">            c[lenc]+=a[i]*b[j];    <span class="comment">//乘法 </span></span><br><span class="line">            c[lenc+<span class="number">1</span>]+=c[lenc]/<span class="number">10</span>; <span class="comment">//进位 </span></span><br><span class="line">            c[lenc]%=<span class="number">10</span>;           <span class="comment">//取个位 </span></span><br><span class="line">            lenc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lenc=lena+lenb;</span><br><span class="line">    <span class="comment">//去除前导0 </span></span><br><span class="line">    <span class="keyword">while</span>(!c[lenc])</span><br><span class="line">        lenc--;</span><br><span class="line">    <span class="comment">//把c存到c1里面</span></span><br><span class="line">    <span class="keyword">while</span>(lenc&gt;=<span class="number">1</span>)</span><br><span class="line">        c1+=c[lenc--]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a1,b1;</span><br><span class="line">    cin&gt;&gt;a1;</span><br><span class="line">    cin&gt;&gt;b1;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">mul</span>(a1,b1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p><hr><h3 id="4-高精度除法之高精除以低精"><a href="#4-高精度除法之高精除以低精" class="headerlink" title="4.高精度除法之高精除以低精"></a>4.高精度除法之高精除以低精</h3><p>没学高精度之前一直不知道为什么要把除法分成两个部分，学了之后才发现这难度根本不是一个级别的！awa</p><p>首先还是思考人是怎么列竖式做除法的。你们自己脑补一个竖式吧。(ˉ▽ˉ；)…</p><p>做除法的步骤是：</p><ol><li>用现在判断到这一位之前的数除以除数，把商存在答案中；</li><li>计算余数；</li><li>循环1~2，直到判断完毕。</li></ol><p>这应该是一个很正确的思路，但是其实它本来是对的，但是放到程序里就错了。</p><p>为什么呢？</p><p>首先除以除数（第一步）的代码是这个样子的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[i]=(a[i]+c[i])/b;</span><br></pre></td></tr></table></figure><p>第二步求余数的代码是这个样子的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[i+<span class="number">1</span>]=(a[i]+c[i])%b*<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>很容易注意到，在执行第一步操作的时候，$c[i]$的值会发生改变，但是求余数需要用到的$c[i]$却必须是原来的值。</p><p>所以在代码的实现中，要先求余数再求商。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10005</span>],b,c[<span class="number">10005</span>];</span><br><span class="line"><span class="function">string <span class="title">div</span><span class="params">(string a1,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a1==<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="comment">//前置工作</span></span><br><span class="line">    string c1;</span><br><span class="line">    <span class="keyword">int</span> lena=a1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//转换为整数类型 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena;i++)&#123;</span><br><span class="line">        a[i+<span class="number">1</span>]=a1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;%d&quot;,a[i+1]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">※错点：一定要先求下一位余了多少再求现在的位数，</span></span><br><span class="line"><span class="comment">因为求现在的位数时c[i]的值会更新 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">        c[i+<span class="number">1</span>]=(a[i]+c[i])%b*<span class="number">10</span>; <span class="comment">//求下一位余了多少 </span></span><br><span class="line">        c[i]=(a[i]+c[i])/b;      <span class="comment">//计算当前位数的值 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> lenc=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!c[lenc])</span><br><span class="line">        lenc++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lenc;i&lt;=lena;i++)</span><br><span class="line">        c1+=c[i]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a1;</span><br><span class="line">    cin&gt;&gt;a1;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">div</span>(a1,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-高精度除法之高精除以高精"><a href="#5-高精度除法之高精除以高精" class="headerlink" title="5.高精度除法之高精除以高精"></a>5.高精度除法之高精除以高精</h3><p>emmm……</p><p>直到现在我的高精除高精还是没写出来啊╮(╯▽╰)╭，因为我感觉这个程序不是bug太多，而是整个程序就是一个bug……</p><p>先看思路。</p><p>首先高精除高精是不能像低精除法那样直接除的（不然请你告诉我怎么除），这里采取的方式是：用减法模拟除法。</p><p>设置一个变量$flag$，代表现在判断到了第几位。在这一位以及这一位之前组成的数就是被减数，除数就是减数。判断一下两个数之间还能否相减（即被减数是否还大于减数），如果不行了就判断下一位，如果还可以就继续减，直到不能减为止。</p><p>说得简单，这玩意儿实现起来超级无敌难的。</p><p>我的代码一直都是 $\texttt{TLE}\ 10$ 分，不过思路应该是对的，也拿出来给大家看一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个bug比头发还多的高精除高精代码 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5005</span>],b[<span class="number">5005</span>],c[<span class="number">5005</span>],d[<span class="number">5005</span>];</span><br><span class="line"><span class="comment">//这是判断是否还能减的函数 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> flag,<span class="keyword">int</span> lena,<span class="keyword">int</span> lenb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag&lt;lenb)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//统计前面有多少个前导0 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lena;i&gt;=flag;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a[i])</span><br><span class="line">            sum++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag-sum&lt;lenb)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag-sum&gt;lenb)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//对于位数一样的数，判断是否可减</span></span><br><span class="line">    <span class="keyword">bool</span> f=<span class="number">1</span>;<span class="comment">//是否完全相等 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lena-sum;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])</span><br><span class="line">            f=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">div</span><span class="params">(string a1,string b1)</span></span>&#123;</span><br><span class="line">    <span class="comment">//前置工作</span></span><br><span class="line">    <span class="keyword">if</span>(a1==<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string c1;</span><br><span class="line">    <span class="keyword">int</span> lena=a1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lenb=b1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//倒序存储并转换为整数类型 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena;i++)&#123;</span><br><span class="line">        a[lena-i]=a1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenb;i++)&#123;</span><br><span class="line">        b[lenb-i]=b1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始用减法模拟除法</span></span><br><span class="line">    <span class="keyword">int</span> flag=lena;<span class="comment">//指针，现在到第几位了 </span></span><br><span class="line">    <span class="keyword">int</span> lenc=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,flag);</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(flag,lena,lenb))&#123;<span class="comment">//现在a已经小于b，需要进行下一位的除法 </span></span><br><span class="line">            a[flag]=<span class="number">0</span>;</span><br><span class="line">            flag--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//a还未小于b，继续减 </span></span><br><span class="line">            <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">            <span class="keyword">int</span> lend=flag;</span><br><span class="line">            <span class="keyword">while</span>(lend&lt;=lena||lend&lt;=lenb)&#123;</span><br><span class="line">                d[lend]+=a[lend]-b[lend];</span><br><span class="line">                <span class="keyword">if</span>(d[lend]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    d[lend]+=<span class="number">10</span>;</span><br><span class="line">                    d[lend+<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                lend++;</span><br><span class="line">            &#125;</span><br><span class="line">            lenc++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=flag;i&lt;=lena;i++)</span><br><span class="line">                a[i]=d[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">while</span>(!c[lenc])</span><br><span class="line">        lenc--;</span><br><span class="line">    <span class="comment">//把c存到c1里面</span></span><br><span class="line">    <span class="keyword">while</span>(lenc&gt;=<span class="number">1</span>)</span><br><span class="line">        c1+=c[lenc--]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a1,b1;</span><br><span class="line">    cin&gt;&gt;a1;</span><br><span class="line">    cin&gt;&gt;b1;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">div</span>(a1,b1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>（我那个 $10$ 分估计是特判 $0$​ 得的？）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书的复制 题解</title>
      <link href="/posts/Solution-P1281/"/>
      <url>/posts/Solution-P1281/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1281">题目传送门</a></p><p>第一道独立做出来的绿题祭（虽然花了我将近一个小时）</p><span id="more"></span><p>这是一道二分题目。</p><h3 id="为了方便："><a href="#为了方便：" class="headerlink" title="为了方便："></a>为了方便：</h3><p>因为这道题没有明确的规定抄书时间（反正不影响结果），所以我们不妨假设一个人抄一页需要 $1$ 分钟。</p><h3 id="确定二分范围"><a href="#确定二分范围" class="headerlink" title="确定二分范围"></a>确定二分范围</h3><p>确定一下二分的范围：</p><p>最优情况：每个人都只抄一本，需要的时间为页数最大的那一本所需时间。</p><p>最坏情况：一个人要把所有书抄完，需要的时间为所有书加在一起的时间。</p><p>所以二分的范围就是从最大值到和。</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>然后二分函数开始验证，注意验证的是当只给那么多时间的时候这些人可不可以完成抄写任务。二分的地方很简单，主要的部分其实是输出答案那一部分和 $check$ 函数。</p><p>首先先来看输出答案那一部分。</p><p>注意题目中的一句话：</p><blockquote><p>如果有多解，则尽可能让前面的人抄写少的页数。</p></blockquote><p>定义 $l$ 为需要的最小时间（也就是二分出来的答案）。</p><p>因为要求让前面的人抄得尽量少，意思就是说让后面的人抄得尽量多（这个点一定要倒着想，如果是从前到后的话需要搜索，这样会 TLE）。那么就写一个循环，只要这个人现在抄的时间不超过 $l$，就让他一直抄，直到再加上一个就会超过为止，这样就可以保证后面的人抄得最多。</p><p>打一个有注释的代码（输出部分）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag=n,c=<span class="number">0</span>;<span class="comment">//flag代表目前拿到的书的编号，c代表现在这个人抄的时间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">1</span>;i--)&#123;<span class="comment">//枚举每一个人，要倒着枚举</span></span><br><span class="line">    <span class="keyword">while</span>(c+a[flag]&lt;=l&amp;&amp;flag)&#123;<span class="comment">//可以继续抄且有书可抄</span></span><br><span class="line">        c+=a[flag];<span class="comment">//这个人抄的时间增加</span></span><br><span class="line">        flag--;<span class="comment">//枚举下一本书</span></span><br><span class="line">    &#125;</span><br><span class="line">    s[i]=flag+<span class="number">1</span>;<span class="comment">//这个人抄完了，存一下开始的编号</span></span><br><span class="line">    c=<span class="number">0</span>;<span class="comment">//清空时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k<span class="number">-1</span>;i++)&#123;<span class="comment">//输出：这个人抄书的结束点一定是下一个人的开始点-1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,s[i],s[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,s[k],n);<span class="comment">//最后一个人的结束点是n，需要单独考虑</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//输出后直接结束程序</span></span><br></pre></td></tr></table></figure><p>然后再看有关 $check$ 函数的那一部分。</p><p>本人采取的方法是：让每本书都被抄到，看在此时间内能否用小于等于 $k$ 个人完成任务。如果可以，就往小的部分二分，反之往大的方向二分。</p><p>写一下 $check$ 函数（也是一个有注释的代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//x为当前判断的时间长度</span></span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">1</span>,c=<span class="number">0</span>;<span class="comment">//r：需要的人数 c：这个人当前抄书的时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c+a[i]&lt;=x)<span class="comment">//可以继续抄这本书</span></span><br><span class="line">            c+=a[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//需要换下一个人抄这本书</span></span><br><span class="line">            r++;</span><br><span class="line">            c=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=k)<span class="comment">//答案是否小于等于总人数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个问题：关于有人没活可以干"><a href="#一个问题：关于有人没活可以干" class="headerlink" title="一个问题：关于有人没活可以干"></a>一个问题：关于有人没活可以干</h3><p>那么现在你可能会问一个问题了：题目中不是还有这么一句话吗？</p><blockquote><p>且每个人都必须抄写。</p></blockquote><p>你咋不判断呢？</p><p>那么我们来分析一下：</p><p>首先题目对人数有个要求：$k≤m≤500$</p><p>可见总人数是小于书的本数的。那么可以发现为了达到最短的时间，每个人都必须抄书，也就是说，最优解情况一定是每个人都会抄的。</p><p>可以证明这一点：假设有人没抄，现在必然有人的抄书时间是等于总用时的，如果耗时最大的人只抄了一本书，那么这个没抄的人可以去找一个抄多本书去“借”一本（题目的数据保证了如果有人没抄，那一定会有抄多本书的人），反正也不会影响结果。如果耗时最大的人抄了不止一本书，那么这个人可以帮他“分摊任务”，这样可以减小总用时，说明这一定不是最佳方案。可以得出：最优解一定是所有人都会抄书的。</p><p>洛谷的题目已经修正了不存在这种情况，但是鉴于我们 OJ 的毒瘤数据还是需要考虑一下这个点。<del>当然你没考虑到也能 AC。</del></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,sum,a[<span class="number">505</span>],s[<span class="number">505</span>];<span class="comment">//sum是页数的和，s是输出的答案</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">1</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c+a[i]&lt;=x)</span><br><span class="line">            c+=a[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r++;</span><br><span class="line">            c=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=k)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;<span class="comment">//已经找到满足条件的页数 </span></span><br><span class="line">        <span class="comment">//计算与输出结果</span></span><br><span class="line">        <span class="keyword">int</span> flag=n,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(c+a[flag]&lt;=l&amp;&amp;flag)&#123;</span><br><span class="line">                c+=a[flag];</span><br><span class="line">                flag--;</span><br><span class="line">            &#125;</span><br><span class="line">            s[i]=flag+<span class="number">1</span>;</span><br><span class="line">            c=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,s[i],s[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,s[k],n);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        <span class="built_in">f</span>(l,mid);<span class="comment">//因为答案就有可能是mid所以mid不能-1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">f</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=INT_MIN;<span class="comment">//y为最大值</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        y=<span class="built_in">max</span>(y,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">f</span>(y,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.3.13 考试总结</title>
      <link href="/posts/2021-3-13-%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/posts/2021-3-13-%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>今天是2021年3月13日，mjl 告诉我们，今天要考搜索。</p><p>我们：什么玩意儿？？？Σ(っ °Д °;)っ</p><span id="more"></span><p>本人最终成绩：$0+0+70+0+86+10=166$</p><p><del>反正就是挺无语的 qwq。</del></p><p>废话不多说，接下来直接进入</p><h2 id="题解时间"><a href="#题解时间" class="headerlink" title="题解时间"></a>题解时间</h2><hr><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="http://222.180.160.110:1024/contest/1384/problem/1">T1</a></h3><blockquote><p>某班的学生订了 $N$ 天的午餐，知道他们每天要花多少钱。每天班主任可以选择自己支付或使用班费支付当天午餐费。班主任希望尽可能多地花掉班费，请你帮他计算他最多能够花多少班费。<strong>输入包含多个测试数据</strong>（不超过 $50$ 个）。$1\leq N\leq 30$，$0\leq M\leq 10^7$。</p></blockquote><p>《论考试不看题不加多组输入考后直接崩掉》</p><p><del>但是其实就是加了估计也要爆零，只是从 WA 变成 TLE 而已。</del></p><p>这就是一道简化版的 The Robbery（考试题目少了一个较为复杂的优化），这里再简单提一下。</p><p>基础的搜索很简单，就是在搜索每一天的情况时继续搜索用班费支付和自己支付两种情况。</p><p>接下来是剪枝：</p><p>首先是排序，按照从大到小排，因为根据简单的贪心思维，先选大的取到最优解的可能性更大。</p><p>然后再求一下后缀和，如果在某个情况时前面已经选了的和后面所有没有选的还小于当前最大值，就直接 <code>return</code>。（最优性剪枝）</p><p>最后还要注意一下，因为是多组输入，所以统计后缀和的数组需要清空一下。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> m,n,a[<span class="number">35</span>],ans=<span class="number">0</span>,hzh[<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum+hzh[t]&lt;ans||sum&gt;m)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(t==n+<span class="number">1</span>)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用班费</span></span><br><span class="line">    <span class="keyword">if</span>(sum+a[t]&lt;=m)<span class="built_in">dfs</span>(t+<span class="number">1</span>,sum+a[t]); </span><br><span class="line">    <span class="comment">//不用班费 </span></span><br><span class="line">    <span class="built_in">dfs</span>(t+<span class="number">1</span>,sum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;lunch.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;lunch.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            hzh[i]=hzh[i+<span class="number">1</span>]+a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(hzh,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(hzh));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="https://www.luogu.com.cn/problem/P4160">T2</a></h3><blockquote><p>有一个 $X\times Y$ 的矩形蛋糕，要分成 $N$ 个面积相同的小块。每一切只能平行于一块蛋糕的一边（任意一边），并且必须把这块蛋糕切成两块。要求 $N$ 块蛋糕的长边与短边的比值的最大值最小。请求出这个比值，输出保留六位小数。$1\le X,Y\le 10000$，$1\le N\le 10$。</p></blockquote><p>这道题主要难在思路（其实也不难），思路出来了基本上就没多大问题了。</p><p>这道题目看起来是个二分，但只要稍微冷静地分析一下就会发现这道题不能用二分，再想一下（<del>其实是因为这是一次搜索测试啦</del>），这道题是可以用 DFS 解决的，其思路和巧克力棒差不多。</p><p>首先我们假设这是一块长为 $x$ 宽为 $y$ 的蛋糕，需要把它分给 $n$ 个人。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/f234et1f.png" alt="" title="这是一块蛋糕"></p><p>我们可以横着切（平行于 $X$ 轴）或者竖着切（平行于 $Y$ 轴）。那么切哪里呢？</p><p>因为我们要把这个蛋糕分给 $n$ 个人，所以我们就切这条边可以被 $n$ 整除的地方。如图。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/b3crgfsv.png" alt="" title="蛋糕上可以切的地方"></p><p>最后我们来看一下出口：假如说这个 $n=1$ 了，就说明不需要再切了，这个时候我们返回一下长与宽的比值。</p><p>（特别注意：最大比例的最小值，不要把 $\max$ 和 $\min$ 用反了）</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">double</span> bzmax=INT_MAX;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">max</span>(x,y)*<span class="number">1.0</span>/<span class="built_in">min</span>(x,y);</span><br><span class="line">    <span class="keyword">double</span> bzmax=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;<span class="comment">//因为切上面和下面都是一样的，所以只用切一半</span></span><br><span class="line">        bzmax=<span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">dfs</span>(x,i*y/n,i),<span class="built_in">dfs</span>(x,y-i*y/n,n-i)),bzmax);<span class="comment">//x</span></span><br><span class="line">        bzmax=<span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">dfs</span>(i*x/n,y,i),<span class="built_in">dfs</span>(x-i*x/n,y,n-i)),bzmax);<span class="comment">//y</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bzmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;birthday.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;birthday.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">int</span> x,y,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;y,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>,<span class="built_in">dfs</span>(x,y,n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="http://222.180.160.110:1024/contest/1384/problem/3">T3</a></h3><blockquote><p>有一个纸片上的数和一个给定的目标数，你需要把纸片切成若干片，要求切出来的每一个数字加起来不超过目标数且与目标数最接近。如果目标数和输入纸片上的数相同，那么纸片不进行切割，如果不论怎样切割，分割得到的纸片上数的和都大于目标数，那么输出错误信息。如果有多种不同的切割方式可以得到相同的最优结果。那么输出拒绝服务信息。你需要给出对纸片的分割方式。<strong>输入包括多组数据。</strong><br>对每一组输入数据，输出相应的输出。有三种不同的输出结果：</p><ul><li><code>sum part1 part2 ...</code>（*切割方案） </li><li><code>rejected</code> （*拒绝服务）</li><li><code>error</code> （*错误信息）</li></ul></blockquote><p>题面很长，但是实质就是添加号问题。</p><p>不过添加号真的很难 awa，<del>再加上本人没做对</del>，所以这里就不详细讲了，<del>添加号在我第一周改对了之后直到第二周都还停留在考试的 70 分。</del></p><p>考试 70 分代码（样例倒数第二个有未知玄学错误，大家看看思路就行了）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> s,tot=<span class="number">0</span>,len,ans=<span class="number">0</span>,js=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> paper[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8</span>],b[<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> sum,<span class="keyword">int</span> last)</span></span>&#123;<span class="comment">//判断t和t+1之间的部分 last：上一个数 </span></span><br><span class="line">    <span class="keyword">if</span>(sum+last&gt;s)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(t==len+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;ans)&#123;</span><br><span class="line">            tot=<span class="number">1</span>,ans=sum;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">            <span class="keyword">while</span>(a[i])b[i]=a[i],i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum==ans)tot++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//切割</span></span><br><span class="line">    a[js]=last*<span class="number">10</span>+paper[t]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    js++;</span><br><span class="line">    <span class="built_in">dfs</span>(t+<span class="number">1</span>,sum+last*<span class="number">10</span>+paper[t]-<span class="string">&#x27;0&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    a[js]=<span class="number">0</span>;</span><br><span class="line">    js--;</span><br><span class="line">    <span class="comment">//不切割 </span></span><br><span class="line">    <span class="built_in">dfs</span>(t+<span class="number">1</span>,sum,last*<span class="number">10</span>+paper[t]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;paper.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;paper.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>,&amp;s,paper+<span class="number">1</span>);</span><br><span class="line">        len=<span class="built_in">strlen</span>(paper+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!s&amp;&amp;paper[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(tot&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rejected\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans);</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(b[i])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">        tot=<span class="number">0</span>,ans=<span class="number">0</span>,js=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a><a href="http://222.180.160.110:1024/contest/1384/problem/4">T4</a></h3><blockquote><p>给出两个单词（开始单词和结束单词）以及一个词典。找出从开始单词转换到结束单词，所需要的最短转换序列。转换的规则如下：</p><ol><li>每次只能改变一个字母。</li><li>转换过程中出现的单词（除开始单词和结束单词）必须存在于词典中，开始单词和结束单词可以不在词典中。如果不能找到这种变换，则输出 <code>0</code>。</li></ol></blockquote><p><del>《论一个人考试不记得字符串的操作函数然后直接原地爆炸的详细过程》</del></p><p>其实这道题应该不用这些奇奇怪怪的函数也可以做，但是当时看到这道题貌似有点难，想了一会儿思路没出来就去看别的题了。</p><p>其实这道题我们可以每一次都统计一下哪些单词和当前的单词可以转换然后在用新的单词继续搜索。</p><p>注意一个优化（最优性剪枝），不然会 TLE：</p><p>拿一个数组存一下从初始单词到这个单词需要多少步，如果现在我们递归到这个单词时的步数已经大于最优的步数就直接 <code>return</code>。</p><p>其实这道题可以用 BFS 做而且据说还好做一点，但是我考试是这么做的就这么写题解吧。</p><p>AC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> len,n,Min=INT_MAX;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">1005</span>][<span class="number">10</span>],end[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];<span class="comment">//记忆化数组，表示从开头到这个单词至少需要几步 </span></span><br><span class="line"><span class="comment">//判断两个单词是否可以互相转换的 check 函数 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[x][i]!=a[y][i])sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dfs 函数 t：需要操作的字符串 l：目前操作的步数 bh：需要操作字符串的编号 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span> t[<span class="number">10</span>],<span class="keyword">int</span> l,<span class="keyword">int</span> bh)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;%s %d %d\n&quot;,t,l,bh);</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;=Min||dp[bh]&amp;&amp;l&gt;=dp[bh])<span class="keyword">return</span>;</span><br><span class="line">    dp[bh]=l;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(bh,n+<span class="number">1</span>))&#123; <span class="comment">// 两个字符串只有一个字符不一样 </span></span><br><span class="line">        Min=<span class="built_in">min</span>(Min,l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==n)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!b[i]&amp;&amp;<span class="built_in">check</span>(bh,i))&#123;</span><br><span class="line">            b[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(a[i]+<span class="number">1</span>,l+<span class="number">1</span>,i);</span><br><span class="line">            b[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;word.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;word.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>,a[<span class="number">0</span>]+<span class="number">1</span>,end+<span class="number">1</span>);</span><br><span class="line">    len=<span class="built_in">strlen</span>(end+<span class="number">1</span>);</span><br><span class="line">    n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a[n]+<span class="number">1</span>)!=EOF)n++;</span><br><span class="line">    <span class="built_in">strcpy</span>(a[n+<span class="number">1</span>]+<span class="number">1</span>,end+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(a[<span class="number">0</span>]+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Min);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a><a href="http://222.180.160.110:1024/contest/1384/problem/5">T5</a></h3><blockquote><p>在一个 $n$ 行 $m$ 列单元格构成的地图中，每一个格子里都有可能是空地（<code>.</code>），墙（<code>#</code>）或者僵尸（<code>G</code>），且四边肯定是墙。若放置一个炸弹，它会以放置点为中心进行行列延伸炸到同行同列的僵尸，但不能穿墙。<br>有一个人去放一个炸弹，他初始位置在 $(x,y)$，只能在地图中朝上下左右四个方向行进，不能穿墙，也不能穿越僵尸。求最多能炸到的僵尸数量。</p></blockquote><p>考场上打了个广搜+记忆化得了 $80$ 分，后来讲题的时候 mjl 说：</p><blockquote><p>在两堵墙之间，横向或纵向能炸到僵尸的数量相同。</p></blockquote><p>然后我就很 zz 的在函数里面加上了这个优化……</p><p><del>最终从 80 掉到了 75。</del></p><p>后来我去问 mjl，他给我看了个 AC 代码……<del>（这玩意儿还是要加在主函数里的？！）</del></p><p>AC 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> dp1[<span class="number">2005</span>][<span class="number">2005</span>],dp2[<span class="number">2005</span>][<span class="number">2005</span>],dp3[<span class="number">2005</span>][<span class="number">2005</span>],dp4[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> m,n,x,y,ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;s&gt; q;</span><br><span class="line">    t1.x=x,t1.y=y;</span><br><span class="line">    q.<span class="built_in">push</span>(t1);</span><br><span class="line">    <span class="keyword">int</span> dx,dy;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        t1=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            dx=t1.x+dir[i][<span class="number">0</span>],dy=t1.y+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dx&gt;=<span class="number">1</span>&amp;&amp;dx&lt;=m&amp;&amp;dy&gt;=<span class="number">1</span>&amp;&amp;dy&lt;=n&amp;&amp;!b[dx][dy]&amp;&amp;a[dx][dy]!=<span class="string">&#x27;#&#x27;</span>&amp;&amp;a[dx][dy]!=<span class="string">&#x27;G&#x27;</span>)&#123;</span><br><span class="line">                b[dx][dy]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp1[dx][dy]+dp2[dx][dy]+dp3[dx][dy]+dp4[dx][dy]&gt;ans)</span><br><span class="line">                ans=dp1[dx][dy]+dp2[dx][dy]+dp3[dx][dy]+dp4[dx][dy];</span><br><span class="line">                t2.x=dx,t2.y=dy;</span><br><span class="line">                q.<span class="built_in">push</span>(t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;zombie.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;zombie.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;m,&amp;n,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;G&#x27;</span>)&#123;</span><br><span class="line">                dp1[i][j]=dp1[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                dp2[i][j]=dp2[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp1[i][j]=dp1[i][j<span class="number">-1</span>];</span><br><span class="line">                dp2[i][j]=dp2[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                dp1[i][j]=<span class="number">0</span>;</span><br><span class="line">                dp2[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;G&#x27;</span>)&#123;</span><br><span class="line">                dp3[i][j]=dp3[i][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                dp4[i][j]=dp4[i+<span class="number">1</span>][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp3[i][j]=dp3[i][j+<span class="number">1</span>];</span><br><span class="line">                dp4[i][j]=dp4[i+<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                dp3[i][j]=<span class="number">0</span>;</span><br><span class="line">                dp4[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(x,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="T6"><a href="#T6" class="headerlink" title="T6"></a><a href="http://222.180.160.110:1024/contest/1384/problem/6">T6</a></h3><blockquote><p>一个人进入了一个两层的迷宫，迷宫的入口是 $S(0,0,0)$，里面有时空传输机（用 <code>#</code> 表示），墙（用 <code>*</code> 表示），平地（用 <code>.</code> 表示）。进入时空传输机会被转到另一层的相对位置，但如果被转到的位置是墙，他就会被撞死。他只能在一层中前后左右移动，每移动一格花 $1$ 时刻。层间的移动只能通过时空传输机，且不需要任何时间。如果他能在 $T$ 时刻及以前到 $P$ 点输出 <code>YES</code>，否则输出 <code>NO</code>。<strong>多组数据。</strong> $1 &lt;= N,M &lt;=10$。</p></blockquote><hr><p><del>其实我根本不知道自己考试的代码为什么会错，但是经过了代码的重构与 mjl 的帮助之后我 A 了这道题。</del></p><p>首先思路 BFS，其他的内容和走迷宫的 BFS 经典题目差不多，唯一的区别就是传送门，如果走到了传送门就传送到另外一层，并且这两个传送门都会走一遍。需要特别注意的是不要陷入上下两个都是传送门的死循环。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> m,n,T;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">15</span>][<span class="number">15</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">15</span>][<span class="number">15</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z,l;</span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="comment">//取相反数：0到1，1到0 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    queue&lt;s&gt; q;</span><br><span class="line">    t1.x=x,t1.y=y,t1.z=z,t1.l=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(t1);</span><br><span class="line">    <span class="keyword">int</span> dx,dy;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        t1=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//特判：#和P</span></span><br><span class="line">        <span class="keyword">if</span>(a[t1.x][t1.y][t1.z]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[t1.x][t1.y][<span class="built_in">f</span>(t1.z)]==<span class="string">&#x27;P&#x27;</span>||a[t1.x][t1.y][<span class="built_in">f</span>(t1.z)]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                t1.z=<span class="built_in">f</span>(t1.z);</span><br><span class="line">                q.<span class="built_in">push</span>(t1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[t1.x][t1.y][t1.z]==<span class="string">&#x27;P&#x27;</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            dx=t1.x+dir[i][<span class="number">0</span>],dy=t1.y+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dx&gt;=<span class="number">1</span>&amp;&amp;dx&lt;=m&amp;&amp;dy&gt;=<span class="number">1</span>&amp;&amp;dy&lt;=n&amp;&amp;a[dx][dy][t1.z]!=<span class="string">&#x27;*&#x27;</span>&amp;&amp;!b[dx][dy][t1.z])&#123;</span><br><span class="line">                b[dx][dy][t1.z]=<span class="number">1</span>;</span><br><span class="line">                t2.x=dx,t2.y=dy,t2.z=t1.z,t2.l=t1.l+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(t2.l&gt;T)<span class="keyword">continue</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;plan.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;plan.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="keyword">int</span> c,x,y,z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c);</span><br><span class="line">    <span class="keyword">while</span>(c--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;m,&amp;n,&amp;T);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a[i][j][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span>(a[i][j][<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)x=i,y=j,z=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a[i][j][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(a[i][j][<span class="number">1</span>]==<span class="string">&#x27;S&#x27;</span>)x=i,y=j,z=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">bfs</span>(x,y,z))<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结时间"><a href="#总结时间" class="headerlink" title="总结时间"></a>总结时间</h2><p>T1 没看到多组输入，以为就是道水题，看到题目的背景之后没有任何联想，也没有想到那道让我犹豫了很久的 The Robbery，导致一道本来会做的题丢掉 $100$ 分。</p><p>T2 本来这么水一道题也没有想到思路，这道题应该就是那种思路很难想，但是一想出来就很简单的那种题吧，得亏我们之前还做过一道类似的题目……</p><p>T3 出了一个 bug，然后我在那个地方调了很久，其实当时应该先把这个部分分拿到之后就先去看别的题目，因为 bug 不好说什么时候调得出来，可是有些题的部分分是很好得的……</p><p>T4 因为不会函数就直接跳过了，其实就相当于我又跳过了一道比较简单的题目，所以事实证明：</p><ol><li>函数不会不要虚，有时候手打函数比系统自带的还要快，比如说$\max$，$\min$ 等。</li><li>要背常用函数。</li></ol><p>T5 的话，还是优化方法没有完全掌握吧……平时刷题不够多。</p><p>T6 属于那种过完样例就走人行为，因为 $10$ 分的话确实太少了……</p><p>所以经过这次考试，可以发现：</p><ul><li>考试比赛如果题目比较难，骗分和部分分永远是王道（*＾-＾*）。</li><li>常用函数是一定要背的（而且不要被错），考试用节约时间，但是如果背不到也不要直接放弃题目，只要你手打得出来就继续做。（当然如果这道题做不出来就另当别论了！）</li><li>安排好考试时间，如果一道题有 bug，不管可不可以拿到一部分分，也先不要在这道题死磕（尤其是死磕超过一节课的时间），先去看一下别的题有没有思路了。</li><li>认真读题。尤其注意别漏了恶心人的多组输入。</li><li>要充分发挥自己的联想能力。要定期复习代码，不要以为 AC 了就万事大吉，这样考试的联想才能发挥作用。</li></ul><p>希望这篇博客可以帮助到大家（还有我自己），感谢观看！</p>]]></content>
      
      
      <categories>
          
          <category> 考试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包装箱 题解</title>
      <link href="/posts/Solution-%E6%89%93%E5%8C%85%E8%A3%85%E7%AE%B1/"/>
      <url>/posts/Solution-%E6%89%93%E5%8C%85%E8%A3%85%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>Update on 2021/10/1：修复了 $\LaTeX$ 格式。</p><hr><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p><a href="http://222.180.160.110:1024/problem/25184">原题链接（CQBZOJ）</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>学校组织了爱心捐书活动，同学们纷纷踊跃把自己看过的旧书拿出来捐给贫困山区的孩子们。图书室的马老师把同学们捐献的书打包在了6种纸箱子里（打包好的各类纸箱子有若干个），纸箱子的高相同，但底面积分为 $1\times 1$，$2\times 2$，$3\times 3$，$4\times 4$，$5\times 5$，$6\times 6$。现为了装车方便，需要把这些纸箱子装在若干个 $6\times 6$ 的木箱子，木箱子的高和打包纸箱子相同，请你帮助马老师，用最少的木箱子打包完所有的纸箱子。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>一行（六个数）用空格隔开，分别表示 $1\times 1$，$2\times 2$，$3\times 3$，$4\times 4$，$5\times 5$，$6\times 6$ 六类纸箱子的个数（每类箱子的个数小于等于 $100$）。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>一行，最少的木箱子个数</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 5 4 3 2 1</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><p><del>是的，为了我们“亲爱”的mjl，我把题目改了（（</del></p><hr><h3 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2.算法分析"></a>2.算法分析</h3><p>用最少的木箱子装完，也就是说让剩余的空间最小，最好的情况就是除了最后一个箱子，其他箱子都装满，所以只需要考虑箱子内部的情况。故这道题可以用贪心算法解决。</p><hr><h3 id="3-思路"><a href="#3-思路" class="headerlink" title="3.思路"></a>3.思路</h3><p>要解决箱子内部如何装满的问题，我们首先需要根据题目条件建立模型。题目告诉我们有六种不同的纸箱子和木箱子的大小，根据这些条件我们可以列出箱子内部装满时的模型如下（PS：最上面的那个数字指的是最大的那个纸箱子）：</p><p><img src="https://i.loli.net/2021/10/01/qXvrsB2TH1ZUFdy.png" alt="装进去的情况"></p><p>可以看出，在纸箱子的大小为 $3\times 3$ 时，情况比较多比较复杂，所以需要着重考虑。</p><p>需要注意的是，在装箱的时候我们会优先把所有 $3\times 3$ 的纸箱子装到一个木箱子里（即 $4$ 个 $3\times 3$ 的箱子装在一个木箱子里），所以剩下的那三种情况只需要判断一次。（我就是在这个地方栽的）</p><p>这里再补充两个编程的技巧（不想看请跳过）：</p><hr><h4 id="（1）向上取整"><a href="#（1）向上取整" class="headerlink" title="（1）向上取整"></a>（1）向上取整</h4><p>如果一个人问大家怎么向上取整的话，估计大多数人的回答应该都是用 <code>&lt;cmath&gt;</code> 头文件里的 <code>ceil</code> 函数。但是这多少有点麻烦，<del>如果你懒得写</del>为了方便，其实根本不需要什么函数，用整数除法就可以实现。</p><p>在 <code>c++</code> 中，整数的除法是默认为向下取整。我们假设 $n$ 可以被 $k$ 整除且 $n/k=q$，那么：</p><p> $(n+1)/k=q$</p><p> $(n+2)/k=q$</p><p> $……$</p><p> $(n+k-1)/k=q$</p><p> $(n+k)/k=q+1$</p><p>由此可以看出，如果我们要向上取整一个除法 $n/k$ （余数为 $r$ ），就需要把 $n$ 的范围提到 $n+(k-r)$ 到 $n+(k-r)+(k-1)$ 这个范围之内，而当这个被除数的加数取到 $k-1$ 的时候，不管余数怎么变，被除数永远都在这个范围。综上所述，向上取整的公式为：</p><p> $\lceil n/k \rceil=(n+k-1)/k$</p><hr><h4 id="（2）辅助数组——为“偷懒”而生"><a href="#（2）辅助数组——为“偷懒”而生" class="headerlink" title="（2）辅助数组——为“偷懒”而生"></a>（2）辅助数组——为“偷懒”而生</h4><p>在数的计算中，我们通常要根据结果的不同而使用不同的值。这个问题可以用条件选择语句解决，但是当情况太多的时候就会造成程序的内容繁杂。（而且写着也麻烦！）当一个计算结果与一个值可以一一对应的时候，我们就可以用辅助数组简化程序。</p><p>（注：如果数与值不是一一对应的，也可以使用辅助数组，但是一定是一个值对应一个结果（也就是说不同的结果可以对应同一个值），但是<del>在本人的学习范围之内</del>辅助数组不能同一个结果对应多个值。）</p><p>拿这道题举例，由于 $3\times 3$ 纸箱子的个数不一定能被 $4$ 整除，这也就意味着当个数除以 $4$ 的时候余数可能是 $0,1,2,3$，不同的值对应边长为 $2\times 2$的纸箱子在放有这些剩余的 $3\times 3$ 的箱子的木箱子中能放得下的不同个数，计算的结果与值一一对应。所以我们可以设置一个辅助数组 <code>cnt</code>，从 $0$ 到 $3$ 号位分别存储余数为 $0,1,2,3$ 的不同情况所对应的值，这样我们在使用这个值的时候就可以直接调用数组，不用写条件语句。</p><hr><h3 id="4-编写代码"><a href="#4-编写代码" class="headerlink" title="4.编写代码"></a>4.编写代码</h3><p>终于到了激动人心的时刻了!</p><p>AC 代码（不要复制，<del>但你要复制我也没办法</del>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;<span class="comment">//辅助数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1,a2,a3,a4,a5,a6,sum=<span class="number">0</span>,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d %d&quot;</span>,&amp;a1,&amp;a2,&amp;a3,&amp;a4,&amp;a5,&amp;a6);</span><br><span class="line">  <span class="comment">//边长为6，5，4，3的盒子需要的箱子数  </span></span><br><span class="line">    sum=a6+a5+a4+(a3+<span class="number">3</span>)/<span class="number">4</span>;</span><br><span class="line">  <span class="comment">//边长为2的盒子在已经装了的箱子中可以装的数量     </span></span><br><span class="line">    x=a4*<span class="number">5</span>+a3*cnt[a3%<span class="number">4</span>];              </span><br><span class="line">    <span class="keyword">if</span>(x&lt;a2)sum+=(a2-x+<span class="number">8</span>)/<span class="number">9</span>;</span><br><span class="line">    <span class="comment">//边长为1的盒子在已经装了的箱子中可以装的数量 </span></span><br><span class="line">    y=sum*<span class="number">36</span>-a6*<span class="number">36</span>-a5*<span class="number">25</span>-a4*<span class="number">16</span>-a3*<span class="number">9</span>-a2*<span class="number">4</span>;  </span><br><span class="line">    <span class="keyword">if</span>(y&lt;a1)sum+=(a1-y+<span class="number">35</span>)/<span class="number">36</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>这应该算是一道<del>对于本人来说</del>比较难的贪心，但是主要难在思路，代码不难，思路想出来题目就没多大问题了。</p><p>但是之前在做的时候一直是 $91$ 分，调了很久的代码才发现x在计算的时候 <code>cnt[a3%4]</code> 不需要乘<code>a[3]</code>，还是思路没有彻底理清楚 ,,ԾㅂԾ,,</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给Dev-C++设置黑暗模式</title>
      <link href="/posts/More-beautiful-Dev-Cplusplus/"/>
      <url>/posts/More-beautiful-Dev-Cplusplus/</url>
      
        <content type="html"><![CDATA[<div class="note warning flat"><p>多图警告！<br>我把较大的图片传到了另一个图床。如果图片没加载出来请反复刷新！</p></div><p>效果如下图：</p><p><img src="https://i.loli.net/2021/10/02/qoDHn7z5QJgCUec.png" alt="最终效果"></p><span id="more"></span><hr><p>首先你需要有一个Dev-c++（我想大家都有）。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ujqckn5i.png" alt=""></p><p>点进去，打开自己的程序。</p><p><del>没错因为我打八皇后的时候心态炸了于是变量名……</del></p><p><img src="https://i.loli.net/2021/10/02/ypdt3X416nBHIYW.png" alt="印象中的C++"></p><p>点击上面工具栏的【工具】—&gt;【编译器选项】，会弹出来这么一个东西：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/2bcvoxgq.png" alt=""></p><p>找到【高亮显示当前行】，点击【色彩】（如果没有启用先点击启用，然后再选颜色），选择black。</p><p>这是为了让当前点击的那一行不那么刺眼。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jhhhne80.png" alt=""><br>然后点击上面的【语法】，会出来一个界面：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/69f0tt96.png" alt=""></p><p>找到左下角的【预设】，点击那个长条，选择【GSS Hacker】，操作后界面如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5e94vb8a.png" alt=""></p><p>找到左上角那个写着很多英语单词的那个框框，需要一个一个点击。</p><p>调颜色是靠左的两个带颜色的长条，第一个是字体颜色（前景），第二个是背景颜色（背景），如图所示。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/tk25g46o.png" alt=""></p><p>1.$Assemblen$ 集合</p><p>本人不知道这东西是干什么的，平常编程也没遇到，就先不管它了（反正也是蓝色系的）。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7abboeql.png" alt=""></p><p>2.$Character$ 字符（即用单引号框起来的字符们）</p><p>这里的【背景】我们不用去管它，点击【前景】，然后跳出来一个选颜色的框框。选择最上面的【Custom】。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/hyeklx5r.png" alt=""></p><p>这个时候会跳出一个更加详细的选颜色的界面。点击下面的【规定自定义颜色】。</p><p>然后看到下面的六个参数，把参数的颜色调成这个样子（其实不用调，检查一下）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/yhc01a5r.png" alt=""></p><p>3.$Comment$ 注释</p><p>不用管背景，点击【前景】，不过这次不用点【Custom】，选择【Gray】就可以了。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fsczxl58.png" alt=""></p><p>4.$Float$ 浮点数（小数）</p><p>不用管背景，点击【前景】—&gt;【Custom】—&gt;【规定自定义颜色】，把参数调成这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7g4ubq0x.png" alt=""></p><p>5.$Hexadecimal$ 十六进制（的数）</p><p>同4</p><p>6.$Identifier$ 标识符（如$main$，变量名等）</p><p>不用管背景，点击【前景】—&gt;【Custom】—&gt;【规定自定义颜色】，把参数调成这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jbyt68yv.png" alt=""></p><p>7.$Illegal$ $Char$ 不合法的的字符</p><p>不用管（虽然不好看，但是我觉得字符打错了就需要一个很丑的颜色来提醒你……）。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/c051btns.png" alt=""></p><p>8.$Number$ 数字（整数类型，十进制）</p><p>同4、5，一家人就要整整齐齐【大写的滑稽】</p><p>9.$Octal$ 八进制（的数）</p><p>同4、5、8，得，又来一个</p><p>10.$Preprocessor$ 前面带“#”的玩意儿</p><p>不用管背景，点击【前景】—&gt;【Sliver】。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/owndj9xo.png" alt=""></p><p>11.$Reserved$ $Word$ 保留字符（如$int$，$if$等)</p><p>不用管背景，【前景】—&gt;【Custom】，然后选上面表格中第三行第八列的猛男色。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5ha7ecng.png" alt=""></p><p>12.$Space$ 空格</p><p>不用管。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/uj0fwaeb.png" alt=""></p><p>13.$String$ 字符串（即用双引号框起来的字符们）</p><p>不用管背景，点击【前景】—&gt;【Teal】。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/tdq9wxjt.png" alt=""></p><p>14.$Symbol$ 符号（类似于括号）</p><p>不用管背景，点击【前景】—&gt;【Sliver】。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/930829ec.png" alt=""></p><p>15.$Selected$ $text$ 被选中的地方</p><p>不用管前景，点击【背景】—&gt;【Gray】。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/x3v0j55z.png" alt=""></p><p>16.$Gutter$ 旁边那一列数字（列号）</p><p>不用管背景，点击【前景】—&gt;【Sliver】。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/x4s6zb7i.png" alt=""></p><p>17.$Breakpoints$ 断点（调试用的）</p><p>点击【前景】—&gt;【Black】，【背景】—&gt;【Custom】—&gt;【规定自定义颜色】，把参数调成这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nzaxogdc.png" alt=""></p><p>18.$Error$ $line$ 编译错误时的那条红杠杠</p><p>这个我们不用管，这个颜色还可以。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/15a8nqe7.png" alt=""></p><p>19.$Active$ $Breakpoints$ 正在执行的断点</p><p>也不用管。</p><p>20.$Floding$ $lines$ 花括号之间的点点</p><p>不用管$ * $3。</p><p><del>作者在偷懒hhhc</del></p><p>然后颜色就调好了。如果大家觉得不好看，可以自己调。</p><p>最后点击下方【预设】那个正方形的按键：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/72s2chxq.png" alt=""></p><p>然后给这个预设取个名字，最后点一下【OK】。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/wsgf4hje.png" alt=""></p><p>勾选【使用语法加亮】。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/psmqqnj6.png" alt=""></p><p>↓ 不勾选【使用语法加亮】的后果</p><p><img src="https://i.loli.net/2021/10/02/QICKzfpli6ynemw.png" alt="诡异のC++"></p><p>最后点击确定，你的C++就成开头展示的那样了。</p><p><strong>完成！</strong></p><p>(Tips：调完之后建议把左边的白框框拉掉，不然反差很大)</p><hr><p>今天的<del>保姆级</del>教程就到这里了哦~</p><p>顺便附上<a href="https://www.cnblogs.com/rjgcs/p/5798143.html">这个水贴的思路来源</a></p>]]></content>
      
      
      <categories>
          
          <category> 水贴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递推、递归学习笔记</title>
      <link href="/posts/Recursion/"/>
      <url>/posts/Recursion/</url>
      
        <content type="html"><![CDATA[<p>Update on 2021/10/1：对文章进行优化，修复 $\LaTeX$。</p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>各位<del>在座的在站的在躺的在趴的以及以各种奇奇怪怪的姿势出现在电脑前的</del>大佬们大家好，虽然我知道你们都是大佬，但是这篇博客，我还是会把你们当成萌新来讲解的（。</p><p>好了，废话不多说，下面进入正题。</p><hr><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h3><p>mjl：从已知道的若干项出发，利用递推关系依次推算出后面的未知项的方法，我们称为递推算法。</p><p>做递推算法最关键的是找出递推式，然后再求出最简单的情况的值并存在数组里。</p><p>这个要直接求出值的情况个数要根据递推式来看。</p><p>比如说，如果一个递推式是 $f(i)=f(i-3)+f(i-2)$，那么我们需要把 $1,2,3$ 的情况都先写出来，然后从 $4$ 开始循环。</p><p>递推模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=...;</span><br><span class="line"><span class="keyword">int</span> a[maxn]=&#123;需要存的最简单的情况&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=...;i&lt;=n;i++)&#123;</span><br><span class="line">    递推式;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>mjl：从已知问题的结果出发，用迭代表达式逐步推算出问题的开始的条件，即顺推法的逆过程，称为递归。</p><p>当然这是算法方面的解释，递归其实就是<del>套娃</del>函数自己调用自己，只不过比纯粹的套娃要难$10^8$ 些罢了（。</p><p>从算法的角度来说，显然无限套娃是没有意义的，所以我们也需要一个递归的出口来结束递归。</p><p>因为递归变化较多，模板不太好写，就不写了。</p><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p>之所以把递推和递归放在一起讲说明他们是有共同点的，根据本人为数不多的做题经验（一定要多刷题啊！awa），可以发现递推和递归都是要推出在一个规律下，不同值对应的不同结果之间的关系，从而推出答案的值，也都需要一个出口来结束程序。</p><p>mjl：而递推与递归的不同之处在于，递归是从未知到已知，逐步接近解决问题的过程，而递推从已知到未知。</p><p>翻译成人话就是：递推是从小到大一点一点推，而递归是一个栈的结构——先从最终结果出发，一点一点往前推，直到推到出口，再根据出口的数值把答案推出来。</p><p>最直观的图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/31accb12619bb136abe1aa9a3fc3fb7f.png" alt="递推"><br><img src="https://img-blog.csdnimg.cn/img_convert/c35e49edf8c20c5ce54afddfbb359af8.png" alt="递归"></p><p>（↑以 $f(x)=f(x-1)+x$ 且 $f(1)=1$ 举例，求 $f(5)$，递推与递归的区别与联系）</p><hr><h2 id="递推递归的-5-种模型"><a href="#递推递归的-5-种模型" class="headerlink" title="递推递归的 5 种模型"></a>递推递归的 5 种模型</h2><p>递推递归有一些模型，这些模型可以在递推和递归中通用。</p><hr><h3 id="1-斐波那契数列（Fibonacci）"><a href="#1-斐波那契数列（Fibonacci）" class="headerlink" title="1. 斐波那契数列（Fibonacci）"></a>1. 斐波那契数列（Fibonacci）</h3><p>这是一种很简单的递推模型。</p><p>这种模型一般都是，此时第 $x$ 项数据与前面的数据有直接的数值关联（一般来说是很明显的倍数关系）。</p><hr><h4 id="例题-铺砖1"><a href="#例题-铺砖1" class="headerlink" title="例题-铺砖1"></a>例题-铺砖1</h4><p><a href="http://222.180.160.110:1024/problem/328">原题链接（CQBZOJ）</a></p><p>有 $2\times n$ 的一个长方形方格道路，只有一种的 $1\times 2$ 砖去铺，总共有多少种铺法？（$0\le n\le 45$）</p><hr><p>很明显可以看到末尾的砖块（只是末尾）有两种放法：</p><ol><li>竖着放一块；</li><li>横着放两块。</li></ol><p>我们在放最新的第 $i$ 列，即末尾的砖块时，这两种放法对应着 $i-1$ 和 $i-2$ 的情况，如下图。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dc1cd3e2c1f2b5e3079e334005dc57b9.png" alt=""></p><p>所以可以看出这是一道很经典的 Fibonacci 递推的题目。</p><p>递推式：$a_i=a_{i-1}+a_{i-2}$</p><p>$80$ 分代码（很简单）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">f</span>(n<span class="number">-1</span>)+<span class="built_in">f</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">f</span>(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么是 $80$ 分，这里先不说，看到后面就知道了。</p><hr><h3 id="2-汉诺塔（Hanoi）"><a href="#2-汉诺塔（Hanoi）" class="headerlink" title="2.汉诺塔（Hanoi）"></a>2.汉诺塔（Hanoi）</h3><p>汉诺塔本身的问题是把若干从小到大堆叠的圆盘借助一根辅助的柱子从一根柱子移到另一根柱子上，要求一次只能移动一个，而且大的不能压在小的上面。</p><p>我们研究最原始的问题。</p><hr><h4 id="例题-汉诺塔问题"><a href="#例题-汉诺塔问题" class="headerlink" title="例题-汉诺塔问题"></a>例题-汉诺塔问题</h4><p><a href="http://222.180.160.110:1024/problem/3615">原题链接（CQBZOJ）</a></p><p>有三个柱子，其中一根上从大到小叠着 $n$ 个圆盘。现在需要移动这些圆盘，规则如下：</p><ol><li>一次只许移动一个盘；</li><li>任何时候、任何柱子不允许把大盘放在小盘上面；</li><li>可使用任一一根立柱暂存圆盘。</li></ol><p>问：如何使用最少步数实现 $n$ 个盘子的移动？打印出具体移动方案。</p><p>数据范围：$1\le n\le 18$</p><hr><p>我们可以假设这三根柱子分别为 $A$，$B$，$C$，我们把 $n$ 个盘子从 $A$ 借助 $B$ 移到 $C$ 上。</p><p>如果只有一个盘子，我们就直接移。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5450d73f2e9271600fcbd709d9a19eee.png" alt="只有一个盘子"></p><p>如果有两个以上的盘子，我们就分 $3$ 步做：</p><ul><li>第一步：把上面 $n-1$ 个盘子从 $A$ 借助 $C$ 移到 $B$ 上，腾出 $C$ 的位置；</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/388f47635883a0c6716c6cb6ee175983.png" alt="第一步"></p><ul><li>第二步：把留在 $A$ 上的最大的圆盘移到 $C$ 上；</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/2473c8882f57709582f6e52f34c40e4c.png" alt="第二步"></p><ul><li>第三步：把暂时放在 $B$ 上的其他圆盘从 $B$ 借助 $A$ 移到 $C$ 上。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/ad71a5695612392ec8fee321d9f41a60.png" alt="第三步"></p><p>而第一步和第三步怎么移过去，就需要继续把这个问题分解成最大的和其他的问题，直到只剩下一个圆盘，就直接移过去。</p><p>递推式（只求步数不求过程）：$a_i=2\times a_{i-1}+1$</p><p>要求输出过程只能用递归。</p><p>AC 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//n：圆盘数量，a、b、c：柱子编号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">h</span>(n<span class="number">-1</span>,a,c,b);           <span class="comment">//第一步</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;%c\n&quot;</span>,a,c); <span class="comment">//第二步</span></span><br><span class="line">    <span class="built_in">h</span>(n<span class="number">-1</span>,b,a,c);           <span class="comment">//第三步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">h</span>(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="3-平面分割"><a href="#3-平面分割" class="headerlink" title="3.平面分割"></a>3.平面分割</h3><p>用一些两两相交但是不会三个及以上相交的圆把平面分成若干个区域。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9bcad3899cda85d7f1ca9c16f2c91a83.png" alt="最简单的情况"></p><p>观察答案，我们会发现：</p><p>$ans_2-ans_1=2$</p><p>$ans_3-ans_2=4$</p><p>$ans_4-ans_3=6$</p><p>$……$</p><p>很明显的差等差数列。发现这个之后规律就出来了：</p><p>递推式：$a_i=a_{i-1}+2\times (i-1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    a[i]=a[i<span class="number">-1</span>]+<span class="number">2</span>*(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-卡塔兰数（Catalan）"><a href="#4-卡塔兰数（Catalan）" class="headerlink" title="4.卡塔兰数（Catalan）"></a>4.卡塔兰数（Catalan）</h3><p>难点来了！这玩意儿很难，主要是规律很难发现，而且做题也不容易看出来。</p><p>卡塔兰数本来是将一个 $n$ 边形通过<strong>不相交</strong>的对角线分成若干个三角形，求这个 $n$ 边形有多少种不同的划分方法。</p><p>最原始的题目：</p><p><a href="http://222.180.160.110:1024/problem/350">原题链接（CQBZOJ）</a></p><p>要解决这个题目，首先我们需要一个 $n$ 边形：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3adc2f937cb460baf7d2c8408f9e58b3.png" alt="n 边形"></p><p>然后我们再选定一个 $i$（$2\leq i \leq n-1$）点，把 $1$ 到 $i$ 和 $n$ 到 $i$ 两条对角线连起来，把这个 $n$ 边形分成三个部分：（$i$ 以 $3$ 为例）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/eff8b957c0b4024a7ef1ccddd6655711.png" alt="把这个多边形切了"></p><p>可见，这个 $n$ 边形被分成了一个 $i$ 边形、一个三角形和一个 $(n-i+1)$ 边形。</p><p>而这个 $i$ 边形和 $(n-i+1)$ 边形可以用相同的方法去求解。</p><p>每个满足条件的 $i$ 点都可以选一遍。</p><p>所以这个递推式就是这样的：</p><p>$a_i=a_2\times  a_{n-2+1}+a_3\times a_{n-3+1}+a_4\times a_{n-4+1}+\ldots+a_{n-1}\times a_2$</p><p>（当然要记住，$a_2=0$，但是我们在计算的时候，为了计算的准确，我们规定 <code>a[0]=a[1]=a[2]=1</code>，最后再把 $a_2$ 改回去。）</p><p>用求和公式表达就是：</p><p>$a_i=\sum_{j=2}^{n-1} \limits a_j\times a_{n-j+1}$</p><p>作为一个初学者，我并不明白 $\sum$ 这玩意儿是啥意思，其实它叫”求和符号“，具体大家去网上搜吧。</p><p>（这里就用递推了好理解一些，注意开 <code>long long</code>，不然会炸。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>]=a[<span class="number">1</span>]=a[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;<span class="comment">//从3开始枚举 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        a[i]+=a[j]*a[i-j+<span class="number">1</span>];</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">a[<span class="number">2</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>好了讲完了理论我们就来看看实际应用。</p><hr><h4 id="例题-编程社买书"><a href="#例题-编程社买书" class="headerlink" title="例题-编程社买书"></a>例题-编程社买书</h4><p><a href="http://222.180.160.110:1024/problem/10689">原题链接（CQBZOJ）</a></p><p>为了进一步提高编程能力，编程社的 $2n$ 个同学决定去购买《信息学奥赛一本通》，书的价格为 $50$ 元。卖书的书店没有零钱找补，但是有一个特殊的找零装置，放入这个装置的钱只能从最上面的一张拿。其中，$n$ 个同学手中仅有一张 $50$ 元，另外 $n$ 个同学手中仅有一张 $100$ 元。请问一共有多少种排队方案使得所有的同学都可以买到书？$(1\leq n\leq100)$</p><p>这道题的关键是：如何看出这是一道卡塔兰。</p><p>样例+打表？显然不是。</p><p>首先，不难发现，不管我们遍历到哪个位置，这个位置和他前面的位置中，$50$ 元的数量必须比 $100$ 多或相等。可以看出：第一个人必须拿 $50$。</p><p>我们在 $2-2n$ 这个区域中随机选一个人，编号为 $i$（不管他拿的是什么钱）。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3ecc4eb1f3be2c9be579677af17d6eff.png" alt=""></p><p>如果前 $i$ 个人可以做到拿 $50$ 的数量 $\ge$ 拿 $100$ 的数量，那么这种情况就可以算一种正确答案。</p><p>而我们从第二个人开始，一直选到第 $2n$ 个人，就是所有的情况。</p><p>我们把这 $2n$ 个人分成了 $3$ 个部分，这不就是卡塔兰数吗？</p><p>代码需要高精度，大家可以自行复制板子：）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a[<span class="number">10005</span>];</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a1,string b1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10005</span>]=&#123;&#125;,b[<span class="number">10005</span>]=&#123;&#125;,c[<span class="number">10005</span>]=&#123;&#125;;</span><br><span class="line">    string c1;</span><br><span class="line">    <span class="keyword">int</span> lena=a1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lenb=b1.<span class="built_in">size</span>(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena;i++) a[lena-i]=a1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenb;i++) b[lenb-i]=b1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> lenc=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lenc&lt;=lena||lenc&lt;=lenb)&#123;</span><br><span class="line">        c[lenc]+=a[lenc]+b[lenc];</span><br><span class="line">        c[lenc+<span class="number">1</span>]=c[lenc]/<span class="number">10</span>;</span><br><span class="line">        c[lenc]%=<span class="number">10</span>;</span><br><span class="line">        lenc++; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span>(!c[lenc]) lenc--;</span><br><span class="line">    <span class="keyword">while</span>(lenc&gt;=<span class="number">1</span>) c1+=c[lenc--]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">mul</span><span class="params">(string a1,string b1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10005</span>]=&#123;&#125;,b[<span class="number">10005</span>]=&#123;&#125;,c[<span class="number">10005</span>]=&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(a1==<span class="string">&quot;0&quot;</span>||b1==<span class="string">&quot;0&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string c1;</span><br><span class="line">    <span class="keyword">int</span> lena=a1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lenb=b1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena;i++)a[lena-i]=a1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenb;i++) b[lenb-i]=b1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> lenc;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">            lenc=i+j<span class="number">-1</span>;</span><br><span class="line">            c[lenc]+=a[i]*b[j];</span><br><span class="line">            c[lenc+<span class="number">1</span>]+=c[lenc]/<span class="number">10</span>;</span><br><span class="line">            c[lenc]%=<span class="number">10</span>;</span><br><span class="line">            lenc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lenc=lena+lenb;</span><br><span class="line">    <span class="keyword">while</span>(!c[lenc]) lenc--;</span><br><span class="line">    <span class="keyword">while</span>(lenc&gt;=<span class="number">1</span>) c1+=c[lenc--]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    a[<span class="number">0</span>]=a[<span class="number">1</span>]=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123; <span class="comment">// 注意这个地方还是和板子略微有一些区别，至于为什么，请读者自行思考</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            a[i]=<span class="built_in">add</span>(a[i],<span class="built_in">mul</span>(a[j<span class="number">-1</span>],a[i-j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="5-第二类-Stirling-数"><a href="#5-第二类-Stirling-数" class="headerlink" title="5.第二类 Stirling 数"></a>5.第二类 Stirling 数</h3><p>这是个二维递推的模型，也就是说，有两个值在影响结果。第二类 Stirling 数的本质是排列组合（个人理解），题目没有固定的解题公式，但是会有非常紧密的联系，大家可以看看下面的三个例子。</p><h4 id="例题1-合理放球"><a href="#例题1-合理放球" class="headerlink" title="例题1-合理放球"></a>例题1-合理放球</h4><p><a href="http://222.180.160.110:1024/problem/351">原题链接（CQBZOJ）</a></p><p>$n$ 个各不相同球放入 $m$ 个相同的盒子里，球全部放完后，要求最后没有空盒，求不同的放法总数。（$0 &lt; n,m\leq 20$）</p><p>我们可以用一个二维数组存放答案。然后假如说我们要把$i$个球放在$j$个盒子里，那么有三种特殊情况：</p><ol><li><p>$i=1$：因为题目要求顺序不算，所以只有在一个盒子里放。$a_{1,j}=1$；</p></li><li><p>$j=0$：因为没有盒子，所以没办法放。$a_{i,0}=0$；</p></li><li><p>$j=1$：因为只有一个盒子，所以只能都放在这个盒子里。$a_{i,1}=1$。</p></li></ol><p>还有三种普通情况：</p><ul><li>$i&lt;j$</li></ul><p>这种一个就不用说了吧，这种情况肯定是没有了（因为不能有空盒子）。$a_{i,j}=0$；</p><div class="note warning flat"><p>注意：上面的 $i=1$ 如果这这里满足条件的话也要变成 $0$，所以特殊情况和普通情况需要分开判断。<br>也就是说这里不能再用 <code>else if</code> 了。</p></div><ul><li>$i=j$</li></ul><p>这种情况也很简单，因为不能有空盒子，所以只能每个盒子放一个球。$a_{i_j}=1$；</p><ul><li>$i&gt;j$</li></ul><p>本题考点。</p><p>首先我们分析一下有 $i$ 个球分到 $j$ 个盒子里的情况，可以分析出来两种变成这样的方式：</p><ol><li><p>先把 $i-1$ 个球放到 $j$ 个盒子里面，再往里面加一个球；</p></li><li><p>先把 $i-1$ 个球放到 $j-1$ 个盒子里面，然后再加一个装了一个球的盒子。</p></li></ol><p>第一种情况因为不管加在哪个盒子里都可以，所以有 $j$种方法。第二种只有一个方法。</p><p>所以递推式为：$a_{i,j}=a-{i-1,j-1}+j\times a_{i-1,j} $</p><p>最后加上其他的东西，组合成 AC 代码~（注意开 <code>long long</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)a[<span class="number">1</span>][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)a[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">1</span>)a[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)a[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==j)a[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i][j]=a[i<span class="number">-1</span>][j<span class="number">-1</span>]+j*a[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="例题2-危险物质"><a href="#例题2-危险物质" class="headerlink" title="例题2-危险物质"></a>例题2-危险物质</h4><p>有 $n$ 个存放危险物质的坑，坑排列在一条直线，要求有危险物质的两个坑之间至少要有 $m$ 个空坑。对于给定的 $n$ 和 $m$ ，求安全存放危险物质的方案总数 $\text{mod}\ 5000011$ 之后的结果。（$1\le m\le n\le 10^5$）</p><hr><p>这也是有两个数字会影响结果，但是<del>你就算是看看数据范围也可以发现</del>这道题只需要一个一维数组就够了。</p><p>首先我们需要 $n$ 个排成一列的坑：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e89b1eebf1c468df66a00e9cca50cb1c.png" alt="挖坑"></p><p>然后我们看向最后一个坑，它有填与不填两种情况。</p><p>如果不填的话，那么前面的坑就可以<del>为所欲为</del>，只要放置方法合理就行了。</p><p>但是如果填呢？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a50fc86973de3cb68907cb2b140b4e8f.png" alt="往最后的坑放危险物质"></p><p>那么这个坑前面的 $m$ 个坑就不能填了，只有往前到第 $n-m-1$ 个坑的时候才可以随便填。</p><p>所以递推式为：$a_i=a_{i-1}+a_{i-m-1}$</p><p>（批注：前面那部分表示此坑不填，后面那部分表示此坑要填）</p><p>接下来我们要注意一下递推的另一个条件，也就是最简单的情况。</p><p>现在 $m$ 不知道，那么我们怎么得出最简单的情况呢？</p><p>可以发现，如果 $n$ 小于 $m+2$ 的话，那么最多只能填一个或者不填，也就是 $n+1$ 种情况，所以我们可以用循环来解决这个问题。</p><p>AC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;m+<span class="number">2</span>)a[i]=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> a[i]=(a[i<span class="number">-1</span>]+a[i-m<span class="number">-1</span>])%<span class="number">5000011</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="例题3-核电站"><a href="#例题3-核电站" class="headerlink" title="例题3-核电站"></a>例题3-核电站</h4><p>一个核电站有 $N$ 个放核物质的坑，坑排列在一条直线上。如果连续 $M$ 个坑中放入核物质，则会发生爆炸，于是，在某些坑中可能不放核物质。对于给定的 $N$ 和 $M$，求不发生爆炸的放置核物质的方案总数。（$2≤N≤50,2≤M≤5$）</p><p>方法类似上面两道题的融合，一共有三种特殊的情况：</p><ol><li>如果坑的个数小于不能连续的个数，直接随便放，就是$2^n$；</li><li>如果坑的个数等于不能连续的个数，就只有全放一种不行，为$2^n-1$;</li><li>如果坑的个数大于不能连续的个数，那就把它分成两个部分看，放和不放。不放就随便，放的话需要让前面连续 $m+1-1$ 个坑不能连续放（因为前面的有最后一个坑放的可能性所以要 $+1$）。</li></ol><p>最后算出来为：</p><ol><li>$a_i=2\times a_{i-1}$</li><li>$a_i=2\times a_{i-1}-1$</li><li>$2\times a_{i-1}-a_{i-m-1}$</li></ol><p>往循环里一套 AC 代码就出来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">55</span>]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;m)a[i]=<span class="number">2</span>*a[i<span class="number">-1</span>]-a[i-m<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==m)a[i]=<span class="number">2</span>*a[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> a[i]=<span class="number">2</span>*a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="递归的优化——记忆化递归"><a href="#递归的优化——记忆化递归" class="headerlink" title="递归的优化——记忆化递归"></a>递归的优化——记忆化递归</h2><p>你们还记得那个 $80$ 分的斐波那契数列吗？<del>要是不记得了可以去前面再看看。</del>为什么它是 $80$ 分呢？</p><p>因为它超时了……<del>（废话）</del></p><p><img src="https://img-blog.csdnimg.cn/img_convert/491b1437e8a716ca678cf45ee685c564.png" alt="TLE"></p><p>那么怎么解决这个问题呢？</p><p><del>用递推就可以了( •̀ ω •́ )y</del></p><p><del>说得好像有道理……</del>不过这并不妨碍我们介绍另一种方法，就是<strong>记忆化递归</strong>。(●ˇ∀ˇ●)</p><p>记忆化递归是一种典型的以空间换取时间的优化。我们用一个数组储存每一种情况的值，如果我们以后再调用到这个值我们就直接调用，不需要计算了。</p><p>除了斐波那契数列，我们还有另外一个记忆化的题目：</p><hr><h3 id="例题-递归函数"><a href="#例题-递归函数" class="headerlink" title="例题-递归函数"></a>例题-递归函数</h3><p>对于一个递归函数$w(a, b, c)$。</p><p>如果$a &lt;= 0\ or\ b &lt;= 0\ or\ c &lt;= 0$就返回值 $1$。</p><p>如果$a &gt; 20\ or\ b &gt; 20\ or\ c &gt; 20$就返回 $W(20,20,20)$。</p><p>如果 $a &lt; b$ 并且 $b &lt; c$ 就返回 $w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$，</p><p>其它别的情况就返回</p><p>$w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$。</p><p>这是个简单的递归函数，但实现起来可能会有些问题。</p><p>$|a|, |b|, |c| &lt; 30$</p><p>这道题很简单，照着他的写就可以了，主要还是记忆化。</p><p>我们定义一个三维数组来存储解（<code>ll</code> 指<code>long long</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll s[<span class="number">35</span>][<span class="number">35</span>][<span class="number">35</span>];</span><br></pre></td></tr></table></figure><p>然后每次递归之前都判断一下这个值是不是已经算过了，如果算过了就直接返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[x][y][z]!=<span class="number">0</span>)<span class="keyword">return</span> s[x][y][z];</span><br></pre></td></tr></table></figure><p>如果没有算过，那么我们算完了之后要把这个值存到数组里（一个例子）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&lt;y&amp;&amp;y&lt;z)<span class="keyword">return</span> s[x][y][z]=<span class="built_in">w</span>(x,y,z<span class="number">-1</span>)+<span class="built_in">w</span>(x,y<span class="number">-1</span>,z<span class="number">-1</span>)-<span class="built_in">w</span>(x,y<span class="number">-1</span>,z);</span><br></pre></td></tr></table></figure><p>这样我们的代码就轻轻松松的 AC 了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll a,b,c,s[<span class="number">35</span>][<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="function">ll <span class="title">w</span><span class="params">(ll x,ll y,ll z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">0</span>||y&lt;=<span class="number">0</span>||z&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">20</span>||y&gt;<span class="number">20</span>||z&gt;<span class="number">20</span>)<span class="keyword">return</span> <span class="built_in">w</span>(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span>(s[x][y][z]!=<span class="number">0</span>)<span class="keyword">return</span> s[x][y][z];</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y&amp;&amp;y&lt;z)<span class="keyword">return</span> s[x][y][z]=<span class="built_in">w</span>(x,y,z<span class="number">-1</span>)+<span class="built_in">w</span>(x,y<span class="number">-1</span>,z<span class="number">-1</span>)-<span class="built_in">w</span>(x,y<span class="number">-1</span>,z);</span><br><span class="line">    <span class="keyword">return</span> s[x][y][z]=<span class="built_in">w</span>(x<span class="number">-1</span>,y,z)+<span class="built_in">w</span>(x<span class="number">-1</span>,y<span class="number">-1</span>,z)+<span class="built_in">w</span>(x<span class="number">-1</span>,y,z<span class="number">-1</span>)-<span class="built_in">w</span>(x<span class="number">-1</span>,y<span class="number">-1</span>,z<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;a,&amp;b,&amp;c))&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">-1</span>&amp;&amp;b==<span class="number">-1</span>&amp;&amp;c==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w(%lld,%lld,%lld)=%lld\n&quot;</span>,a,b,c,<span class="built_in">w</span>(a,b,c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>递推递归是很基础的一个算法，也是我们正式学的第一种算法，以后很多的算法都需要用到它们（尤其是递归），所以这是很重要的一节课。递推递归的题目难起来也会让人很头疼，甚至很多递归都涉及到了以后学的搜索，而递推涉及到了 dp。</p><p>不管怎么样，各种算法之间都是有很紧密的联系的。递推与递归之间也有很紧密的联系，甚至它们之间的基本模型也是可以通用的，所以我们就把它们放在一起一起学了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递推，递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex测试</title>
      <link href="/posts/latex-test/"/>
      <url>/posts/latex-test/</url>
      
        <content type="html"><![CDATA[<p>PS：由于 markdown 和 $\LaTeX$ 语法冲突，<code>$</code>，<code>*</code>，<code>\</code>，<code>_</code> 前面要打反斜杠 qwq。</p><span id="more"></span><p>$a+b=c$</p><p>$$a+b=c$$</p><p>$alpha$</p><p>$\alpha$</p><p>$pi$</p><p>$\pi$</p><p>$\Gamma$</p><p>$a\equiv b$</p><p>$$\equiv$$</p><p>$$a=b$$</p><p>$$a\notin b \ c\in d  $$</p><p>$\int$ </p><p>$\iint$</p><p>$\iiint$</p><p>$$C_{1} \qquad \int_{x} $$</p><p>$$\Sigma_{C_{i}}\quad \Psi$$</p><p>$$a_{i} \ b_{i}$$</p><p>$$C_1+C_2$$</p><p>$$C_ {m,n} $$</p><p>$${C_{i^2}}^2 = a^2+b^{\int_{x}}$$</p><p>$$e^{x^2} \neq e^{x^2}$$</p><p>$${sin\alpha}^2+{cos\beta}^2 \equiv 1$$</p><p>$$\sqrt{x+y}= \sqrt{\Sigma_{i=1}^{n} x}$$</p><p>$\sqrt{a}$</p><p>$$a=b\cdot c \ a=b\dot c$$</p><p>$$lim_{x \rightarrow 0} \frac {\sin x}{x}=1$$</p><p>$$\overline{a} \quad \underline{m+n}$$</p><p>$$\underbrace{\int_{a_1}^{a_2}f_1(x)dx+\int_{a_2}^{a_3}f_2(x)dx+\cdots+\int_{a_{n-1}}^{a_n}f_n(x)dx}_{\iint_{\Sigma_{i=1}^{n} g(b_i) dx}}$$</p><p>$$y’=3\widetilde a$$</p><p>$$\overrightarrow{AC}=\overrightarrow{AB}+\overrightarrow{BC}$$</p><p>$${n\choose m} \qquad {x\atop y+2} \quad ({x\atop y+2})$$</p><p>$$C_({x\atop y+2})$$</p><p>$${\int_{0}^{\frac{\pi}{2}}}$$</p><p>$$\sum_{i=1}^{n}$$</p><p>$$\prod_ \epsilon$$</p><p>$$1+\left(\frac {1}{1-x^2}\right)^3 \qquad 1+(\frac {1}{1-x^2})^2$$</p><p>$$\left(\underbrace{\int_{a_1}^{a_2}f_1(x)dx+\int_{a_2}^{a_3}f_2(x)dx+\cdots+\int_{a_{n-1}}^{a_n}f_n(x)dx}_{\iint_{\Sigma_{i=1}^{n} g(b_i) dx}}\right)= \Psi $$</p><p>$$a=b$$</p><p>$$\begin{Bmatrix} 1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6 \ 7 &amp; 8 &amp; 9 \end{Bmatrix} \tag{1} $$</p><p>$$\mathbf{X} = \left( \begin{array}{ccc} x_{11} &amp; x_{12} &amp; \ldots \\ x_{21} &amp; x_{22} &amp; \ldots \\ \vdots &amp; \vdots &amp; \ddots \end{array} \right) $$</p><p>$$\mathbf{X} = \left( \begin{array}{ccc} x_{11} &amp; x_{12} &amp; \ldots \\ x_{21} &amp; x_{22} &amp; \ldots \\ \vdots &amp; \vdots &amp; \ddots \end{array} \right) \tag{2}$$</p><p>$\mathbf{X} = \left( \begin{array}{ccc} x_{11} &amp; x_{12} &amp; \ldots \\ x_{21} &amp; x_{22} &amp; \ldots \\ \vdots &amp; \vdots &amp; \ddots \end{array} \right) \tag{1}$</p><p>$$ \left[ \begin{matrix} 1 &amp; 2 &amp; \cdots &amp; 4 \ 7 &amp; 6 &amp; \cdots &amp; 5 \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \ 8 &amp; 9 &amp; \cdots &amp; 0 \ \end{matrix} \right] $$</p><p>$$ \left[ \begin{array}{cc|c} 1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6 \end{array} \right] \tag{7} $$</p><p>$$\sum_{i=1}^n a_i=0$$</p><p>$$f(x)=x^{x^x}$$</p><p>$$<br>1=1\<br>2=2<br>$$</p><p>$$1=1$$</p><p>$$\sqrt[3]{x}$$</p><p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p><p>$$[f(x,y,z) = 3y^2 z \left( 3 + \frac{7x+5}{1 + y^2} \right).]$$</p><p>$$\left. \frac{du}{dx} \right|_{x=0}.$$</p><p>$$\begin{eqnarray*}\cos 2\theta &amp; = &amp; \cos^2 \theta - \sin^2 \theta \\ &amp; = &amp; 2 \cos^2 \theta - 1.\end{eqnarray*}$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网站测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01背包学习笔记</title>
      <link href="/posts/0-1-Knapsack/"/>
      <url>/posts/0-1-Knapsack/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>01背包之所以叫“01”背包，就是它需要选择是否将当前这样物品装入背包。$0$ 代表不装，$1$ 代表装。</p><span id="more"></span><hr><h2 id="一、板子题和强化"><a href="#一、板子题和强化" class="headerlink" title="一、板子题和强化"></a>一、板子题和强化</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个最多能装 $m$ 千克的背包，有 $n$ 块魔法石，它们的重量分别是$W_1,W_2,…,W_n$ ，它们的价值分别是 $C_1,C_2,…,C_n$。若每种魔法石只有一件，问能装入的最大总价值。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为两个整数 $m$ 和 $n$，以下 $n$ 行中，每行两个整数 $W_i,C_i$，分别代表第 $i$ 件物品的重量和价值。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，即最大价值。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">2 3</span><br><span class="line">5 4</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><hr><h3 id="1-板子"><a href="#1-板子" class="headerlink" title="1.板子"></a>1.板子</h3><p>$1\le m \le 30,1\le n\le 15$.</p><p>首先还是分析问题：每个东西都可以选择<strong>选或不选</strong>。我们假设正在抉择第 $i$ 个物品，如果选的话，我们需要付出的代价就是占据一部分的背包容量。可见有两个因素在影响dp数组的值：$i$ 和背包容量 $m$。</p><p>因此可以定义dp数组的意义为：</p><blockquote><p>$dp_{i,j}$ 代表在前 $i$ 件物品中做选择，背包容量为 $j$ 时能获得的最大价值。</p></blockquote><p>好，继续分析，每次对于第 $i$ 个物体的抉择，无非是<strong>选和不选</strong>的两种情况。</p><p>如果选的话，那么在选择前 $i-1$ 个物体的时候，可以使用的背包容量就需要减少 $w_i$，但是所获得的价值就可以加上 $c_i$。</p><p>如果不选，那就和选择前 $i-1$ 个物品的最优情况是一样的。</p><p>可得出动态转移方程：</p><script type="math/tex; mode=display">dp_{i,j}=\max(dp_{i-1,j},dp_{i-1,j-w_i}+c_i)</script><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>把动态转移方程套到程序里面就可以了，注意循环两层从小到大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,w[<span class="number">20</span>],c[<span class="number">20</span>],dp[<span class="number">20</span>][<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;w[i],&amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;j)</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-压缩空间"><a href="#2-压缩空间" class="headerlink" title="2.压缩空间"></a>2.压缩空间</h3><p>$1\le m \le 3\times 10^6,1\le n\le 100$，空限变得极度 duliu。</p><p>考虑优化空间复杂度。</p><p>上述程序的 $dp$ 数组为二维数组，但是大家注意到动态转移方程时只需要用到 $dp_{i-1,?}$ 的值。</p><p>这也就意味着我们可以使用<strong>滚动数组</strong>优化空间复杂度。<del>（不过时间复杂度就没法变了……）</del></p><p><strong>需要注意的是</strong>，因为问号处的值必定小于 $j$，所以我们 $j$ 这一维需要<strong>倒着枚举</strong>，不然在利用前面的值的时候就会错利用为 $dp_{i,?}$ 而非 $dp_{i-1,?}$ 的值了。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b)</span></span><br><span class="line"><span class="keyword">int</span> m,n,dp[<span class="number">35</span>],w[<span class="number">20</span>],c[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;w[i],&amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w[i];j--)&#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="3-如果有其它的限制条件……"><a href="#3-如果有其它的限制条件……" class="headerlink" title="3.如果有其它的限制条件……"></a>3.如果有其它的限制条件……</h3><p>$1\le n\le 100$</p><p>$1\le W_i,m\le 10^9$</p><p>$1\le C_i\le 10^7$</p><p>对于每个 $i=2,3,…,n$，满足 $W_1\le W_i\le W_1+3$</p><hr><p>如果按照背包的板子做，那么一定会 TLE 和 MLE。那如何优化呢？</p><p>我们注意到数据范围里有一句十分特殊的话：</p><blockquote><p>对于每个 $i=2,3,…,n$，满足 $W_1\le W_i\le W_1+3$</p></blockquote><p>那么我们完全可以把每个物品的重量以 $W_1$ 为基准，转化为一个不超过 $3$ 的数。这么可以极大地优化空间复杂度。</p><p>用 $h$ 代表 $W_1$ 的真实数字。</p><p>但是这样的话，我们就无法得知我们现在装的东西到底有没有超过背包的容量，因为我们并不知道我们选了多少个东西。所以 $dp$ 数组还需要开一维代表选择物品的个数。</p><p>所以 $dp_{i,j,k}$ 代表在前 $i$ 个物品中选择 $k$ 个物品，背包容量为 $j$ 时的最大价值。</p><p>还需要注意一下循环的范围：</p><ul><li>$i:1\sim n$</li></ul><p>（这个不需要解释了吧……）</p><ul><li>$j:0\sim 3\times i$</li></ul><p>（因为物品的重量被处理过，当原来的 $W_i=W_1$ 时这个物品的重量为 $0$。所以最小的背包容量有可能是 $0$。物品最大的重量不超过 $3$，有 $i$ 个物品，所以最大可能容量为 $3\times i$。）</p><ul><li>$k:1\sim i$</li></ul><p>（选择的物品数量不能超过总数。因为后面求答案 $ans$ 的初始值就为 $0$ 已经包括了一个都不选的情况，所以不需要考虑不选物品的情况。）</p><p>最后求答案的时候需要枚举 $dp_{n,i,j}$，注意只有 $i+j\times h\le m$ 时背包才不超限，可以更新答案。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b) <span class="comment">//卡常小技巧：用这个比库函数要快一些</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll n,m,ans,h,w[<span class="number">105</span>],v[<span class="number">105</span>],dp[<span class="number">105</span>][<span class="number">305</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;h,&amp;v[<span class="number">1</span>]); <span class="comment">//h 代表 W1 的的重量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">        w[i]-=h; <span class="comment">//以 W1 为基准转化每一件物品的重量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=i;k++)&#123; <span class="comment">//选择的物品数量不能大于总数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>*i;j++)&#123; <span class="comment">//3*i 为被允许的最大容量</span></span><br><span class="line">                <span class="keyword">if</span>(j&lt;w[i])</span><br><span class="line">                    dp[i][j][k]=dp[i<span class="number">-1</span>][j][k];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j][k]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][k],dp[i<span class="number">-1</span>][j-w[i]][k<span class="number">-1</span>]+v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在合法的范围内寻找最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>*n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+j*h&lt;=m)</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,dp[n][i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二、比较简单的应用"><a href="#二、比较简单的应用" class="headerlink" title="二、比较简单的应用"></a>二、比较简单的应用</h2><p>一些适合背包初学者体会的题目~</p><h3 id="例2-1-采药"><a href="#例2-1-采药" class="headerlink" title="例2-1.采药"></a>例2-1.采药</h3><p><a href="https://www.luogu.com.cn/problem/P1048">题目链接</a></p><p>非常板的一道题，把板子搬过来即可。</p><hr><h3 id="例2-2-装箱问题"><a href="#例2-2-装箱问题" class="headerlink" title="例2-2.装箱问题"></a>例2-2.装箱问题</h3><p><a href="https://www.luogu.com.cn/problem/P1049">题目链接</a></p><p>也是板子题，因为没有价值，而要求剩余空间最小，那么就是让重量尽量大。所以我们可以把重量当作价值，在不超过容量的前提下把剩余空间尽量变小。</p><h3 id="Code-（非滚动写法）"><a href="#Code-（非滚动写法）" class="headerlink" title="Code （非滚动写法）"></a>Code （非滚动写法）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> m,n,w[<span class="number">35</span>],dp[<span class="number">35</span>][<span class="number">20005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;j)</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,m-dp[n][m]); <span class="comment">//求的是剩余空间所以需要做减法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="例2-3-数字分组1"><a href="#例2-3-数字分组1" class="headerlink" title="例2-3.数字分组1"></a>例2-3.数字分组1</h3><p><a href="http://222.180.160.110:1024/contest/1559/problem/4">题目链接</a></p><p>简化题意：给出若干个数字，把这些数字分为两组使两组数字的和的差距尽量小。</p><p>因为要让两组尽量接近，即接近 $\big (\sum\limits_{i=1}^{n}w_i\big ) ÷2$，所以我们规定一个背包的大小为这个数，然后让一组的重量尽量靠近这个值（也就是例 $2-2$，顺便展示一下例 $2-2$ 的滚动数组写法），再分别输出即可。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> m,sum,n,w[<span class="number">35</span>],dp[<span class="number">300005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">        m+=w[i];</span><br><span class="line">        sum+=w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    m=(m+<span class="number">1</span>)/<span class="number">2</span>; <span class="comment">//为了以防万一向上取整也是可以的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w[i];j--)&#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=sum-dp[m];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">abs</span>(k-dp[m]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、01背包问题输出方案"><a href="#三、01背包问题输出方案" class="headerlink" title="三、01背包问题输出方案"></a>三、01背包问题输出方案</h2><p>DP 算法输出方案的思想都是差不多的，即，开一个 $pre$ 数组记录每一步的决策，然后输出的时候根据 $pre$ 数组倒推回去。</p><p>我们来看一些例题。</p><hr><h3 id="例3-1-01背包输出方案"><a href="#例3-1-01背包输出方案" class="headerlink" title="例3-1.01背包输出方案"></a>例3-1.01背包输出方案</h3><p>题目即让一个普通的01背包输出方案——输出要选择的物品编号。</p><p>那么，在每次求最大值的时候，我们就不能用 $\max$ 了，而是打一个条件选择，如果能更新 $dp_j$ 的值，那么我们就更新 $dp_j$，而且把 $pre_{i,j}$ 设为 $1$，代表在背包容量为 $j$ 的情况下要选择 $i$ 物品。</p><p>最后的输出可以用递归，也可以用循环。这里本人比较偏向于打递归（倒着推，代码较为简短），大家可以结合注释好好理解一下这个递归的输出函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//x代表物品的编号，y代表背包此时的容量</span></span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>; <span class="comment">//物品已经枚举完</span></span><br><span class="line">    <span class="keyword">if</span>(pre[x][y])&#123; <span class="comment">//要选这个物品</span></span><br><span class="line">        <span class="built_in">print</span>(x<span class="number">-1</span>,y-w[x]); <span class="comment">//往前推，背包的容量需要减少这个物品的重量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x); <span class="comment">//输出（因为要正着输出但是我们是倒着推的，所以在运行完了上面的递归函数后才输出）</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">print</span>(x<span class="number">-1</span>,y); <span class="comment">//不选的话就不用减少背包容量了</span></span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//华丽结束~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候，题目会要求我们输出使用背包容量最小时的方案，我们在调用函数的时候 $y$ 参数就不可以直接填 $m$，而是进行一次循环，从小往大枚举，如果 $dp_i=dp_m$（最优解），就把这个 $i$ 值代入函数的 $y$ 参数。</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b)</span></span><br><span class="line"><span class="keyword">int</span> m,n,dp[<span class="number">35</span>],w[<span class="number">20</span>],c[<span class="number">20</span>],pre[<span class="number">20</span>][<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre[x][y])&#123;</span><br><span class="line">        <span class="built_in">print</span>(x<span class="number">-1</span>,y-w[x]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">print</span>(x<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;w[i],&amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w[i];j--)&#123;</span><br><span class="line">            <span class="comment">//dp[j]=max(dp[j],dp[j-w[i]]+c[i]);</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j-w[i]]+c[i]&gt;dp[j])&#123;</span><br><span class="line">            dp[j]=dp[j-w[i]]+c[i];</span><br><span class="line">            pre[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[m]);</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i]==dp[m])&#123;</span><br><span class="line">    t=i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(n,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="例3-2-CD"><a href="#例3-2-CD" class="headerlink" title="例3-2.CD"></a>例3-2.CD</h3><p><a href="https://www.luogu.com.cn/problem/UVA624">题目链接</a></p><p>和上述题目差不多，有多组输入，但是输出要求要输出<strong>和</strong>。</p><p>不过因为和是在最后输出，所以我们可以在递归函数的过程中统计选择了多少个 CD，代码实现很简单。</p><p>再说一句：如果是要求在输出方案之前输出和，那么我们就需要再准备一个数组，先用此函数统计和（但是把输出语句改为<strong>把答案存到数组</strong>里的语句），输出 $sum$，然后输出数组。</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> m,n,dp[<span class="number">10005</span>],a[<span class="number">105</span>],pre[<span class="number">105</span>][<span class="number">10005</span>],sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre[x][y])&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">print</span>(x<span class="number">-1</span>,y-a[x]);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(x<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[x]);</span><br><span class="line">        sum+=a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=a[i];j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-a[i]]+a[i]&gt;m)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-a[i]]+a[i]&gt;=dp[j])&#123;</span><br><span class="line">                    dp[j]=dp[j-a[i]]+a[i];</span><br><span class="line">                    pre[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(n,m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum:%d\n&quot;</span>,sum);</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、需要排序的01背包问题"><a href="#四、需要排序的01背包问题" class="headerlink" title="四、需要排序的01背包问题"></a>四、需要排序的01背包问题</h2><p>到这个阶段，背包问题就开始有难度了。</p><p>背包问题本身是不需要排序的。需要排序的背包问题就是说在做某个决策的时候，一些参数（如背包容量等）会发生变化，为了得到最优解，我们需要对背包的物品进行排序。</p><p>一般来说，排序的过程涉及到贪心的思想，我们可以使用<strong>假设</strong>的方法。这种方法会在下面的题解中详细介绍。</p><p>还是来看一些例题来加强理解吧。</p><hr><h3 id="例4-1-骄傲的商人"><a href="#例4-1-骄傲的商人" class="headerlink" title="例4-1.骄傲的商人"></a>例4-1.骄傲的商人</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3466">题目链接</a></p><p>题意简述：有一些商人，每个商人只卖一件商品，价格是 $P_i$，但是如果你的钱少于 $Q_i$，你就不能买这个东西。你评估了每一件商品的价值 $V_i$。而且你只有 $M$ 单位的钱，那么你能得到的最大价值是多少?</p><p>其实这道题是非常简单的，就是十分普通的01背包板子，只需要在前面加一个判断总钱数是否大于 $Q_i$ 的程序就好啦~</p><p>结果你交上去会发现错了（（</p><p>为什么呢？疑惑(っ´Ι`)っ？？</p><p>原因是这样的：</p><p>因为每一次购买物品都需要耗钱买，那么有些本来可以买的东西因为枚举较为靠后就没有买到。</p><p>所以呢，我们需要对每一件商品进行排序，让每个让我拿到最优解的东西都可以买到。</p><p>那么怎么排序呢？这时候就需要<strong>假设法</strong>（名字我自己取的）来分析了！</p><p>使用结构体存储每件商品的信息，然后假设我们要买两件商品 $x$ 和 $y$，而且你的钱 $M$ 大于两个商品耗费的钱之和。</p><p>假设如果你先买 $x$ 商品比先买 $y$ 商品方案更优。</p><p>那么就只有一种情况：买了 $x$ 后可以继续买 $y$，但是买了 $y$ 之后就不可以买 $x$ 了。</p><p>$x\ \ \ \ x.p\ \ \ x.q\ \ \ x.v$<br>$y\ \ \ \ y.p\ \ \ y.q\ \ \ y.v$</p><p>（把所有条件都列在草稿纸上以便分析，一定要养成好习惯哦！）</p><p>所以可以得出：</p><p>$<br>  \begin{cases}<br>       M-x.p\ge y.q\cdots(1)\\<br>    M-y.p&lt;x.q\cdots(2)<br>  \end{cases}<br>$</p><p>整理一下式子可以得到：</p><p>$<br>  \begin{cases}<br>       M-x.p\ge y.q\cdots(1)\\<br>    y.p-M&gt;-x.q\cdots(2)<br>  \end{cases}<br>$</p><p>（右边负号别漏了）</p><p>$(1)+(2)$ 可得：</p><p>$y.p-x.p&gt;y.q-x.q$</p><p>移项变号：</p><p>$x.q-x.p&lt;y.q-y.p$</p><p>就得出了最后排序的式子。</p><p>使用的时候，$x$（放在前面更优的物品）放在 <code>cmp</code> 传参的前面，$y$ 放在<code>cmp</code> 传参的后面，直接 <code>return</code> 推出来的式子即可。当然，你愿意保险一点像我一样写条件选择也没问题。</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> m,n,dp[<span class="number">5005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p,q,v;</span><br><span class="line">&#125;a[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.q-x.p&gt;=y.q-y.p)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a[i].p,&amp;a[i].q,&amp;a[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=a[i].q;j--)&#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-a[i].p]+a[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="例4-2-烹调方案"><a href="#例4-2-烹调方案" class="headerlink" title="例4-2.烹调方案"></a>例4-2.烹调方案</h3><p><a href="https://www.luogu.com.cn/problem/P1417">题目链接</a></p><p>很明显这道题是需要排序的，因为每一道菜的美味指数与时间有关，所以需要排序安排做每个食物的顺序。不过现在这并不是我们的重点。</p><p>问题是：背包容量是啥，重量是啥，价值又是啥呢？</p><p>题目中只规定了一个<strong>时间</strong>，所以重量限制就是做菜的时间；需要获得的是最大的<strong>美味指数</strong>，所以价值就是每道菜的美味指数。（我说了先暂时不管时间对食物价值的损耗，只是推状态转移方程而已啦！）</p><p>外层循环 $i$：枚举每个食物。</p><p>内层循环 $j$：枚举过了多少时间。</p><p><strong>特别注意！</strong> 在背包问题中，需要注意你的内层循环这个数值到底代表的是<strong>最多这么多限制还是刚好这么多限制</strong>，这道题因为不需要用到非常精准的时间分钟数所以是最多的限制，$dp$ 数组不需要初始化极小值，所有数为 $0$ 即可。</p><p>每个食物的重量：$c_i$</p><p>每个食物的价值：$a_i-j\times b_i$</p><p>照着板子打上去就可以了。现在是考虑排序的时间~</p><p>还是假设要做两个食物 $x$ 和 $y$，先做 $x$ 比先做 $y$ 获得的美味指数多。为了方便，时间从 $0$ 开始且不考虑食物美味指数小于等于 $0$ 的情况。</p><p>$x\ \ \ \ x.a\ \ \ x.b\ \ \ x.c$<br>$y\ \ \ \ y.a\ \ \ y.b\ \ \ y.c$</p><p>先做 $x$ 的美味指数：$x.a+y.a-y.b\times x.c$</p><p>先做 $y$ 的美味指数：$y.a+x.a-x.b\times y.c$</p><p>由假设得出结论：</p><p>$x.a+y.a-y.b\times x.c&gt;y.a+x.a-x.b\times y.c$</p><p>整理得：</p><p>$-y.b\times x.c&gt;-x.b\times y.c$</p><p>去掉负号：</p><p>$y.b\times x.c&lt;x.b\times y.c$</p><p>OK，式子推出来了。还是用结构体存储排序打代码。</p><p>代码记得开 <code>long long</code>。</p><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll T,n,ans,dp[<span class="number">100005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">food</span>&#123;</span></span><br><span class="line">    ll a,b,c;</span><br><span class="line">&#125;w[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(food x,food y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.c*y.b&gt;=x.b*y.c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;T,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w[i].a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(w+<span class="number">1</span>,w+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=T;j&gt;=w[i].c;j--)&#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i].c]+w[i].a-w[i].b*j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="说句闲话"><a href="#说句闲话" class="headerlink" title="说句闲话"></a>说句闲话</h3><p>其实上面两道题代表得是本人认为对于需要排序得背包问题的两大类：</p><p>骄傲的商人 $→$ 不同的排序方式，一些情况成立，另一些则无法成立。每种情况只要成立创造的价值都是相同的。</p><p>列出来的式子通常是 $2$ 个及以上，需要合并，较为麻烦。</p><p>烹饪方案 $→$ 不同的排序方式，所有情况都成立，可是创造的价值不同。</p><p>通常只会列出一个式子进行推到，相对比较容易。</p><p>当然肯定会有两者的结合题目，只不过本人暂时未遇到就先不说了。</p><hr><h2 id="五、01背包进阶"><a href="#五、01背包进阶" class="headerlink" title="五、01背包进阶"></a>五、01背包进阶</h2><p>到了这个阶段，01背包就已经不是单纯的背包问题了，其本质上是每进行一个操作参数的变化。具体表现为：“背包的容量”和物品的“重量”、“价值”不是很好找，而且很有可能根据某些操作变化。</p><p>我们来看一些例题。</p><hr><h3 id="例5-1-Course-Selection-System"><a href="#例5-1-Course-Selection-System" class="headerlink" title="例5-1.Course Selection System"></a>例5-1.Course Selection System</h3><p><a href="http://222.180.160.110:1024/contest/1559/problem/11">题目链接</a></p><p>题意简述：有 $n$ 个物品，第 $i$ 个物品都有两个权值 $H_i$ 和 $C_i$。现在选出若干个物品（可以不选）$x_1,x_2,\ldots ,x_m$ 使得 $ans$ 最大。</p><p>$ans=\big(\sum\limits_{i=1}^{m}H_{x_i}\big)^2-\big(\sum\limits_{i=1}^{m}H_{x_i}\big)\times \big(\sum\limits_{i=1}^{m}C_{x_i}\big)-\big(\sum\limits_{i=1}^{m}C_{x_i}\big)^2$</p><p>这道题乍一看没有什么思路，那我们就需要对这个式子进行处理。</p><p>首先，根据观察可得：这道题中 $H_i$ 主要是<strong>让答案更大</strong>，$C_i$ 是<strong>让答案更小</strong>。可以说，$C_i$ 是<strong>答案的限制</strong>。所以，我们可以把 $C_i$ 作为背包的容量和每一件物品的重量。不难看出，背包的最大容量应该是 $\sum\limits_{i=1}^{n}C_i$。</p><p>那么相应地，$H_i$ 就可以作为物品的价值，所以存在 $dp$ 数组里面的值就是固定 $C_i$ 下的最大 $H_i$ 之和。</p><p>在进行一次 01 背包之后，你不要以为就万事大吉了！因为不一定 $C_i$ 大的 $ans$ 值就是最优解，所以我们需要遍历 $dp$ 数组，每次在计算答案的时候按照题目要求的格式计算即可。具体看代码理解。</p><p>最后注意开 <code>long long</code>，注意多组数据和每次的初始化。</p><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll t,n,ans,sum,h[<span class="number">505</span>],c[<span class="number">505</span>],dp[<span class="number">50005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp)); <span class="comment">//多组数据要初始化</span></span><br><span class="line">        ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;h[i],&amp;c[i]);</span><br><span class="line">            sum+=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=c[i];j--)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-c[i]]+h[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=sum;i++)&#123; <span class="comment">//i遍历的是 Ci 的值，dp 数组里的值代表 Hi</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[i]*dp[i]-dp[i]*i-i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="例5-2-Dima-and-Salad"><a href="#例5-2-Dima-and-Salad" class="headerlink" title="例5-2.Dima and Salad"></a>例5-2.Dima and Salad</h3><p><a href="https://www.luogu.com.cn/problem/CF366C">题目链接</a></p><p>本题解已审核通过，欢迎大家资瓷~<a href="https://www.luogu.com.cn/problem/solution/CF366C">link</a></p><p>首先假设我们选了 $m$ 个水果。已知：</p><script type="math/tex; mode=display">\dfrac{\sum\limits_{i=1}^{m}a_i}{\sum\limits_{i=1}^{m}b_i}=k</script><p>转换式子后可得：</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{m}a_i=\sum\limits_{i=1}^{m}b_i\times k</script><p>再次转换：</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{m}a_i-\sum\limits_{i=1}^{m}b_i\times k=0</script><p>可以写成：</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{m}(a_i-b_i\times k)=0</script><p>所以我们可以让第 $i$ 个水果的重量为 $a_i-b_i\times k$，最后只要让重量总和等于 $0$ 就算满足条件啦。</p><p>此时我们需要注意初始值：因为按照上面这么分析，水果的重量和完全有可能是负数。这个时候看到数据范围：</p><p>$1\le n\le 100,1\le k\le 10,1\le a_i,b_i\le 100$</p><p>最小极限情况：$n=100,k=10,a_i=1,b_i=100$</p><p>那么重量总和就为：</p><p>$100\times (1-100\times 10)\approx -100000$</p><p>所以 $dp$ 数组中，每一个数字都需要加上 $100000$ 以保证不越界。我们可以定义一个常量 $p=100000$，写代码更加简洁，不过不写也是可以的。</p><p>接着我们计算最大极限情况：$n=100,k=1,a_i=100,b_i=1$</p><p>那么重量总和就为：</p><p>$100\times (100-1\times 1)\approx 10000$</p><p>所以 $dp$ 数组需要开 $110000+5$，这也是最大有可能出现的背包容量。</p><p>最后要注意：因为重量有正有负，所以我们不知道循环是从小到大还是从大到小。所以我没有打滚动，如果要打滚动，需要注意判断重量的正负之后判断循环的顺序。</p><p>打代码要注意细节，我错了很多次才对。</p><p>（PS：我打代码的时候觉得 $a_i-b_i\times k$ 看着不爽，就改成了 $b_i\times k-a_i$，这样在分析极限值的时候有变化，需要注意。）</p><h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b)</span></span><br><span class="line"><span class="keyword">int</span> n,k,a[<span class="number">105</span>],b[<span class="number">105</span>],m[<span class="number">105</span>],dp[<span class="number">105</span>][<span class="number">110005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">10000</span>]=<span class="number">0</span>; <span class="comment">//最后答案的位置是0</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        m[i]=k*b[i]-a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">110000</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-m[i]&lt;=<span class="number">110000</span>&amp;&amp;j-m[i]&gt;=<span class="number">0</span>)&#123; <span class="comment">//不能越界，越了界后面就没有回来的可能性了，直接跳过此循环</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j-m[i]]==<span class="number">-1</span>)</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]; <span class="comment">//不可能</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-m[i]]+a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[n][<span class="number">10000</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][<span class="number">10000</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="例5-3-多米诺骨牌"><a href="#例5-3-多米诺骨牌" class="headerlink" title="例5-3.多米诺骨牌"></a>例5-3.多米诺骨牌</h3><p><a href="https://www.luogu.com.cn/problem/P1282">题目链接</a></p><p>emmm 这也许是一道转化比较复杂的01背包问题了。</p><p>首先对于每个骨牌，都有转与不转两种抉择，相当于01背包里的“选和不选”。</p><p>其次，要求的是“上下分别之和的差得绝对值”尽量小。为了方便，我们把这个差记为上面减下面的差。假如说我们把第 $i$ 个骨牌的上面点数记为 $a_i$，下面的点数记为 $b_i$，那么每旋转一个骨牌，那么上下和的差就会减少 $2\times (a_i-b_i)$，这个 $2$ 可以约掉。我们可以把这个东西记为第 $i$ 个骨牌旋转后的重量。</p><p>每个骨牌的价值是 $1$，我们要让价值最小。</p><p>但是这道题和上一道题有相同的地方，就是<del>万恶的</del>负重量！于是我们又要分析数据的极限值了 qwq。</p><p>分析过程省略，反正最后出来是 $-5000\sim 5000$。</p><p>所以 $dp$ 数组关于容量的那个下标需要统一加上 $5000$。</p><p>另外还有就是与上面一样，因为重量有正有负，所以打滚动需要注意循环的顺序。</p><p>求答案：那如何让在产生最优的重量时求得最小的价值呢？我们可以把 $dp$ 数组先全部初始化为极大值，只把 $dp_{0,5000}$ 定义为 $0$，在求解答案的过程中，从小到大枚举背包占的容量，只要有一个数字不是极大值，就可以直接输出。不过因为让求的是差的绝对值的最小值，所以枚举的时候，两边（重量为正和负）都需要看一下。</p><h3 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> ans,n,a[<span class="number">1005</span>],b[<span class="number">1005</span>],c[<span class="number">1005</span>],dp[<span class="number">1005</span>][<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">        c[i]=a[i]-b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">127</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">5000</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">10000</span>;j&gt;=c[i];j--)&#123;</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j-c[i]],dp[i<span class="number">-1</span>][j+c[i]]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">5000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="built_in">min</span>(dp[n][<span class="number">5000</span>-i],dp[n][<span class="number">5000</span>+i]);</span><br><span class="line">        <span class="keyword">if</span>(ans!=<span class="number">2139062143</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="例5-4-夏季特惠"><a href="#例5-4-夏季特惠" class="headerlink" title="例5-4.夏季特惠"></a>例5-4.夏季特惠</h3><p><a href="http://222.180.160.110:1024/contest/1559/problem/15">题目链接</a></p><p>题意简述：有 $n$ 个商品，第 $i$ 个商品原价为 $a_i$，打折后的价格为 $b_i$，买到这个东西你的快乐值会增加 $w_i$。你的钱数是无限的，预算为 $m$ 元，只要花的钱不超过 $m$ 或者获得的<strong>总优惠金额</strong>不低于超过预算的总金额，那么你就不会觉得吃亏。现在请你在感觉不吃亏的前提下获得最多的快乐值。</p><p>这道题很明显背包是会根据买的东西变化的。具体表现为：每买一样东西，背包会先减去 $b_i$，再加上 $a_i-b_i$ （获得优惠的金额）。</p><p>那么<del>易证</del>只要买的东西价格满足 $a_i\ge 2\times b_i$，那背包<strong>可用</strong>的容量不仅不会减少，而且可能会增加。</p><p>所以满足上述条件的商品是一定要买的。</p><p>接着考虑剩下的物品。上面已经分析，在买了一个物品后，背包的可用容量 $H$ 就会变成 $H-2\times b_i+a_i$。所以商品的重量可以规定为 $2\times b_i-a_i$。而因为剩下的商品不满足上述条件，所以买了背包的容量是一定会减小的，即剩下的商品重量不会为负数。</p><p>商品的价值是 $w_i$，这个很明显。</p><p>代码实现很简单，哦，对了，记得开 <code>long long</code>。</p><h3 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,x,tot,ans,a[<span class="number">505</span>],b[<span class="number">505</span>],h[<span class="number">505</span>],c[<span class="number">505</span>],w[<span class="number">505</span>],dp[<span class="number">5000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;a[i],&amp;b[i],&amp;h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=<span class="number">2</span>*b[i])&#123;</span><br><span class="line">            x+=a[i]<span class="number">-2</span>*b[i];</span><br><span class="line">            ans+=h[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            w[++tot]=<span class="number">2</span>*b[i]-a[i];</span><br><span class="line">            c[tot]=h[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=x;j&gt;=w[i];j--)&#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans+dp[x]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>01背包这个算法有非常多的变化形式，唯有多看题、刷题、总结题型才能真正掌握。同时它还是后面其它背包问题的基础，所以学好 01 背包是一个十分重要的版块。</p><hr><p>终于写完了！完结撒花！❀╰(*°▽°*)╯❀</p><p><code>Markdown</code> 竟然写了 $900^+$ 行，创历史新高啊 qwq。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
